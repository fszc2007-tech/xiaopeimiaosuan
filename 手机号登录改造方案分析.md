# 手機號登錄統一方案（僅手機號版，含風控增強）

> **版本**: v1.2  
> **創建日期**: 2024年12月  
> **最後更新**: 2024年12月  
> **狀態**: 方案已定稿（可進入實施階段）

---

## 一、背景與目標

### 1.1 背景

* 當前系統處於開發階段，**實際上已經全部用手機號登錄進行聯調和測試**。
* 代碼和數據結構中仍有"支持郵箱"的歷史影子（如 `email` 字段、`phone OR email` 查詢）。
* 未來產品定位明確：
  👉 **全系統只支持「手機號 + 驗證碼」登錄，不再支持郵箱登錄**。

### 1.2 v1.2 目標

在 v1.0 / v1.1 的基礎上，v1.2 做兩件事：

1. **徹底統一為"僅手機號登錄"模型**
   * 刪除郵箱登錄邏輯和字段。
   * 以"完整手機號（含國家碼）"作為唯一登錄憑證和賬號唯一鍵。

2. **引入基礎安全增強能力**
   * 後端使用類似 **libphonenumber** 的能力，對手機號進行**正規化 & 校驗**，避免髒數據入庫。
   * 對短信驗證碼接口增加**風控與頻率限制**：
     * 每手機號：1 分鐘內最多 1 條
     * 每手機號：1 小時內最多 5 條
     * 每手機號：24 小時內最多 10 條
     * 可擴展到 IP / 設備級別

---

## 二、現狀簡要分析

> 用來說明要"清理掉什麼"。

### 2.1 App 前端

* ✅ 已支持手機號 + 驗證碼登錄（測試碼 123456）。
* ✅ 已有 CN / HK 區域概念。
* ❌ 沒有統一的國家碼選擇器，手機號校驗默認按大陸 11 位規則。
* ❌ 類型定義中可能還保留 `email` 字段、郵箱相關註釋。

### 2.2 後端 Core

* ✅ `requestOTP` / `loginOrRegister` 已接受 `phone`。
* ❌ 接口簽名仍然是「`phone?` / `email?` 二選一」風格。
* ❌ SQL 查詢中仍存在 `WHERE phone = ? OR email = ?` 等邏輯。
* ❌ 未對手機號做嚴格"國家碼 + 號碼"的正規化校驗。

### 2.3 數據庫

`users` 表（現狀示意）：

```sql
CREATE TABLE users (
  user_id VARCHAR(36) PRIMARY KEY,
  phone   VARCHAR(20),           
  email   VARCHAR(100),
  ...
  INDEX idx_phone (phone)
);
```

`verification_codes` 表（現狀可能類似）：

```sql
CREATE TABLE verification_codes (
  id         BIGINT PRIMARY KEY AUTO_INCREMENT,
  phone      VARCHAR(20),
  email      VARCHAR(100),
  code       VARCHAR(10),
  scene      VARCHAR(20),
  created_at DATETIME,
  expired_at DATETIME
);
```

---

## 三、設計原則（v1.2）

1. **單一登錄憑證**
   * 登錄只依賴：**完整手機號（含國家碼）**。
   * `users.phone` 必須是**非空 + 唯一**。

2. **存儲格式統一（E.164 風格）**
   * `+<CountryCode><LocalNumber>`
   * 例：`+8613800138000`、`+85291234567`、`+11234567890`。

3. **前後端職責清晰**
   * 前端：國家碼選擇 + 初步格式校驗 + 拼裝完整手機號。
   * 後端：使用 libphonenumber 類庫做正規化、嚴格校驗，並作為**唯一數據真實性裁決**。

4. **安全優先**
   * 所有驗證碼請求必須經過**頻率限制**與**風控檢查**。
   * 防止單號 / 單 IP / 單設備的惡意刷短信。

5. **結構簡潔**
   * 在當前明確"不用郵箱"前提下，**可以直接移除 email 字段及所有相關邏輯**。

---

## 四、核心方案選擇

### 4.1 繼續採用方案 A：存儲完整手機號 ✅

**策略**：`users.phone` 存儲完整手機號（國家碼 + 本地號）。

* 中國大陸：`+8613800138000`
* 香港：`+85291234567`
* 美國：`+11234567890`

**優點**：
* 查詢邏輯簡單：`WHERE phone = ?`。
* 直接作為用戶唯一標識，無需額外 `country_code` 字段。
* 解析前綴即可獲得國家信息，便於後續擴展。

### 4.2 放棄方案 B：分字段存儲 ❌

* 增加 `country_code` 字段、聯合索引，複雜度提高。
* 當前業務沒有強需求，收益不足。

**結論**：
👉 v1.2 繼續採用方案 A，並在此基礎上增加**正規化 + 風控**。

---

## 五、詳細方案設計

### 5.1 數據庫設計

#### 5.1.1 `users` 表（v1.2 最終結構）

```sql
CREATE TABLE users (
  user_id        VARCHAR(36)   PRIMARY KEY,
  phone          VARCHAR(20)   NOT NULL,           -- 完整手機號，如 +8613800138000
  phone_verified TINYINT(1)    NOT NULL DEFAULT 1, -- 後續改號/安全操作可用
  nickname       VARCHAR(50),
  avatar_url     VARCHAR(255),
  region         VARCHAR(10),                      -- 業務區域（可選：'cn' | 'hk' | ...）
  created_at     DATETIME      NOT NULL,
  updated_at     DATETIME      NOT NULL,
  UNIQUE INDEX uniq_phone (phone)
);
```

**從當前開發態演進的 SQL**：

```sql
ALTER TABLE users
  DROP COLUMN email,
  MODIFY COLUMN phone VARCHAR(20) NOT NULL;

ALTER TABLE users
  DROP INDEX idx_phone,
  ADD UNIQUE INDEX uniq_phone (phone);
```

---

#### 5.1.2 `verification_codes` 表

```sql
CREATE TABLE verification_codes (
  id         BIGINT        PRIMARY KEY AUTO_INCREMENT,
  phone      VARCHAR(20)   NOT NULL,     -- 完整手機號
  code       VARCHAR(10)   NOT NULL,
  scene      VARCHAR(20)   NOT NULL,     -- 'login' | 'bind' 等
  created_at DATETIME      NOT NULL,
  expired_at DATETIME      NOT NULL,
  INDEX idx_phone_scene (phone, scene)
);
```

**演進 SQL**：

```sql
ALTER TABLE verification_codes
  DROP COLUMN email,
  MODIFY COLUMN phone VARCHAR(20) NOT NULL;
```

> 說明：不對 `verification_codes` 的 `phone` 做唯一約束，而是通過業務層的限流控制發送頻率。

---

### 5.2 後端 Core 改造

#### 5.2.1 Auth Service 接口簽名（最終）

```ts
// 請求驗證碼
export interface RequestOtpParams {
  phone: string;            // 完整手機號：+8613800138000
  scene: 'login';           // 當前只做登錄，後續可擴展
}

export async function requestOTP(params: RequestOtpParams): Promise<RequestOtpResponseDto> {}

// 登錄 / 註冊二合一
export interface LoginOrRegisterParams {
  phone: string;                      // 完整手機號
  code: string;
  channel?: 'cn' | 'hk' | 'global';   // 可選：埋點或渠道標記
}

export async function loginOrRegister(
  params: LoginOrRegisterParams
): Promise<LoginResponseDto> {}
```

> ✅ `email` 參數完全移除
> ✅ `phone` 為必填

---

#### 5.2.2 手機號正規化 & 校驗（新增重點）

**目標**：無論前端傳什麼，後端統一規範成「合法的完整手機號」，再入庫。

1. 選擇一個類似 **libphonenumber** 的庫（Node 生態常見如 `libphonenumber-js`）。

2. 封裝一個工具函數：

```ts
import { parsePhoneNumberFromString } from 'libphonenumber-js';

export function normalizeAndValidatePhone(rawPhone: string): string {
  // 1. 去掉空格等
  const trimmed = rawPhone.trim();

  // 2. 嘗試解析：如果以 + 開頭，直接按國際格式解析
  const phoneNumber = parsePhoneNumberFromString(trimmed);

  if (!phoneNumber || !phoneNumber.isValid()) {
    throw new Error('INVALID_PHONE');
  }

  // 3. 輸出統一格式（E.164）：+8613800138000
  return phoneNumber.number;
}
```

3. 在 `requestOTP` 和 `loginOrRegister` 的入口統一調用：

```ts
export async function requestOTP({ phone, scene }: RequestOtpParams) {
  const normalizedPhone = normalizeAndValidatePhone(phone);
  // 後續邏輯都使用 normalizedPhone
}

export async function loginOrRegister({ phone, code, channel }: LoginOrRegisterParams) {
  const normalizedPhone = normalizeAndValidatePhone(phone);
  // 使用 normalizedPhone 去查用戶、校驗驗證碼
}
```

> 這樣可以確保：
> * 數據庫裡永遠是標準化後的一致格式；
> * 即使前端有 bug 或被繞過，後端仍有最後一道防線。

---

#### 5.2.3 短信發送風控 & 頻率限制（新增重點）

**目標**：防止短信接口被濫用，控制成本並避免被運營商拉黑。

##### 頻率規則（手機號維度）

* **每手機號：**
  * 1 分鐘內最多 **1 條**
  * 1 小時內最多 **5 條**
  * 24 小時內最多 **10 條**

> 可以先從"手機號維度"開始做，後續再擴展 IP / 設備 ID。

##### 推薦實現方式：Redis + 簡單限流 Key

假設有 Redis，可定義如下 Key 結構：

* `otp:phone:1m:${phone}` → 當前 1 分鐘內的次數
* `otp:phone:1h:${phone}` → 當前 1 小時內的次數
* `otp:phone:1d:${phone}` → 當前 24 小時內的次數

**偽代碼：**

```ts
async function checkAndIncreaseOtpQuota(phone: string) {
  const minuteKey = `otp:phone:1m:${phone}`;
  const hourKey   = `otp:phone:1h:${phone}`;
  const dayKey    = `otp:phone:1d:${phone}`;

  const [mCount, hCount, dCount] = await redis.mget(minuteKey, hourKey, dayKey);

  if ((mCount && Number(mCount) >= 1) ||
      (hCount && Number(hCount) >= 5) ||
      (dCount && Number(dCount) >= 10)) {
    throw new Error('OTP_RATE_LIMITED'); // 前端提示"發送太頻繁，請稍後再試"
  }

  const pipeline = redis.multi();

  pipeline.incr(minuteKey);
  pipeline.expire(minuteKey, 60);        // 60 秒

  pipeline.incr(hourKey);
  pipeline.expire(hourKey, 60 * 60);     // 1 小時

  pipeline.incr(dayKey);
  pipeline.expire(dayKey, 24 * 60 * 60); // 24 小時

  await pipeline.exec();
}
```

在 `requestOTP` 中使用：

```ts
export async function requestOTP({ phone, scene }: RequestOtpParams) {
  const normalizedPhone = normalizeAndValidatePhone(phone);

  // 1. 風控頻率限制
  await checkAndIncreaseOtpQuota(normalizedPhone);

  // 2. 校驗手機號、生成驗證碼、寫表、發短信...
}
```

> 後續可以再加 IP、設備維度的限流（同樣的模式，多加幾個 Key 即可）。

---

#### 5.2.4 登錄 / 註冊邏輯（整合正規化和風控）

1. `requestOTP`：正規化 + 限流 + 發碼
2. `loginOrRegister`：正規化 + 校驗驗證碼 + 查/建用戶 + 發 token

核心偽代碼組合（略，前面已經給過，這裡不重複）。

---

### 5.3 App 前端方案（簡要）

#### 5.3.1 登錄頁面結構

* 國家代碼選擇器（`CountryCodePicker`）
* 手機號輸入框（只填本地號）
* 獲取驗證碼按鈕
* 驗證碼輸入框
* 登錄按鈕

#### 5.3.2 關鍵狀態 & 調用

```ts
const [countryCode, setCountryCode] = useState('+86');
const [phoneLocal, setPhoneLocal] = useState('');
const [otp, setOtp] = useState('');

const fullPhone = `${countryCode}${phoneLocal}`; // +8613800138000

// 獲取驗證碼
await authService.requestOTP({
  phone: fullPhone,
  scene: 'login',
});

// 登錄
await authService.loginOrRegister({
  phone: fullPhone,
  code: otp,
  channel: appRegion === 'HK' ? 'hk' : 'cn',
});
```

#### 5.3.3 前端手機號校驗（與後端配合）

保留你原來的 RegExp 邏輯做體驗優化即可，**最終以後端校驗為準**。

---

### 5.4 Admin 後台方案

* 用戶列表以 `phone` 為核心展示字段。
* 搜索支持完整手機號（去空格後直接傳給後端）。
* 不再提供郵箱搜索/展示。
* 如有手動創建用戶頁面，也使用「國家碼 + 本地號 → 完整手機號」邏輯。

---

## 六、實施步驟（v1.2）

### 階段 1：數據庫結構調整（0.5–1 天）

1. `users`：
   * 刪除 `email` 字段；
   * 修改 `phone` 為 `NOT NULL`；
   * 刪除舊索引，增加 `UNIQUE INDEX uniq_phone (phone)`。

2. `verification_codes`：
   * 刪除 `email` 字段；
   * 修改 `phone` 為 `NOT NULL`。

> 當前無生產數據，風險極低，可一次性執行。

---

### 階段 2：後端 Core 改造（1–1.5 天）

1. 更新 `AuthService`：
   * 接口簽名改為只支持 `phone`；
   * 引入手機號正規化函數（libphonenumber）。

2. 修改 SQL 查詢邏輯：
   * 所有 `WHERE phone = ? OR email = ?` → `WHERE phone = ?`。

3. 增加 `checkAndIncreaseOtpQuota` 限流邏輯：
   * Redis key 設計 & 實現；
   * 接入 `requestOTP` 流程。

---

### 階段 3：App 前端改造（1–2 天）

1. 引入 `CountryCodePicker` 組件。
2. 登錄頁邏輯統一使用 `fullPhone` 調用後端。
3. 更新 `User` 類型，僅保留 `phone`。
4. 清理所有與 email 有關的 UI / 邏輯 / 註釋。

---

### 階段 4：Admin 改造（1 天）

1. 列表展示統一使用手機號。
2. 搜索邏輯統一按手機號（支持有/無空格輸入）。
3. 如有用戶創建/編輯頁面，統一用國家碼 + 本地號。

---

### 階段 5：聯調與測試（1–2 天）

* 前後端打通；
* 驗證不同國家區號的登錄；
* 驗證限流策略是否生效。

---

## 七、測試清單（包含正規化 & 風控）

### 7.1 功能測試

* [ ] 大陸手機號 +86 登錄成功。
* [ ] 香港手機號 +852 登錄成功。
* [ ] 不正確格式手機號前端阻攔。
* [ ] 繞過前端校驗時，後端能返回 `INVALID_PHONE`。
* [ ] 驗證碼錯誤時，返回正確錯誤碼。
* [ ] 驗證碼超時失效邏輯正常。
* [ ] 首次登錄創建用戶，重複登錄復用同一用戶。

### 7.2 正規化測試

* [ ] 帶空格的手機號（`"+86 138 0013 8000"`）能被後端規範成 `+8613800138000`。
* [ ] 輸入本地不合法號碼，後端返回 `INVALID_PHONE`。
* [ ] 數據庫中 `users.phone` 全部為 `+` 開頭的 E.164 格式。

### 7.3 風控 & 限流測試

* [ ] 同一手機號 1 分鐘內連續請求 2 次驗證碼，第 2 次被拒絕。
* [ ] 同一手機號 1 小時內請求超過 5 次，第 6 次被拒絕。
* [ ] 同一手機號 24 小時內請求超過 10 次，第 11 次被拒絕。
* [ ] 不同手機號並發請求互不影響。
* [ ] 限流錯誤碼/文案對用戶友好（例如"發送太頻繁，請稍後再試"）。

### 7.4 Admin 測試

* [ ] 用戶列表中手機號格式展示正確（`+86 13800138000`）。
* [ ] 通過完整手機號搜索可以準確命中對應用戶。
* [ ] 如支持手動創建用戶，創建出的用戶可以在 App 正常登錄。

---

## 八、風險評估

### 8.1 技術風險

1. **手機號解析異常**
   * 依賴 libphonenumber 類庫，若使用不當可能偶爾解析失敗。
   * 對策：對 `INVALID_PHONE` 做清晰的錯誤提示，並在日誌中記錄原始輸入。

2. **Redis 不可用導致限流失效**
   * 對策：
     * Redis 掛了時，短信限流可以回退為"更保守策略"（例如直接禁止發送），避免被刷爆。
     * 或短暫允許放寬（視業務容忍度而定）。

### 8.2 產品/體驗風險

1. **限流規則太嚴格導致部分正常用戶被攔截**
   * 對策：先按"1m/1h/1d"規則上線，結合日誌觀察一段時間後微調閾值。

---

## 九、總結

v1.2 版本在 v1.1 的基礎上：

1. **徹底清掉郵箱歷史包袱**：
   登錄方式、數據庫字段、查詢邏輯全部統一為"完整手機號"。

2. **把手機號當成真正的"主鍵"看待**：
   `users.phone` 非空 + 唯一，所有認證/賬號識別都圍繞它來做。

3. **補上長期一定會想要的兩件事**：
   * 使用 libphonenumber 做**正規化和嚴謹校驗**，確保數據乾淨。
   * 為短信驗證碼加上**頻率限制與風控機制**，避免被惡意刷短信。

這樣一來，你這套手機號登錄體系就是：
**結構簡單、擴展方便、且「看得起」長期運營安全需求的設計**。

---

**文檔版本**: v1.2  
**創建日期**: 2024年12月  
**最後更新**: 2024年12月  
**狀態**: 方案已定稿（可進入實施階段）

