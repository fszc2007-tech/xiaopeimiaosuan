# Core 架构与安全策略方案

> **版本**: v1.0  
> **创建日期**: 2024年11月  
> **状态**: 方案设计阶段  
> **说明**: 本文档中的 "core" 指后端核心服务，与项目目录 `core/` 保持一致

---

## 一、安全策略分析

### 1.1 核心安全原则

**目标**: 保护核心算法、prompt 模板和业务逻辑，防止前端被反编译后泄露核心资产。

**核心原则**:
1. **前端（壳 App）只负责 UI 和状态管理**
2. **所有命盘算法、blocks_json 计算、prompt 模板、计费判断都在 core（后端核心服务）**
3. **壳和 core 只通过 HTTP API 通信**
4. **前端永远看不到 prompt 文本和算法细节**

### 1.2 安全边界划分

```
┌─────────────────────────────────────────┐
│         前端（壳 App）                   │
│  ✅ UI 渲染                              │
│  ✅ 用户交互                             │
│  ✅ 状态管理（Zustand）                  │
│  ✅ 路由导航                             │
│  ✅ HTTP API 调用                        │
│  ❌ 命盘算法                             │
│  ❌ Prompt 模板                          │
│  ❌ Blocks 计算                          │
│  ❌ 计费判断                             │
└──────────────┬──────────────────────────┘
               │ HTTP API (JSON)
               │ Authorization: Bearer <token>
┌──────────────▼──────────────────────────┐
│       Core（后端核心服务）               │
│  ✅ 用户鉴权                             │
│  ✅ 命盘算法（core/engine）              │
│  ✅ Blocks 计算                          │
│  ✅ Prompt 模板管理                      │
│  ✅ 意图识别                             │
│  ✅ LLM 调用                             │
│  ✅ 计费判断                             │
│  ✅ 数据存储（MySQL）                    │
└─────────────────────────────────────────┘
```

### 1.3 安全风险分析

**如果前端包含核心逻辑的风险**:
- ❌ 反编译后可直接获取算法代码
- ❌ 可提取 prompt 模板，复制业务逻辑
- ❌ 可绕过计费限制
- ❌ 可被用于构建"盗版小佩"

**采用 Core-Service 架构的优势**:
- ✅ 算法和 prompt 完全在后端，前端无法获取
- ✅ 计费判断在后端，无法绕过
- ✅ 即使前端被完全反编译，核心资产仍然安全
- ✅ 可以随时更新算法和 prompt，无需发版

---

## 二、架构设计

### 2.1 整体架构

```
┌─────────────────────────────────────────────────────────┐
│                   前端（React Native）                   │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐             │
│  │  UI 层   │  │ 状态管理  │  │ API 调用  │             │
│  └──────────┘  └──────────┘  └──────────┘             │
└──────────────────────┬──────────────────────────────────┘
                       │ HTTPS + JWT
┌──────────────────────▼──────────────────────────────────┐
│              Core（后端核心服务，Node.js/Express）       │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐             │
│  │ 鉴权模块  │  │ 业务模块  │  │ LLM 网关  │             │
│  └──────────┘  └──────────┘  └──────────┘             │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐             │
│  │ 排盘引擎  │  │ Blocks   │  │ Prompt   │             │
│  │ (engine) │  │ Engine   │  │ Templates│             │
│  └──────────┘  └──────────┘  └──────────┘             │
└──────────────────────┬──────────────────────────────────┘
                       │
┌──────────────────────▼──────────────────────────────────┐
│              数据层（MySQL + Redis）                     │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐             │
│  │ 用户数据  │  │ 命盘数据  │  │ 缓存层   │             │
│  └──────────┘  └──────────┘  └──────────┘             │
└─────────────────────────────────────────────────────────┘
```

### 2.2 Core 模块划分

#### 2.2.1 鉴权模块（auth）
- 用户登录/注册
- JWT Token 发放和校验
- 请求鉴权中间件

#### 2.2.2 用户与命盘档案模块（user & profile）
- 用户信息管理
- 命盘档案 CRUD
- 当前命主管理

#### 2.2.3 排盘引擎模块（bazi_engine）
- 调用 `core/engine` 目录下的引擎进行排盘计算
- 真太阳时换算
- 四柱、纳音、节气等基础计算

#### 2.2.4 Blocks 引擎模块（blocks_engine）
- 从命盘生成 `blocks_json`
- 日主强弱、五行分布、用神忌神
- 大运、流年、流月时间线
- 神煞、冲合、通根等指标

#### 2.2.5 意图识别模块（intent_engine）
- 使用 LLM 分析用户问题
- 输出结构化 `intent_json`
- 话题识别、时间范围识别等

#### 2.2.6 Prompt 模板管理模块（prompt_templates）
- 存储系统 prompt 片段
- 存储场景 prompt 模板
- Prompt 拼接逻辑
- **不对外暴露，只在服务端使用**

#### 2.2.7 解读编排模块（reading_engine）
- 根据 scene + intent + blocks 构造最终 prompt
- 调用 LLM
- 解析 `<XA-JSON>` 和 `<XA-TEXT>`
- 返回结构化结果给前端

#### 2.2.8 计费与权限模块（billing & entitlement）
- 订阅状态管理
- 功能解锁判断
- 限流控制

#### 2.2.9 LLM 服务网关（aiService）
- 统一的 LLM 调用接口
- 请求封装和错误处理
- 流式响应支持（可选）

---

## 三、API 设计规范

### 3.1 API 设计原则

1. **RESTful 风格**: 使用标准 HTTP 方法
2. **统一响应格式**: 所有 API 返回统一结构
3. **JWT 鉴权**: 所有业务 API 需要 Token
4. **版本控制**: API 版本化（`/api/v1/...`）
5. **错误处理**: 明确的错误码和错误信息

### 3.2 统一响应格式

```typescript
// 成功响应
interface SuccessResponse<T> {
  success: true;
  data: T;
}

// 错误响应
interface ErrorResponse {
  success: false;
  error: {
    code: string;        // 错误码（如 'RATE_LIMIT_EXCEEDED'）
    message: string;     // 错误信息（用户友好）
    details?: any;       // 错误详情（可选，用于调试）
  };
}
```

### 3.3 核心 API 列表

#### 3.3.1 用户与鉴权

**POST /api/v1/auth/login_or_register**
- 登录/注册（手机号验证码）
- 返回: `{ token, user }`

**POST /api/v1/auth/refresh**
- 刷新 Token

**POST /api/v1/auth/logout**
- 登出

---

#### 3.3.2 命盘相关

**POST /api/v1/bazi/chart**
- 创建命盘（排盘）
- 请求: 出生信息 + 命盘档案信息
- 返回: `{ chart, chart_profile }`
- **内部**: 调用 `bazi_engine` + `blocks_engine`

**GET /api/v1/bazi/charts**
- 获取命盘列表
- 返回: `{ items: Chart[] }`

**GET /api/v1/bazi/charts/:chartId**
- 获取单个命盘详情
- 返回: `{ chart, overview }`
- **注意**: 只返回结果数据，不返回 blocks_json 原始结构

**PUT /api/v1/bazi/charts/:chartId**
- 更新命盘档案信息（名称、关系等）

**DELETE /api/v1/bazi/charts/:chartId**
- 删除命盘档案

---

#### 3.3.3 解读相关

**POST /api/v1/bazi/reading**
- 获取命理解读（核心 API）
- 请求: `{ scene, chartId, message, options }`
- 返回: `{ display_text, json, meta }`
- **内部流程**:
  1. 加载 chart + blocks
  2. 意图识别（intent_engine）
  3. 检查计费/权限
  4. 拼接 prompt（prompt_templates）
  5. 调用 LLM（aiService）
  6. 解析结果（reading_engine）

**POST /api/v1/bazi/intent**（可选）
- 独立意图识别 API
- 请求: `{ chartId, message }`
- 返回: `{ intent }`

---

#### 3.3.4 对话相关

**GET /api/v1/chat/conversations**
- 获取对话列表
- 支持筛选（按命主、日期）

**GET /api/v1/chat/conversations/:conversationId/messages**
- 获取对话消息列表

**POST /api/v1/chat/conversations/:conversationId/messages**
- 发送消息（调用解读 API）

**DELETE /api/v1/chat/conversations/:conversationId**
- 删除对话

---

#### 3.3.5 计费与权限

**GET /api/v1/me/entitlements**
- 查询当前用户权益
- 返回: `{ isVip, vipExpiredAt, features }`

**POST /api/v1/me/subscribe**
- 订阅 Pro（调用支付接口）

---

### 3.4 API 安全要求

**必须遵守**:
- ✅ 所有业务 API 需要 JWT Token（除登录/注册）
- ✅ 使用 HTTPS（生产环境）
- ✅ 请求频率限制（防止滥用）
- ✅ 输入验证和 SQL 注入防护
- ✅ 敏感信息不返回给前端（prompt、算法细节）

**禁止行为**:
- ❌ 通过 API 返回 prompt 模板
- ❌ 通过 API 返回 blocks_json 的完整内部结构
- ❌ 通过 API 返回算法代码或配置
- ❌ 在前端进行计费判断（只做 UI 展示控制）

---

## 四、系统化安全策略实施方案

### 4.1 开发规范文档

创建以下规范文档，作为**系统级要求**：

#### 4.1.1 前端开发规范（Frontend Rules）

**文件**: `app.doc/前端开发安全规范.md`

**核心规则**:
1. **禁止在前端实现命盘算法**
   - 所有排盘计算必须调用 `POST /api/v1/bazi/chart`
   - 禁止在前端代码中引入 `core/engine` 目录

2. **禁止在前端存储 prompt 模板**
   - 所有 LLM 调用必须通过 `POST /api/v1/bazi/reading`
   - 禁止在前端代码中硬编码 prompt 文本

3. **禁止在前端进行计费判断**
   - 计费判断逻辑必须在后端
   - 前端只能根据 `GET /api/v1/me/entitlements` 的返回控制 UI 展示
   - 后端 API 必须二次校验权限

4. **禁止在前端计算 blocks_json**
   - 所有 blocks 相关数据必须从后端 API 获取
   - 前端只负责展示，不进行计算

5. **API 调用规范**
   - 所有 API 调用必须通过统一的 `apiService`
   - 必须携带 JWT Token
   - 必须处理错误响应

---

#### 4.1.2 后端开发规范（Backend Rules）

**文件**: `app.doc/后端开发安全规范.md`

**核心规则**:
1. **Prompt 模板管理**
   - 所有 prompt 模板必须在 `core-service` 内部管理
   - 使用配置文件或数据库存储 prompt 片段
   - 禁止通过 API 返回 prompt 模板给前端

2. **算法保护**
   - 所有命盘算法调用 `core/engine`
   - 算法逻辑不对外暴露
   - 只返回计算结果，不返回计算过程

3. **Blocks 计算**
   - Blocks 计算在服务端完成
   - 返回给前端的数据是**结果数据**，不是原始 blocks_json 结构
   - 可以返回简化版或转换后的数据结构

4. **计费判断**
   - 所有需要计费的功能必须在后端判断
   - 前端请求时进行权限校验
   - 返回明确的错误信息（如"需要 Pro 权限"）

5. **API 设计**
   - 所有 API 必须进行鉴权
   - 敏感数据不返回给前端
   - 使用统一的错误响应格式

---

### 4.2 代码检查清单

创建代码审查检查清单，确保每次提交都符合安全规范：

**文件**: `app.doc/代码审查安全检查清单.md`

**前端检查项**:
- [ ] 是否在前端代码中引入了 `core/engine`？
- [ ] 是否在前端代码中硬编码了 prompt 文本？
- [ ] 是否在前端进行了计费判断（而非仅 UI 控制）？
- [ ] 是否在前端计算了 blocks_json？
- [ ] 所有 API 调用是否通过统一的 `apiService`？
- [ ] 是否所有 API 调用都携带了 Token？

**后端检查项**:
- [ ] 是否通过 API 返回了 prompt 模板？
- [ ] 是否返回了完整的 blocks_json 内部结构？
- [ ] 是否在 API 中进行了权限校验？
- [ ] 是否返回了算法代码或配置？
- [ ] 敏感信息是否被正确过滤？

---

### 4.3 项目结构规范

#### 4.3.1 前端项目结构

```
src/
├── screens/              # 页面组件（只负责 UI）
├── components/           # UI 组件（只负责展示）
├── navigation/           # 路由导航
├── store/                # 状态管理（只管理 UI 状态）
├── services/
│   └── api/              # API 调用层（统一封装）
│       ├── client.ts     # HTTP 客户端
│       ├── authService.ts
│       ├── chartService.ts
│       ├── readingService.ts
│       └── endpoints.ts  # API 路径常量
├── types/                # TypeScript 类型定义
└── theme/                # UI 主题

❌ 禁止在前端项目中包含：
- core/engine（排盘算法）
- prompt 模板文件
- blocks 计算逻辑
- 计费判断逻辑
```

#### 4.3.2 后端项目结构

```
core/
├── src/
│   ├── modules/
│   │   ├── auth/         # 鉴权模块
│   │   ├── user/         # 用户模块
│   │   ├── bazi/         # 命盘模块
│   │   │   ├── engine/   # 调用 core/engine
│   │   │   └── blocks/   # Blocks 计算
│   │   ├── intent/       # 意图识别
│   │   ├── reading/      # 解读编排
│   │   ├── prompt/       # Prompt 模板管理（不对外暴露）
│   │   ├── billing/      # 计费模块
│   │   └── ai/           # LLM 服务网关
│   ├── routes/           # API 路由
│   ├── middleware/       # 中间件（鉴权、限流等）
│   └── utils/            # 工具函数
├── core/
│   └── engine/           # 八字引擎（算法）
└── config/
    └── prompts/          # Prompt 模板配置（不对外暴露）
```

---

### 4.4 开发流程规范

#### 4.4.1 新功能开发流程

1. **需求分析**
   - 明确功能属于前端还是后端
   - 确认是否需要调用后端 API

2. **API 设计**
   - 如果是新功能，先设计 API 接口
   - 确认 API 返回的数据结构
   - 确认是否需要权限校验

3. **后端开发**
   - 实现 API 接口
   - 确保不返回敏感信息
   - 进行权限校验

4. **前端开发**
   - 调用后端 API
   - 只负责 UI 展示
   - 不实现业务逻辑

5. **代码审查**
   - 使用安全检查清单
   - 确保符合安全规范

---

#### 4.4.2 代码审查流程

**必须检查项**:
1. 前端代码是否包含核心算法？
2. 前端代码是否包含 prompt 模板？
3. 前端代码是否进行计费判断？
4. 后端 API 是否返回敏感信息？
5. 后端 API 是否进行权限校验？

**审查工具**:
- ESLint 规则（禁止引入 `core/engine`）
- Git Hooks（提交前检查）
- CI/CD 检查（自动化检查）

---

### 4.5 技术实现方案

#### 4.5.1 前端安全措施

**1. ESLint 规则**
```javascript
// .eslintrc.js
module.exports = {
  rules: {
    'no-restricted-imports': [
      'error',
      {
        patterns: [
          {
            group: ['**/core/engine/**'],
            message: '禁止在前端代码中引入 core/engine，所有排盘计算必须通过 API 调用。',
          },
        ],
      },
    ],
  },
};
```

**2. 类型检查**
```typescript
// 禁止在前端定义 prompt 相关类型
// 禁止在前端定义 blocks_json 完整结构类型
// 只定义 API 返回的简化数据结构类型
```

**3. API 调用封装**
```typescript
// src/services/api/client.ts
// 统一封装所有 API 调用
// 自动添加 Token
// 统一错误处理
```

---

#### 4.5.2 后端安全措施

**1. Prompt 模板管理**
```typescript
// core/src/modules/prompt/templates.ts
// 所有 prompt 模板集中管理
// 不通过 API 暴露
// 只在服务端使用
```

**2. 数据过滤中间件**
```typescript
// 过滤敏感信息
// 只返回前端需要的数据
// 不返回 blocks_json 完整结构
```

**3. 权限校验中间件**
```typescript
// 所有业务 API 必须经过权限校验
// 计费功能必须检查用户权限
```

---

### 4.6 监控与审计

#### 4.6.1 日志记录

**记录内容**:
- API 调用日志（不记录敏感信息）
- 错误日志
- 性能日志

**不记录内容**:
- ❌ 完整的 prompt 文本
- ❌ 用户敏感信息（密码、完整命盘数据）
- ❌ 算法内部计算过程

#### 4.6.2 安全审计

**定期检查**:
- 前端代码是否包含核心算法
- API 是否返回敏感信息
- 权限校验是否完整

---

## 五、实施建议

### 5.1 分阶段实施

#### 阶段一：规范制定（已完成）✅
1. ✅ 创建前端开发安全规范文档（`前端开发安全规范.md`）
2. ✅ 创建后端开发安全规范文档（`后端开发安全规范.md`）
3. ✅ 创建代码审查安全检查清单（`代码审查安全检查清单.md`）
4. ✅ 创建 Core 架构与安全策略方案（本文档）

#### 阶段二：工具配置（1-2天）
1. 配置 ESLint 规则
2. 配置 Git Hooks
3. 配置 CI/CD 检查

#### 阶段三：团队培训（1天）
1. 向团队讲解安全策略
2. 讲解开发规范
3. 讲解代码审查流程

#### 阶段四：持续监控（长期）
1. 代码审查时使用检查清单
2. 定期安全审计
3. 根据实际情况调整规范

---

### 5.2 建议的文档结构

```
app.doc/
├── security/                          # 安全策略文档目录
│   ├── Core架构与安全策略方案.md      # 本文档（总体方案）
│   ├── 前端开发安全规范.md            # 前端必须遵守的规则 ✅ 已创建
│   ├── 后端开发安全规范.md            # 后端必须遵守的规则 ✅ 已创建
│   └── 代码审查安全检查清单.md        # 代码审查时使用 ✅ 已创建
└── features/                          # App 功能设计文档目录
    └── ...                            # 所有功能设计文档
```

---

### 5.3 与现有文档的整合

**更新 `APP开发文档.md`**:
- 添加"安全策略"章节
- 引用前端/后端开发安全规范
- 在开发流程中强调安全检查

**更新 `数据库与API设计方案.md`**:
- 明确 API 设计的安全要求
- 强调不返回敏感信息

---

## 六、关键检查点

### 6.1 开发前检查

- [ ] 功能需求是否明确前端/后端职责？
- [ ] 是否需要设计新 API？
- [ ] API 设计是否符合安全规范？

### 6.2 开发中检查

- [ ] 前端是否只负责 UI？
- [ ] 后端是否进行了权限校验？
- [ ] 是否返回了敏感信息？

### 6.3 代码审查检查

- [ ] 使用安全检查清单
- [ ] 确保符合安全规范
- [ ] 确保不泄露核心资产

---

## 七、常见问题

### Q1: 前端能否缓存排盘结果？

**A**: 可以，但只能缓存 API 返回的结果数据，不能缓存算法或 blocks_json 的完整结构。

### Q2: 前端能否进行简单的数据格式化？

**A**: 可以，但仅限于展示层面的格式化（如日期格式化、文本截断等），不能进行业务逻辑计算。

### Q3: 如何确保后端 API 不返回敏感信息？

**A**: 
- 使用数据过滤中间件
- 定义明确的 API 响应类型
- 代码审查时检查

### Q4: Prompt 模板如何管理？

**A**: 
- 存储在服务端配置文件或数据库
- 使用模块化管理（按场景分类）
- 不通过 API 暴露给前端

---

## 八、总结

### 8.1 核心原则

1. **前端只负责 UI，不包含核心逻辑**
2. **所有算法、prompt、计费判断都在后端**
3. **通过 API 通信，前端无法获取核心资产**
4. **系统化规范，确保持续遵循**

### 8.2 实施方式

**建议采用"规范文档 + 工具检查 + 代码审查"的组合方式**:

1. **规范文档**: 作为系统级要求，所有开发必须遵循
2. **工具检查**: ESLint、Git Hooks、CI/CD 自动化检查
3. **代码审查**: 使用检查清单，人工审查

### 8.3 下一步行动

1. ✅ 创建前端开发安全规范文档
2. ✅ 创建后端开发安全规范文档
3. ✅ 创建代码审查安全检查清单
4. 配置 ESLint 规则和 Git Hooks
5. 团队培训和宣贯

---

**文档版本**: v1.0  
**最后更新**: 2024年11月  
**维护者**: 开发团队

