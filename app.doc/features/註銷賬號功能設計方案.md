# 註銷賬號功能設計方案

**版本**: v1.1（優化版）  
**日期**: 2025-12-16  
**狀態**: 設計階段（已優化關鍵問題）

**更新記錄**:
- v1.1: 優化 token_version 與 refresh token 策略、白名單匹配邏輯、時區策略、訂閱匿名化方案、並發保護、Blocking page 按鈕語義

---

## 0. 目標與非目標

### 目標

1. **用戶發起註銷**：帳號立即停用、立即登出、進入 7 天寬限期
2. **寬限期內**：用戶可以透過重新登入進入「帳號待刪除」Blocking page，並撤銷註銷恢復使用
3. **到期後**：自動執行不可逆刪除；users 保留最小 tombstone 記錄（DELETED + deleted_at，無 PII）
4. **若存在付款/訂閱**：交易/訂閱流水保留，但與用戶的關聯做不可逆匿名化

### 非目標

- ❌ 不做「輸入註銷」文字確認
- ❌ 不做長按/二次點擊防誤觸
- ❌ UI 不展示「將刪除哪些資料」清單（僅保留精簡提示）

---

## 1. 狀態機與核心規則

### 1.1 帳號狀態

```typescript
enum UserStatus {
  ACTIVE = 'ACTIVE',           // 正常使用
  PENDING_DELETE = 'PENDING_DELETE',  // 待刪除（7天寬限期）
  DELETED = 'DELETED'          // 已刪除（tombstone）
}
```

### 1.2 時間欄位（users 表新增）

| 欄位名 | 類型 | 說明 |
|--------|------|------|
| `status` | ENUM('ACTIVE', 'PENDING_DELETE', 'DELETED') | 帳號狀態，默認 'ACTIVE' |
| `delete_requested_at` | TIMESTAMP NULL | 發起註銷時間（UTC） |
| `delete_scheduled_at` | TIMESTAMP NULL | 計劃刪除時間（UTC，delete_requested_at + 7天） |
| `deleted_at` | TIMESTAMP NULL | 實際刪除時間（UTC，Job 執行時） |
| `token_version` | INT NOT NULL DEFAULT 0 | Token 版本號（用於立即失效） |

**時區策略**:
- **全站統一使用 UTC 時區**存儲所有時間字段
- `NOW()` 使用 `UTC_TIMESTAMP()` 或應用層統一轉換為 UTC
- API 返回時間一律使用 ISO 8601 格式（含時區標識，如 `2025-12-23T00:00:00Z`）
- 前端展示時根據用戶時區轉換
- Job 服務器與 API 服務器必須使用相同時區配置（建議 UTC）

### 1.3 行為轉換

```
發起註銷：ACTIVE -> PENDING_DELETE
  - 設置 delete_requested_at = NOW()
  - 設置 delete_scheduled_at = NOW() + 7 DAYS
  - token_version++（立即失效所有 token）

撤銷註銷：PENDING_DELETE -> ACTIVE（必須 NOW() < delete_scheduled_at）
  - 清除 delete_requested_at
  - 清除 delete_scheduled_at
  - token_version++（確保安全）

到期刪除：PENDING_DELETE -> DELETED（Job 執行後）
  - 設置 deleted_at = NOW()
  - 清除所有 PII
  - 保留 tombstone 記錄
```

### 1.4 索引設計

```sql
-- 用於 Job 掃描待刪除帳號
INDEX idx_users_delete_due (status, delete_scheduled_at)

-- 用於查詢特定狀態的用戶
INDEX idx_users_status (status)
```

---

## 2. UI / UX（完整閉環）

### 2.1 設置頁入口

**位置**: `app/src/screens/Settings/SettingsScreen.tsx`

- 在「退出登錄」按鈕上方添加「註銷賬號」按鈕
- 樣式：警告色（橙色 `colors.warning` 或紅色 `colors.error`）
- 圖標：`Trash2` (lucide-react-native)
- 文案：「註銷賬號」

### 2.2 二次確認 Modal

**組件**: 使用現有的 `ConfirmDialog` 或 `MessageDialog`

**標題**: 「確認註銷賬號」

**內容**:
```
帳號將立即停用並登出。

資料將在 7 天後永久刪除，屆時無法恢復。
```

**按鈕**:
- 「取消」（主要按鈕，灰色）
- 「確認註銷」（警告色按鈕）

### 2.3 註銷提交後前端行為

**流程**:
1. 調用 `POST /api/v1/account/deletion-request`
2. 成功後：
   - 清除本地 `access token` / `refresh token` / `cache`
   - 調用 `authStore.logout()` 清除本地狀態
   - 跳轉登入頁（由 `RootNavigator` 自動處理）
   - 顯示 Toast 提示：「已提交註銷申請，可在 7 天內重新登入撤銷」

### 2.4 登入後 Blocking page（核心設計）

**觸發條件**: 用戶重新登入成功後（身份驗證通過）

**路由邏輯**:
```typescript
// 在 RootNavigator 或登入成功後檢查
if (user.status === 'PENDING_DELETE') {
  // 不進入 App 主流程
  // 直接導向 Blocking page
  navigation.navigate('AccountDeletionPending');
}
```

**Blocking page 內容** (`app/src/screens/AccountDeletionPending/AccountDeletionPendingScreen.tsx`):

1. **顯示信息**:
   - 標題：「帳號待刪除」
   - 說明：「您的帳號將於 YYYY-MM-DD 永久刪除」
   - 提示：「在此日期前，您可以撤銷註銷申請」

2. **按鈕**:
   - **「撤銷註銷」**（主按鈕，綠色）
     - 調用 `POST /api/v1/account/deletion-cancel`
     - 成功後重新拉取 profile（調用 `GET /api/v1/auth/me`）
     - 進入 App 主流程
   - **「返回登入頁」**或**「登出」**（次按鈕，灰色）
     - 文案建議：「返回登入頁」或「登出」
     - 二級說明（可選）：「您可等待系統於 YYYY-MM-DD 自動刪除」
     - 行為：
       - 調用 `POST /api/v1/auth/logout`（可選）
       - 清 token
       - 回登入頁
     - **注意**: 避免用戶誤以為點擊會「立刻執行刪除」，明確說明是「返回登入頁」或「登出」

**注意**: Blocking page 不應展示任何產品功能入口；這是「停用但可撤銷」的核心設計。

---

## 3. 後端授權策略

### 3.1 PENDING_DELETE API 白名單（必做）

**位置**: `core/src/middleware/authMiddleware.ts` 或類似的中間件

**規則**: 當 `users.status = 'PENDING_DELETE'` 時，只允許以下 endpoint（其餘全部 `403 ACCOUNT_PENDING_DELETE`）：

**白名單結構**（method + path pattern）:
```
GET  /api/v1/account/deletion-status
POST /api/v1/account/deletion-cancel
POST /api/v1/auth/logout
GET  /api/v1/auth/me
```

**注意**: **不包含** `/api/v1/auth/refresh`（見第 6.2 節說明）

**實現邏輯**:
```typescript
// 在認證中間件中
if (user.status === 'PENDING_DELETE') {
  // 白名單：method + normalized path
  const allowedRoutes = [
    { method: 'GET', path: '/api/v1/account/deletion-status' },
    { method: 'POST', path: '/api/v1/account/deletion-cancel' },
    { method: 'POST', path: '/api/v1/auth/logout' },
    { method: 'GET', path: '/api/v1/auth/me' }
  ];
  
  // Path 規範化：去除尾部斜杠、query string、路由參數
  const normalizePath = (path: string) => {
    // 移除 query string
    const pathWithoutQuery = path.split('?')[0];
    // 移除尾部斜杠（除非是根路徑）
    return pathWithoutQuery.replace(/\/$/, '') || '/';
  };
  
  const normalizedPath = normalizePath(req.path);
  const isAllowed = allowedRoutes.some(route => 
    route.method === req.method && 
    route.path === normalizedPath
  );
  
  if (!isAllowed) {
    return res.status(403).json({
      success: false,
      error: {
        code: 'ACCOUNT_PENDING_DELETE',
        message: '帳號待刪除，僅允許撤銷或登出操作'
      }
    });
  }
}
```

**安全考慮**:
- 使用 `method + normalized path` 精確匹配，避免路徑繞過
- 去除尾部斜杠、query string，統一比較基準
- 不支持通配符或前綴匹配，確保白名單精確可控

### 3.2 認證層對 DELETED

**規則**: `users.status = 'DELETED'` 時，登入/refresh 一律拒絕

**響應**: `410 GONE` 或 `404`（避免暴露帳號存在性）

---

## 4. API 設計（完整）

### 4.1 發起註銷（進入寬限期）

**端點**: `POST /api/v1/account/deletion-request`

**路由文件**: `core/src/routes/account.ts`（新建）

**認證**: 需要有效 access token

**請求體**: 無（從 token 中獲取 user_id）

**響應 200**:
```json
{
  "success": true,
  "data": {
    "status": "PENDING_DELETE",
    "deleteScheduledAt": "2025-12-23T00:00:00Z"
  }
}
```

**服務端行為（冪等）**:

1. **若 status=ACTIVE**:
   - `status = 'PENDING_DELETE'`
   - `delete_requested_at = UTC_TIMESTAMP()`（使用 UTC）
   - `delete_scheduled_at = UTC_TIMESTAMP() + INTERVAL 7 DAY`（使用 UTC）
   - `token_version++`（立即作廢既有 token）
   - **revoke 所有 refresh token**（見第 6.2 節）
   - 審計日誌：`DELETION_REQUEST`

2. **若 status=PENDING_DELETE**:
   - 不重置時間（保持首次 request 的 schedule）
   - 返回既有 `delete_scheduled_at`

**錯誤碼**:
- `401 UNAUTHORIZED`: 未登入
- `500 INTERNAL_SERVER_ERROR`: 數據庫錯誤

### 4.2 查詢刪除狀態（Blocking page 用）

**端點**: `GET /api/v1/account/deletion-status`

**認證**: 允許 ACTIVE 與 PENDING_DELETE

**響應 200**:
```json
{
  "success": true,
  "data": {
    "status": "PENDING_DELETE",
    "deleteScheduledAt": "2025-12-23T00:00:00Z",
    "serverNow": "2025-12-16T03:12:00Z"
  }
}
```

**注意**: 
- `deleteScheduledAt` 和 `serverNow` 一律使用 UTC 時區（ISO 8601 格式，以 `Z` 結尾）
- 前端根據用戶時區轉換顯示

**用途**: Blocking page 顯示倒計時

### 4.3 撤銷註銷

**端點**: `POST /api/v1/account/deletion-cancel`

**認證**: 只允許 PENDING_DELETE

**請求體**: 無

**響應 200**:
```json
{
  "success": true,
  "data": {
    "status": "ACTIVE"
  }
}
```

**服務端行為**:

1. **檢查與更新（原子操作）**:
   ```sql
   UPDATE users 
   SET 
     status = 'ACTIVE',
     delete_requested_at = NULL,
     delete_scheduled_at = NULL,
     token_version = token_version + 1
   WHERE 
     user_id = ? 
     AND status = 'PENDING_DELETE' 
     AND delete_scheduled_at > UTC_TIMESTAMP()
   ```
   - 使用**條件更新**確保原子性
   - 檢查 `affected_rows = 1`，否則返回錯誤

2. **審計日誌**: `DELETION_CANCEL`

**並發保護**:
- 使用 `WHERE` 條件確保只有滿足條件的記錄才會更新
- 若 `affected_rows = 0`，說明已過期或狀態不符，返回 `409 CANNOT_CANCEL_DELETION_EXPIRED` 或 `409 CANNOT_CANCEL_DELETION_INVALID_STATE`

**錯誤碼**:
- `409 CANNOT_CANCEL_DELETION_EXPIRED`: 已超過可撤銷期限
- `409 CANNOT_CANCEL_DELETION_INVALID_STATE`: 狀態不符（非 PENDING_DELETE）
- `401 UNAUTHORIZED`: 未登入

---

## 5. SQL 表設計

### 5.1 users 表新增欄位（Migration）

**文件**: `core/src/database/migrations/XXX_add_account_deletion_fields.sql`

```sql
ALTER TABLE users
  ADD COLUMN status ENUM('ACTIVE', 'PENDING_DELETE', 'DELETED') 
    NOT NULL DEFAULT 'ACTIVE' AFTER app_region,
  ADD COLUMN delete_requested_at TIMESTAMP NULL AFTER status,
  ADD COLUMN delete_scheduled_at TIMESTAMP NULL AFTER delete_requested_at,
  ADD COLUMN deleted_at TIMESTAMP NULL AFTER delete_scheduled_at,
  ADD COLUMN token_version INT NOT NULL DEFAULT 0 AFTER deleted_at;

-- 索引
CREATE INDEX idx_users_delete_due ON users(status, delete_scheduled_at);
CREATE INDEX idx_users_status ON users(status);
```

**時區配置**:
- 使用 `TIMESTAMP` 類型（MySQL 自動處理時區轉換）
- 確保 MySQL 服務器時區設置為 UTC（`SET time_zone = '+00:00'`）
- 或在應用層統一使用 `UTC_TIMESTAMP()` 寫入

### 5.2 Tombstone（最小保留策略）

**到期刪除後，不刪 users row，而是**:

1. `status = 'DELETED'`
2. `deleted_at = UTC_TIMESTAMP()`（使用 UTC）
3. `delete_requested_at = NULL`
4. `delete_scheduled_at = NULL`
5. **清除/替換所有 PII 欄位**:
   - `phone = NULL`（若允許）或 `CONCAT('deleted_', SUBSTRING(MD5(CONCAT(user_id, RAND())), 1, 16))`
   - `email = NULL`（若允許）或 `CONCAT('deleted_', SUBSTRING(MD5(CONCAT(user_id, RAND())), 1, 16), '@example.invalid')`
   - `nickname = NULL`
   - `avatar = NULL`
   - `password_hash = NULL`（已無用）

6. **清除第三方 subject 與關聯**:
   - 若存在 OAuth 關聯表（如 `oauth_identities`），清除 `provider_user_id`、`subject` 等欄位
   - 若存在設備 token 表（如 `device_tokens`），清除所有設備綁定

7. **清除外部存儲與索引**:
   - **對象存儲**（S3/OSS）:
     - 刪除用戶頭像（`avatar` 欄位對應的文件）
     - 刪除聊天附件（通過 `messages` 表關聯的附件）
     - 若使用延遲刪除策略，標記為待刪除
   - **全文索引/向量庫**（如有）:
     - 刪除聊天記錄的全文索引
     - 刪除 embedding 向量（若使用 AI 檢索）
   - **搜索索引**（如有）:
     - 從搜索服務（如 Elasticsearch）中刪除用戶相關文檔

**好處**:
- 審計需要（保留 user_id）
- 避免主鍵衝突
- 避免唯一索引佔用導致新用戶無法註冊
- 保留外鍵完整性（其他表的 `user_id` 仍有效）

### 5.3 反註冊保護（產品策略選擇）

**問題**: Tombstone 清空 `phone`/`email` 可以釋放唯一鍵；但產品是否允許「同手機號重新註冊新帳號」需要明確。

**方案 A（允許重新註冊）**: 
- 當前做法 OK（清空 `phone`/`email` 後，唯一鍵釋放）
- 新用戶可以使用相同手機號註冊新帳號
- **適用場景**: 用戶可能換號碼，或希望重新開始

**方案 B（不允許重新註冊）**:
- 需要另設 `phone_hash`（不可逆）永久保留來阻斷重建
- 在 `users` 表新增 `phone_hash` 欄位（SHA256 哈希）
- 刪除時不清空 `phone_hash`，保留用於阻斷
- 註冊時檢查 `phone_hash` 是否已存在（即使 `phone` 為 NULL）
- **適用場景**: 防止用戶反覆註冊/註銷，或合規要求

**建議**: 根據產品策略選擇，文檔中需明確說明採用哪種方案。

### 5.3 審計日誌表（可選）

**文件**: `core/src/database/migrations/XXX_create_account_audit_logs.sql`

```sql
CREATE TABLE IF NOT EXISTS account_audit_logs (
  log_id VARCHAR(36) PRIMARY KEY,
  user_id VARCHAR(36) NOT NULL,
  action ENUM('DELETION_REQUEST', 'DELETION_CANCEL', 'DELETION_EXECUTED') NOT NULL,
  created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  request_id VARCHAR(100),
  result VARCHAR(50),
  error_code VARCHAR(50),
  ip_hash VARCHAR(64) COMMENT 'IP 哈希（不含 PII）',
  ua_hash VARCHAR(64) COMMENT 'User-Agent 哈希',
  INDEX idx_user_id (user_id),
  INDEX idx_action (action),
  INDEX idx_created_at (created_at)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

---

## 6. Token / Session 立即失效

### 6.1 token_version（推薦方案）

**實現位置**: `core/src/modules/auth/authService.ts` 和 JWT 驗證中間件

**JWT Payload 結構**:
```typescript
{
  userId: string;
  tv: number;  // token_version
  iat: number;
  exp: number;
}
```

**驗證邏輯**:
```typescript
// 在 JWT 驗證中間件中
const decoded = jwt.verify(token, JWT_SECRET);
const user = await getUserById(decoded.userId);

if (decoded.tv !== user.token_version) {
  throw new Error('Token 已失效');
}
```

**deletion-request 時**:
```sql
UPDATE users SET token_version = token_version + 1 WHERE user_id = ?;
```

**deletion-cancel 時**:
```sql
UPDATE users SET token_version = token_version + 1 WHERE user_id = ?;
```

### 6.2 refresh token（若存在）

**策略選擇（推薦方案 1）**:

#### 方案 1（推薦）：deletion-request 時 revoke 所有 refresh token

**deletion-request 時**:
```sql
UPDATE refresh_tokens SET revoked_at = UTC_TIMESTAMP() WHERE user_id = ?;
```

**影響**:
- 用戶**必須重新走登入流程**才能進入 Blocking page
- 無法通過 refresh token 獲取新的 access token
- 確保用戶在 Blocking page 使用的是「重新登入後拿到的新 token」

**deletion-cancel 時**:
- 用戶已重新登入，會自動獲得新的 refresh token（若系統支持）
- 或要求用戶重新登入（更安全）

**白名單策略**:
- **不包含** `/api/v1/auth/refresh` 在白名單中
- 因為 refresh token 已被 revoke，refresh 請求會失敗

#### 方案 2（不推薦）：不 revoke refresh，只靠 token_version 失效 access

**複雜度更高，容易出邊界 bug**:
- 需要同時檢查 `token_version` 和 `status`
- refresh 產生的新 access token 仍需限制白名單
- 可能出現 token 版本不一致的邊界情況

**結論**: **採用方案 1**，確保流程簡單清晰，避免邊界問題。

---

## 7. 後台刪除 Job（7 天到期）

### 7.1 掃描條件

**文件**: `core/src/jobs/accountDeletionJob.ts`（新建）

**查詢**:
```sql
SELECT user_id FROM users 
WHERE status = 'PENDING_DELETE' 
  AND delete_scheduled_at <= UTC_TIMESTAMP()
LIMIT 200;
```

**並發保護**:
- 對每個 user 使用 `SELECT ... FOR UPDATE` 鎖住行
- 再次確認仍滿足條件（`status = 'PENDING_DELETE' AND delete_scheduled_at <= UTC_TIMESTAMP()`）
- 若條件不滿足（可能被 cancel），跳過該用戶
- 確保同一用戶不會被多個 worker 重複處理

### 7.2 執行要求

- **分批處理**: 每批 200 個用戶
- **冪等性**: 每個 user 刪除流程可重跑
- **Job Log**: 記錄執行結果（不含 PII）
- **錯誤處理**: 單個用戶失敗不影響整批

### 7.2.1 Job 可觀測性（重要）

**記錄內容**:
- 刪除了多少 `messages`、多少 `charts`、多少 `attachments`
- 總耗時（每個用戶的處理時間）
- 失敗原因（錯誤碼）
- 成功/失敗計數

**用途**: 對排障非常關鍵，便於監控與優化

**實現建議**:
```typescript
interface JobLog {
  jobId: string;
  startTime: Date;
  endTime: Date;
  totalUsers: number;
  successCount: number;
  failureCount: number;
  deletedCounts: {
    messages: number;
    charts: number;
    attachments: number;
    // ...
  };
  errors: Array<{
    userId: string;
    errorCode: string;
    errorMessage: string;
  }>;
}
```

### 7.3 刪除順序（建議）

1. **聊天相關**:
   - `messages`（通過 `conversation_id` 關聯）
   - `conversations`
   - 附件（若有）

2. **命盤與分析**:
   - `readings`
   - `bazi_charts`（通過 `chart_profile_id` 關聯）
   - `chart_profiles`

3. **綁定與設備**:
   - `user_settings`
   - `rate_limits`
   - `feedbacks`（user_id 設為 NULL，保留反饋內容）

4. **會員權益**:
   - `subscriptions`（見第 8 節：匿名化處理）

5. **外部存儲與派生索引**（重要）:
   - **對象存儲**（S3/OSS）:
     - 刪除用戶頭像（`avatar` 欄位對應的文件）
     - 刪除聊天附件（通過 `messages` 表關聯的附件）
     - 若使用延遲刪除策略，標記為待刪除
   - **全文索引/向量庫**（如有）:
     - 刪除聊天記錄的全文索引
     - 刪除 embedding 向量（若使用 AI 檢索）
   - **搜索索引**（如有）:
     - 從搜索服務（如 Elasticsearch）中刪除用戶相關文檔

6. **第三方 subject 與關聯**:
   - OAuth 關聯表（如 `oauth_identities`）: 清除 `provider_user_id`、`subject` 等欄位
   - 設備 token 表（如 `device_tokens`）: 清除所有設備綁定

7. **users tombstone**:
   - 更新 `status = 'DELETED'`
   - 設置 `deleted_at = UTC_TIMESTAMP()`
   - 清除 PII（見第 5.2 節）

### 7.4 Job 調度

**建議**: 使用 cron 或定時任務（如 `node-cron`）

**頻率**: 每小時執行一次

**文件**: `core/src/jobs/scheduler.ts`

```typescript
// 每小時執行一次
cron.schedule('0 * * * *', async () => {
  await executeAccountDeletionJob();
});
```

---

## 8. 交易/訂閱流水保留但不可逆匿名化

### 8.1 目標

- 保留財務對帳/退款核對必要欄位
- 切斷與自然人的可回溯性

### 8.2 subscriptions 表處理

**⚠️ 重要修正：方案 A 有重大隱患，改為推薦方案**

#### 方案 A（原方案，不推薦）的問題

```sql
-- ❌ 不推薦：會破壞外鍵語義
UPDATE subscriptions 
SET user_id = CONCAT('deleted_', user_id, '_', SUBSTRING(MD5(RAND()), 1, 8))
WHERE user_id = ?;
```

**問題**:
1. 會把 `user_id` 變成偽造字符串，破壞外鍵語義（若 `subscriptions.user_id` 被其他表引用）
2. 若 `user_id` 是 UUID(36)，拼接後長度可能溢出
3. 仍然可能被視為「可回溯」，因為裡面包含原 `user_id`
4. 若未來需要 JOIN `users` 表，會導致關聯失敗

#### 推薦方案：新增 `anonymized_user_key`，`user_id` 置 NULL

**Migration**:
```sql
ALTER TABLE subscriptions
  ADD COLUMN anonymized_user_key VARCHAR(64) NULL AFTER user_id;
```

**刪除 Job 中的處理**:
```sql
-- 生成不可逆匿名鍵
SET @anonymized_key = SHA2(CONCAT('user:', user_id, ':', server_secret), 256);

-- 更新訂閱記錄
UPDATE subscriptions 
SET 
  anonymized_user_key = @anonymized_key,
  user_id = NULL,  -- 若業務允許，置為 NULL
  -- 清除可能存在的 PII 欄位（如 email, phone，若存在）
WHERE user_id = ?;
```

**若必須保留 `user_id` 以對賬**:
```sql
-- 保留 user_id（指向 tombstone 的 users 記錄，但已無 PII）
-- 同時添加 anonymized_user_key 便於跨系統對賬
UPDATE subscriptions 
SET 
  anonymized_user_key = SHA2(CONCAT('user:', user_id, ':', server_secret), 256),
  -- user_id 保留（指向 DELETED 狀態的 users 記錄）
  -- 清除 email/phone 等 PII 欄位（若存在）
WHERE user_id = ?;
```

**優勢**:
1. ✅ 不破壞外鍵語義（若保留 `user_id`，仍可 JOIN `users` 表，但 `users` 已是 tombstone）
2. ✅ 不可逆匿名化（無法從 `anonymized_user_key` 回溯到原 `user_id`）
3. ✅ 便於跨系統對賬（通過 `anonymized_user_key` 和 `external_order_id`）
4. ✅ 符合 GDPR/CCPA 要求（切斷與自然人的可回溯性）

**注意**: 
- `server_secret` 必須是強隨機密鑰，存儲在環境變量中
- 不保留 `user_id` 到 `anonymized_user_key` 的映射表，確保不可逆

---

## 9. Blocking page 的服務端支持

### 9.1 登入成功回應擴展

**端點**: `POST /api/v1/auth/login_or_register`

**響應擴展**:
```json
{
  "success": true,
  "data": {
    "user": {
      "userId": "...",
      "phone": "...",
      "status": "PENDING_DELETE",  // 新增
      "deleteScheduledAt": "2025-12-23T00:00:00Z"  // 新增（若 status=PENDING_DELETE）
    },
    "token": "..."
  }
}
```

**優化**: 登入響應直接包含 `status` 和 `deleteScheduledAt`，前端不必額外調用 `/api/v1/auth/me` 即可決定導航，減少閃屏與競態條件。

### 9.2 GET /api/v1/auth/me 擴展

**響應擴展**:
```json
{
  "success": true,
  "data": {
    "userId": "...",
    "phone": "...",
    "status": "PENDING_DELETE",  // 新增
    "deleteScheduledAt": "2025-12-23T00:00:00Z"  // 新增（若 status=PENDING_DELETE）
  }
}
```

### 9.3 前端 routing 規則

**位置**: `app/src/navigation/RootNavigator.tsx` 或登入成功後的處理邏輯

```typescript
// 登入成功後
if (user.status === 'ACTIVE') {
  // 正常進入 App
  navigation.navigate('MainTabs');
} else if (user.status === 'PENDING_DELETE') {
  // 導向 Blocking page
  navigation.navigate('AccountDeletionPending');
} else if (user.status === 'DELETED') {
  // 提示帳號不可用（不暴露原因亦可）
  Alert.alert('帳號不可用', '此帳號已無法使用');
  // 清除本地狀態，返回登入頁
  await logout();
}
```

---

## 10. 錯誤碼與邊界情況

### 10.1 重複 request

**行為**: 返回同一 `deleteScheduledAt`（冪等）

**實現**: 檢查 `status = 'PENDING_DELETE'` 時，直接返回現有時間

### 10.2 已到期但 job 尚未跑到

**deletion-cancel 必須拒絕**（按 `UTC_TIMESTAMP() >= delete_scheduled_at` 判定）

**前端 Blocking page 應提示**: 「已超過可撤銷期限」

**處理邏輯**:
- 檢查 `delete_scheduled_at <= UTC_TIMESTAMP()` 時，返回 `409 CANNOT_CANCEL_DELETION_EXPIRED`
- 即使 Job 尚未執行，也視為「已到期」，不可撤銷

### 10.3 Job 執行中並發

**問題**: `cancel` 與 `job` 可能同時操作同一 user

**解決方案**:

1. **Cancel 使用條件更新**（見第 4.3 節）:
   ```sql
   UPDATE users SET ... 
   WHERE user_id=? 
     AND status='PENDING_DELETE' 
     AND delete_scheduled_at > UTC_TIMESTAMP();
   ```
   - 檢查 `affected_rows = 1` 才算成功

2. **Job 使用行鎖**:
   ```sql
   SELECT user_id FROM users 
   WHERE status = 'PENDING_DELETE' 
     AND delete_scheduled_at <= UTC_TIMESTAMP()
   FOR UPDATE;  -- 鎖住行
   ```
   - 再次確認仍滿足條件
   - 若條件不滿足（可能被 cancel），跳過該用戶

3. **可選：新增 DELETING 狀態**（更嚴格）:
   - Job 先將 `status` 從 `PENDING_DELETE` 改為 `DELETING`
   - 執行刪除後改為 `DELETED`
   - Cancel 檢查 `status = 'PENDING_DELETE'`，若已是 `DELETING` 則拒絕

### 10.4 PENDING_DELETE 的 API 訪問

**規則**: 非白名單 API 一律 `403 ACCOUNT_PENDING_DELETE`

**實現**: 在認證中間件中檢查（見第 3.1 節）

---

## 11. 文件結構

### 11.1 前端文件

```
app/src/
├── screens/
│   ├── Settings/
│   │   └── SettingsScreen.tsx          # 添加「註銷賬號」按鈕
│   └── AccountDeletionPending/          # 新建
│       └── AccountDeletionPendingScreen.tsx
├── services/api/
│   └── accountService.ts                # 新建：account API 封裝
└── types/
    └── account.ts                       # 新建：account 相關類型
```

### 11.2 後端文件

```
core/src/
├── routes/
│   └── account.ts                       # 新建：account 路由
├── modules/
│   └── account/
│       ├── accountService.ts            # 新建：account 業務邏輯
│       └── accountDeletionJob.ts        # 新建：刪除 Job
├── middleware/
│   └── accountStatusMiddleware.ts       # 新建：PENDING_DELETE 白名單檢查
├── database/
│   └── migrations/
│       └── XXX_add_account_deletion_fields.sql
└── jobs/
    └── scheduler.ts                     # 新建或擴展：Job 調度器
```

---

## 12. 國際化文案

### 12.1 前端文案（繁體中文）

**文件**: `app/src/i18n/locales/zh-HK.ts`

```typescript
account: {
  deleteAccount: '註銷賬號',
  confirmDeletionTitle: '確認註銷賬號',
  confirmDeletionMessage: '帳號將立即停用並登出。\n\n資料將在 7 天後永久刪除，屆時無法恢復。',
  confirmDeletionButton: '確認註銷',
  deletionRequested: '已提交註銷申請，可在 7 天內重新登入撤銷',
  deletionPendingTitle: '帳號待刪除',
  deletionPendingMessage: '您的帳號將於 {date} 永久刪除',
  deletionPendingHint: '在此日期前，您可以撤銷註銷申請',
  cancelDeletion: '撤銷註銷',
  continueDeletion: '仍要註銷',
  deletionExpired: '已超過可撤銷期限',
  accountDeleted: '帳號已刪除',
}
```

### 12.2 後端錯誤碼

**文件**: `core/src/config/errors.ts`（若存在）或直接在 API 響應中定義

```typescript
ACCOUNT_PENDING_DELETE: {
  code: 'ACCOUNT_PENDING_DELETE',
  message: '帳號待刪除，僅允許撤銷或登出操作',
  status: 403
},
CANNOT_CANCEL_DELETION_EXPIRED: {
  code: 'CANNOT_CANCEL_DELETION_EXPIRED',
  message: '已超過可撤銷期限',
  status: 409
},
CANNOT_CANCEL_DELETION_INVALID_STATE: {
  code: 'CANNOT_CANCEL_DELETION_INVALID_STATE',
  message: '當前狀態不允許撤銷',
  status: 409
}
```

---

## 13. 測試要點

### 13.1 功能測試

1. ✅ 發起註銷 → 立即登出 → 重新登入 → 進入 Blocking page
2. ✅ Blocking page → 撤銷註銷 → 正常進入 App
3. ✅ Blocking page → 仍要註銷 → 返回登入頁
4. ✅ 7 天後 → Job 執行 → 帳號變為 DELETED
5. ✅ DELETED 帳號 → 無法登入（410/404）

### 13.2 安全測試

1. ✅ PENDING_DELETE 狀態 → 非白名單 API → 403
2. ✅ token_version 更新 → 舊 token 立即失效
3. ✅ 並發測試：cancel 與 job 同時執行

### 13.3 數據完整性測試

1. ✅ 刪除後 → 關聯表數據正確清理
2. ✅ subscriptions 匿名化 → 無法回溯到原用戶
3. ✅ tombstone 記錄 → 不影響新用戶註冊（phone/email 唯一性）

---

## 14. 實施順序建議

### Phase 1: 數據庫與後端基礎
1. 創建 Migration（添加欄位）
2. 實現 `accountService.ts`（deletion-request, deletion-cancel, deletion-status）
3. 實現 `accountStatusMiddleware.ts`（PENDING_DELETE 白名單）
4. 擴展 `GET /api/v1/auth/me` 返回 status

### Phase 2: 前端基礎
1. 創建 `AccountDeletionPendingScreen.tsx`
2. 在 `SettingsScreen.tsx` 添加「註銷賬號」按鈕
3. 實現 `accountService.ts`（前端 API 封裝）
4. 更新 `RootNavigator.tsx` 路由邏輯

### Phase 3: Token 失效機制
1. 在 JWT payload 中添加 `tv`（token_version）
2. 在認證中間件中驗證 `tv`
3. 在 deletion-request/cancel 時更新 `token_version`

### Phase 4: 刪除 Job
1. 實現 `accountDeletionJob.ts`
2. 實現 Job 調度器
3. 測試刪除流程

### Phase 5: 訂閱匿名化
1. 更新 `subscriptions` 表結構（若需要）
2. 在 Job 中實現匿名化邏輯

### Phase 6: 審計與優化
1. 創建審計日誌表（可選）
2. 添加監控與告警
3. 性能優化

---

## 15. 風險與注意事項

### 15.1 數據恢復

- ⚠️ 7 天寬限期後，數據無法恢復
- ⚠️ 建議在 Job 執行前發送最後一次提醒（可選）

### 15.2 並發安全

- ⚠️ cancel 與 job 並發時，需使用數據庫鎖或條件更新
- ⚠️ 建議使用 `SELECT ... FOR UPDATE` 或樂觀鎖

### 15.3 性能

- ⚠️ 刪除 Job 可能涉及大量數據，需分批處理
- ⚠️ 建議在低峰期執行（如凌晨）

### 15.4 法律合規

- ⚠️ 確保符合 GDPR、CCPA 等數據保護法規
- ⚠️ 審計日誌需保留一定期限（不含 PII）

---

## 16. 後續優化（可選）

1. **郵件提醒**: 在寬限期第 6 天發送提醒郵件
2. **數據導出**: 允許用戶在註銷前導出數據
3. **部分刪除**: 允許用戶選擇保留部分數據（如訂閱記錄）
4. **延長寬限期**: 允許用戶申請延長寬限期（需審核）

---

**文檔結束**

