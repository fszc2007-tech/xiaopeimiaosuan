# 主題設置功能實施方案

**版本**: v1.1（優化版）  
**日期**: 2025-12-16  
**狀態**: 設計完成（已拍板）  
**對應設計文檔**: 主題設置功能設計方案（用戶提供）

**更新記錄**:
- v1.1: 整合產品決策、優化關鍵點、明確工程拆分、補充深色配色基準與測試清單

---

## 0. 技術棧確認

### 當前項目架構

- **框架**: React Native + Expo (v54)
- **狀態管理**: Zustand (v5.0.8) + persist middleware
- **存儲**: AsyncStorage (`@react-native-async-storage/async-storage`)
- **導航**: React Navigation (v7)
- **主題系統**: 現有 `app/src/theme/colors.ts`（僅淺色配色）

### 現有狀態

1. **`uiStore.ts`** 已存在，但僅支持 `theme: 'light' | 'dark'`，缺少 `system` 選項
2. **`colors.ts`** 僅定義了淺色配色，無深色配色
3. **`SettingsScreen.tsx`** 中主題設置為占位（顯示「開發中」）
4. **無系統外觀檢測**：未使用 React Native 的 `Appearance` API

---

## 1. 實施範圍與目標

### 1.1 核心功能

1. ✅ 擴展 `uiStore` 支持 `themeMode: 'system' | 'light' | 'dark'`
2. ✅ 實現系統外觀檢測與監聽（`system` 模式下）
3. ✅ 創建深色配色方案（`colors.dark.ts`）
4. ✅ 實現主題解析邏輯（`themeMode` → `resolvedTheme: 'light' | 'dark'`）
5. ✅ 創建「主題設置」頁面（`ThemeSettingsScreen.tsx`）
6. ✅ 全局主題注入（在 App 根組件初始化）
7. ✅ 持久化存儲（通過 Zustand persist）

### 1.2 非目標

- ❌ 多套主題配色（僅深/淺兩套）
- ❌ 分頁/預覽（直接選擇即生效）
- ❌ 服務端同步（**第一期不做**，後續可擴展）

---

## 2. 產品與交互決策（已拍板）

### 2.1 核心決策

1. **主策略枚舉**: `themeMode = 'system' | 'light' | 'dark'`
   - Switch「跟隨系統」= `themeMode === 'system'`
   - 不再用兩個布林值避免狀態互斥 bug

2. **「跟隨系統」開啟時單選列表行為**: **可點擊**（採用）
   - 點「淺色/深色」→ 直接切到對應模式並自動關閉跟隨系統
   - 這是最少步驟、最符合直覺的交互

3. **Switch 從 ON → OFF 的落點規則**（必須明確）
   - 由 `system` 切到「非 system」時，落到當前 `resolvedTheme`
   - 當下實際是深色就落到 `dark`，否則 `light`
   - 避免突然跳回預設造成用戶困惑

4. **文案決策**
   - 描述文案保留圖中的一句：「開啟後，將跟隨系統打開或關閉深色模式」
   - 另加一行小字（不破壞版式，放在描述下方）：
     - 當 `system`：`目前：淺色 / 深色`（根據 `resolvedTheme` 顯示）
   - 這能消除「勾選到底代表什麼」的語義模糊

5. **服務端同步**: **第一期不做**（拍板）
   - 這是純前端偏好，不應阻塞上線
   - 後續要做多端一致再加

---

## 3. 技術方案設計

### 3.1 依賴分析

#### 需要新增的依賴

**無需新增依賴** ✅

- React Native 內置 `Appearance` API（`react-native` 自帶）
- Expo 提供 `expo-appearance`（但 Expo v54 已內置，無需額外安裝）

#### 可選優化依賴（後續考慮）

- `react-native-appearance`（已棄用，不推薦）
- `@react-native-community/hooks`（提供 `useColorScheme` hook，但可直接用 `Appearance`）

**結論**: 使用 React Native 原生 `Appearance` API，無需安裝額外依賴。

---

### 3.2 文件結構設計

```
app/src/
├── store/
│   └── uiStore.ts                    # 擴展：支持 system/light/dark
├── theme/
│   ├── colors.ts                     # 保持：淺色配色（重命名為 colors.light.ts？）
│   ├── colors.dark.ts                # 新增：深色配色
│   ├── themeProvider.tsx             # 新增：主題 Provider 與 Hook
│   └── index.ts                      # 更新：導出主題相關工具
├── screens/
│   └── Settings/
│       ├── SettingsScreen.tsx        # 更新：主題設置入口改為導航
│       └── ThemeSettingsScreen.tsx   # 新增：主題設置頁面
├── navigation/
│   └── RootNavigator.tsx             # 更新：註冊 ThemeSettings 路由
└── constants/
    └── routes.ts                      # 更新：新增 THEME_SETTINGS 路由常量
```

---

### 3.3 數據模型設計

#### 3.3.1 UI Store 擴展（最低必需字段）

```typescript
// app/src/store/uiStore.ts

interface UIState {
  // ===== State =====
  themeMode: 'system' | 'light' | 'dark';  // 用戶選擇（持久化）
  resolvedTheme: 'light' | 'dark';          // 實際生效（不持久化，每次啟動推導）
  hasHydrated: boolean;                     // 避免閃爍（hydration gate）
  language: 'zh-CN' | 'zh-HK';
  bottomSheetVisible: boolean;
  bottomSheetContent: 'filter' | 'menu' | null;
  
  // ===== Actions =====
  setThemeMode: (mode: 'system' | 'light' | 'dark') => void;
  syncResolvedTheme: () => void;  // system 時響應 OS（內部使用）
  _setHasHydrated: (hydrated: boolean) => void;  // 內部使用
  // ... 其他 actions
}
```

**關鍵設計**:
- ✅ `themeMode`: 用戶選擇，持久化到 AsyncStorage
- ✅ `resolvedTheme`: 實際生效，不持久化，每次啟動推導
- ✅ `hasHydrated`: 用於避免首屏閃爍

#### 3.3.2 存儲策略

- **AsyncStorage Key**: `xiaopei-ui-storage`（保持不變）
- **持久化字段**: 僅 `themeMode`（`'system' | 'light' | 'dark'`）
- **不持久化**: `resolvedTheme`（每次啟動從 `themeMode` 推導）

#### 3.3.3 默認值

- **首次啟動**: `themeMode: 'system'`（跟隨系統）
- **無存儲值時**: 回退到 `'system'`
- **hasHydrated**: 默認 `false`，rehydrate 完成後設為 `true`

---

### 3.4 主題配色方案設計（建立語義 Token 對稱）

#### 3.4.1 核心原則

**問題**: 如果 dark 只是零散改幾個顏色，後面會失控。

**改法（拍板）**: 建立「語義 token」對稱（最小集合），要求 light/dark 都完整覆蓋。

#### 3.4.2 語義 Token 定義（最小集合）

```typescript
// 語義 Token 結構（light 和 dark 都必須完整覆蓋）

interface ColorTokens {
  // 背景層級
  background: string;      // 頁面底色
  surface: string;         // 表面（卡片、輸入框等）
  card: string;           // 卡片底色（可與 surface 相同）
  
  // 文字層級
  textPrimary: string;     // 主文字（標題、正文）
  textSecondary: string;   // 次文字（說明、placeholder）
  textTertiary: string;   // 三級文字（輔助信息，可選）
  
  // 邊框與分隔
  border: string;         // 邊框、分割線
  divider: string;        // 分隔線（可與 border 相同）
  
  // 品牌主色
  primary: string;        // 主綠色（品牌色，保持不變）
  primaryPressed: string; // 按下態
  primaryTextOnPrimary: string; // 主色上的文字（通常是白色，確保可讀）
  
  // 狀態色
  danger: string;         // 錯誤、危險
  warning: string;        // 警告
  success: string;        // 成功
  info: string;          // 信息
  
  // 可選
  shadow?: string;        // 陰影（dark 下更克制）
}
```

#### 3.4.3 淺色配色（重構為語義 Token）

```typescript
// app/src/theme/colors.light.ts

export const lightColors: ColorTokens = {
  background: '#f5f5f5',        // 頁面底色
  surface: '#ffffff',            // 表面
  card: '#ffffff',              // 卡片底色
  
  textPrimary: '#32343a',       // 主文字
  textSecondary: '#6b7280',     // 次文字
  textTertiary: '#9ca3af',      // 三級文字（可選）
  
  border: '#e5e7eb',            // 邊框
  divider: '#e5e7eb',           // 分隔線
  
  primary: '#52b788',           // 主綠色（品牌色）
  primaryPressed: '#2d6a4f',    // 按下態
  primaryTextOnPrimary: '#ffffff', // 主色上的文字（白色）
  
  danger: '#f97373',            // 錯誤
  warning: '#fbbf24',           // 警告
  success: '#40916c',           // 成功
  info: '#648e93',              // 信息
  
  shadow: 'rgba(0, 0, 0, 0.1)', // 淺色下正常陰影
};
```

#### 3.4.4 深色配色（對應語義 Token）

```typescript
// app/src/theme/colors.dark.ts

export const darkColors: ColorTokens = {
  background: '#1a1a1a',         // 接近純黑但不純黑（避免 OLED 過黑）
  surface: '#2d2d2d',            // 比 background 亮一級
  card: '#2d2d2d',              // 卡片底色
  
  textPrimary: '#f5f5f5',        // 接近白但非純白
  textSecondary: '#9ca3af',     // 降低亮度 20-30%
  textTertiary: '#6b7280',      // 三級文字
  
  border: '#404040',             // 在 dark 下要比 light 更"弱"
  divider: '#404040',           // 分隔線
  
  primary: '#52b788',            // 品牌綠保持，但需檢查與 dark 背景的對比度
  primaryPressed: '#95d5b2',     // 按下態（變淺）
  primaryTextOnPrimary: '#ffffff', // 主色上的文字（白色，確保可讀）
  
  danger: '#f97373',             // 錯誤（可能需要微調）
  warning: '#fbbf24',            // 警告
  success: '#40916c',            // 成功
  info: '#648e93',               // 信息
  
  shadow: 'rgba(0, 0, 0, 0.3)',  // dark 下陰影更克制
};
```

#### 3.4.5 深色配色建議基準（可直接用）

**可讀性與層級規則**（設計照此填值就不會翻車）:

1. **background**: 接近純黑但不純黑（避免對比過強、OLED 過黑造成眩光差異）
   - 建議: `#1a1a1a` 或 `#121212`

2. **surface/card**: 比 background 亮一級，用於卡片底
   - 建議: `#2d2d2d` 或 `#1e1e1e`

3. **textPrimary**: 接近白但非純白
   - 建議: `#f5f5f5` 或 `#ffffff`（但避免純白 `#ffffff`）

4. **textSecondary**: 降低亮度 20–30%
   - 建議: `#9ca3af` 或 `#a0a0a0`

5. **divider/border**: 在 dark 下要比 light 更"弱"，不然像網格紙
   - 建議: `#404040` 或 `#333333`

6. **primary**: 品牌綠保持，但需檢查與 dark 背景的對比度
   - 必要時提高亮度或飽和度（例如 `#6bc89a`）

7. **shadow**: dark 下陰影要更克制，更多用"描邊/層級差"而非強投影
   - 建議: `rgba(0, 0, 0, 0.3)` 或更弱

#### 3.4.6 兼容導出策略（避免全局改動太大）

**拍板落地策略**:

1. **仍保留 `colors` 的老用法**（如果現有大量引用）
   - 但其本質改成 getter: `colors = getColors(resolvedTheme)`
   - 這樣第一期改動可控，不會全 repo 大改

2. **新代碼必須用 `useTheme()` / `useColors()`**（你們定名）
   - 逐步遷移現有代碼

**實現方式**:

```typescript
// app/src/theme/index.ts

import { lightColors } from './colors.light';
import { darkColors } from './colors.dark';
import { useUIStore } from '@/store/uiStore';

// 兼容導出（getter）
export const getColors = (resolvedTheme: 'light' | 'dark') => {
  return resolvedTheme === 'dark' ? darkColors : lightColors;
};

// 老用法兼容（從 store 讀取 resolvedTheme）
export const colors = getColors(useUIStore.getState().resolvedTheme);

// 新用法（推薦）
export const useColors = () => {
  const resolvedTheme = useUIStore((state) => state.resolvedTheme);
  return getColors(resolvedTheme);
};
```

---

### 3.5 主題解析邏輯（單點解析 + 系統監聽）

#### 3.5.1 核心問題

**問題**: 如果只存 `themeMode`，UI 到底用哪套顏色會變得分散、組件容易各算各的。

**改法（拍板）**: 全局只做一次解析：

- `themeMode`: 用戶選擇（`system` / `light` / `dark`）
- `resolvedTheme`: 實際生效（`light` / `dark`），由以下規則推導：
  - 若 `themeMode !== 'system'` → `resolvedTheme = themeMode`
  - 若 `themeMode === 'system'` → `resolvedTheme = Appearance.getColorScheme() ?? 'light'`
- **所有 UI 都只依 `resolvedTheme` 拿 token**

#### 3.5.2 核心算法（純函數）

```typescript
// app/src/theme/themeResolver.ts

import { Appearance } from 'react-native';

/**
 * 解析主題（純函數）
 * @param themeMode 用戶選擇的主題模式
 * @returns 實際生效的主題
 */
export function getResolvedTheme(
  themeMode: 'system' | 'light' | 'dark'
): 'light' | 'dark' {
  if (themeMode !== 'system') {
    return themeMode;
  }
  
  // system 模式下，從 OS 獲取
  const systemColorScheme = Appearance.getColorScheme();
  return systemColorScheme ?? 'light';  // null 時回退到 light
}
```

#### 3.5.3 系統外觀監聽（訂閱管理）

**關鍵要求**: 只有在 `themeMode === 'system'` 時訂閱；切到 manual 時要取消訂閱，防止記憶體泄露/多重回調。

```typescript
// app/src/store/uiStore.ts（內部實現）

import { Appearance } from 'react-native';

// 在 store 內部管理訂閱
let appearanceSubscription: { remove: () => void } | null = null;

const subscribeAppearanceChanges = (set: any) => {
  // 取消舊訂閱
  if (appearanceSubscription) {
    appearanceSubscription.remove();
    appearanceSubscription = null;
  }
  
  // 只在 system 模式下訂閱
  const currentState = useUIStore.getState();
  if (currentState.themeMode === 'system') {
    appearanceSubscription = Appearance.addChangeListener(({ colorScheme }) => {
      const resolved = colorScheme ?? 'light';
      set({ resolvedTheme: resolved });
    });
  }
};

// setThemeMode 時調用
setThemeMode: (mode) => {
  set({ themeMode: mode });
  // 重新計算 resolvedTheme
  const resolved = getResolvedTheme(mode);
  set({ resolvedTheme: resolved });
  // 重新訂閱（如果需要）
  subscribeAppearanceChanges(set);
}
```

**注意事項**:
- ✅ `colorScheme` 可能為 `null`（極少見），需回退到 `'light'`
- ✅ 監聽器必須在切到 manual 時取消，防止記憶體泄露
- ✅ 監聽器必須在組件卸載時移除

---

### 3.6 全局主題注入方案（Provider / Hook）

#### 3.6.1 主題 Provider 設計

**職責**:
- 根容器背景色、StatusBar style（若你們已用 `expo-status-bar` 或 RN StatusBar）
- 將 colors 注入 context（或只用 hook 從 store 取）
- 若你們已有全局 design system，直接接入即可，不必再造輪子

```typescript
// app/src/theme/themeProvider.tsx

import { useUIStore } from '@/store/uiStore';
import { getColors } from './index';
import { StatusBar } from 'expo-status-bar';

export const ThemeProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const themeMode = useUIStore((state) => state.themeMode);
  const resolvedTheme = useUIStore((state) => state.resolvedTheme);
  const colors = getColors(resolvedTheme);
  
  return (
    <>
      <StatusBar style={resolvedTheme === 'dark' ? 'light' : 'dark'} />
      <View style={{ flex: 1, backgroundColor: colors.background }}>
        {children}
      </View>
    </>
  );
};

// Hook（推薦新代碼使用）
export const useTheme = () => {
  const themeMode = useUIStore((state) => state.themeMode);
  const resolvedTheme = useUIStore((state) => state.resolvedTheme);
  const setThemeMode = useUIStore((state) => state.setThemeMode);
  const colors = getColors(resolvedTheme);
  
  return {
    themeMode,
    resolvedTheme,
    colors,
    setThemeMode,
  };
};
```

#### 3.6.2 App.tsx 初始化流程（避免首屏閃爍）

**問題**: 主題如果在首屏渲染後才套用，會出現閃爍。Expo/RN 很常見。

**改法（拍板）**: 在 Zustand store rehydrate 完成後再渲染主體 UI（至少在根容器套 theme 前）。

**最低標準**: 在 `App.tsx` 先讀 storage → 得到 `themeMode` → 設置 store → 再渲染 Navigator。

```typescript
// app/App.tsx

export default function App() {
  const [isInitialized, setIsInitialized] = useState(false);
  const hasHydrated = useUIStore((state) => state.hasHydrated);
  
  useEffect(() => {
    async function prepare() {
      try {
        // 1. 初始化認證（現有）
        await initializeAuth();
        initApiAuth();
        
        // 2. 初始化主題（新增）
        //    - Zustand persist 會自動 rehydrate themeMode
        //    - 計算初始 resolvedTheme
        //    - 設置系統外觀監聽（如果 themeMode === 'system'）
        const themeMode = useUIStore.getState().themeMode;
        const resolved = getResolvedTheme(themeMode);
        useUIStore.getState().syncResolvedTheme();
        useUIStore.getState()._setHasHydrated(true);
        
        setIsInitialized(true);
      } catch (error) {
        console.error('[App] 初始化失败:', error);
        setIsInitialized(true);
      }
    }
    prepare();
  }, []);
  
  // 等待認證和主題初始化完成
  if (!isInitialized || !hasHydrated) {
    return (
      <SafeAreaProvider>
        <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: '#1a1a1a' }}>
          <ActivityIndicator size="large" color="#52b788" />
        </View>
      </SafeAreaProvider>
    );
  }
  
  return (
    <ThemeProvider>
      <SafeAreaProvider>
        <NavigationContainer>
          <RootNavigator />
        </NavigationContainer>
      </SafeAreaProvider>
    </ThemeProvider>
  );
}
```

---

### 3.7 主題設置頁面設計（你圖中的 UI）

#### 3.7.1 頁面結構

```
ThemeSettingsScreen
├── Header (返回 + 標題「主題設置」)
├── ScrollView
│   ├── Section 1: 跟隨系統
│   │   └── SwitchCell
│   │       ├── Icon (Palette)
│   │       ├── Text: "跟隨系統"
│   │       ├── Desc: "開啟後，將跟隨系統打開或關閉深色模式"
│   │       ├── DescSmall: "目前：淺色 / 深色" (當 system 時顯示)
│   │       └── Switch (右側)
│   │
│   └── Section 2: 手動選擇
│       ├── RadioCell: "淺色模式" (右側勾選)
│       └── RadioCell: "深色模式" (右側勾選)
```

#### 3.7.2 交互實作（拍板規則）

**狀態 1: 跟隨系統 = ON (`themeMode === 'system'`)**

- Switch 顯示為 ON
- 單選列表仍可點擊（點擊後自動關閉跟隨系統）
- 勾選顯示當前 `resolvedTheme`（也就是"目前生效"）
- 描述文案下方顯示小字：「目前：淺色 / 深色」（根據 `resolvedTheme` 顯示）

**狀態 2: 跟隨系統 = OFF (`themeMode === 'light' | 'dark'`)**

- Switch 顯示為 OFF
- 單選列表中對應項顯示勾選（根據 `themeMode`）
- App 立即切換到所選主題

**操作行為（拍板）**:

1. **Switch onChange（開啟）**:
   ```typescript
   setThemeMode('system')
   ```

2. **Switch onChange（關閉）**:
   ```typescript
   const currentResolved = useUIStore.getState().resolvedTheme;
   setThemeMode(currentResolved);  // 落到當前生效
   ```

3. **點選「淺色模式」**:
   ```typescript
   setThemeMode('light')
   // Switch 自動變為 OFF（因為 themeMode !== 'system'）
   ```

4. **點選「深色模式」**:
   ```typescript
   setThemeMode('dark')
   // Switch 自動變為 OFF（因為 themeMode !== 'system'）
   ```

**勾選顯示規則（拍板）**:
- 勾選顯示當前 `resolvedTheme`（也就是"目前生效"）
- 若 `themeMode === 'system'`，仍可勾選 `resolvedTheme`，同時展示"目前：xxx"小字

---

### 3.8 路由與導航

#### 2.8.1 路由常量

```typescript
// app/src/constants/routes.ts

export const SCREEN_NAMES = {
  // ... 現有路由
  SETTINGS: 'Settings',
  THEME_SETTINGS: 'ThemeSettings',  // 新增
  // ...
} as const;
```

#### 2.8.2 導航註冊

```typescript
// app/src/navigation/RootNavigator.tsx

<Stack.Screen 
  name={SCREEN_NAMES.THEME_SETTINGS} 
  component={ThemeSettingsScreen}
/>
```

#### 2.8.3 SettingsScreen 更新

```typescript
// app/src/screens/Settings/SettingsScreen.tsx

// 將「主題設置」Cell 的 onPress 改為：
onPress={() => navigation.navigate(SCREEN_NAMES.THEME_SETTINGS)}
```

---

## 4. 最終落地方案（工程拆分級）

### 4.1 Store：uiStore 擴展（Zustand）

**字段（最低必需）**:
- `themeMode: 'system' | 'light' | 'dark'`
- `resolvedTheme: 'light' | 'dark'`
- `setThemeMode(mode)`
- `syncResolvedTheme()`（system 時響應 OS）
- `hasHydrated`（避免閃爍）

**持久化**:
- storage key: `app_theme_mode`（或沿用 `xiaopei-ui-storage`）
- 僅持久化 `themeMode`，`resolvedTheme` 每次啟動推導即可

### 4.2 Theme Resolver：單點解析 + 系統監聽

- `getResolvedTheme(themeMode)`: 純函數
- `subscribeAppearanceChanges()`: 只有在 `themeMode === 'system'` 時訂閱；切到 manual 時要取消訂閱，防止記憶體泄露/多重回調

### 4.3 Colors：建立 Token 對稱

- `colors.light.ts`
- `colors.dark.ts`
- `getColors(resolvedTheme)` → return 對應 token 集

### 4.4 Provider / Hook

- `ThemeProvider`（放 App 根部）負責：
  - 根容器背景色、StatusBar style
  - 將 colors 注入 context（或只用 hook 從 store 取）
- `useTheme()` / `useColors()` hook

### 4.5 設置頁面（你圖中的 UI）

**交互實作**:
- Switch onChange：開啟 → `setThemeMode('system')`；關閉 → `setThemeMode(resolvedTheme)`
- 點選「淺色/深色」：`setThemeMode('light'|'dark')`
- 勾選顯示：勾選顯示當前 `resolvedTheme`（也就是"目前生效"）

---

## 5. 實施步驟（按順序）

### Phase 1: 基礎架構擴展

1. **擴展 uiStore**
   - 將 `theme: 'light' | 'dark'` 改為 `themeMode: 'system' | 'light' | 'dark'`
   - 新增 `resolvedTheme: 'light' | 'dark'`（不持久化）
   - 新增 `hasHydrated: boolean`（避免閃爍）
   - 更新 `setTheme` → `setThemeMode`
   - 實現 `syncResolvedTheme()`（system 時響應 OS）
   - 實現系統外觀監聽邏輯（訂閱管理，防止記憶體泄露）

2. **創建主題解析器**
   - 創建 `app/src/theme/themeResolver.ts`
   - 實現 `getResolvedTheme()` 純函數

3. **重構配色為語義 Token**
   - 重構 `app/src/theme/colors.ts` → `colors.light.ts`（語義 Token）
   - 創建 `app/src/theme/colors.dark.ts`（對應語義 Token）
   - 實現 `getColors(resolvedTheme)` getter
   - 實現兼容導出（`colors` 從 store 讀取 `resolvedTheme`）

4. **創建主題 Provider**
   - 創建 `app/src/theme/themeProvider.tsx`
   - 實現 `useTheme()` / `useColors()` hook
   - 實現根容器背景色、StatusBar style

### Phase 2: 頁面實現

4. **創建主題設置頁面**
   - 創建 `app/src/screens/Settings/ThemeSettingsScreen.tsx`
   - 實現 UI（Switch + 單選列表）
   - 實現交互邏輯（聯動規則）

5. **更新路由**
   - 在 `routes.ts` 新增 `THEME_SETTINGS`
   - 在 `RootNavigator.tsx` 註冊路由
   - 更新 `SettingsScreen.tsx` 導航入口

### Phase 3: 全局集成

6. **App.tsx 集成（避免首屏閃爍）**
   - 在 `App.tsx` 包裹 `ThemeProvider`
   - 實現 hydration gate（等待 `hasHydrated === true` 再渲染主體 UI）
   - 確保主題在渲染前初始化（先讀 storage → 得到 themeMode → 設置 store → 再渲染 Navigator）

7. **遷移現有組件（可選，分階段）**
   - 新代碼必須用 `useTheme()` / `useColors()`
   - 舊代碼保持 `colors` 導出兼容（getter 從 store 讀取）
   - 優先遷移核心頁面（Settings、Me、Chat 等）

### Phase 4: 測試與優化

8. **功能測試**
   - 測試三種模式切換
   - 測試系統外觀監聽
   - 測試持久化
   - 測試邊界條件（無存儲值、系統不支持深色等）

9. **視覺驗收**
   - 檢查深色配色對比度
   - 檢查所有頁面在深色模式下的顯示效果

---

## 6. 邊界條件處理

### 4.1 首次啟動

- **無存儲值**: 默認 `themeMode = 'system'`
- **存儲值損壞**: 回退到 `'system'`

### 4.2 系統不支持深色模式

- **檢測**: `Appearance.getColorScheme()` 返回 `null` 或僅返回 `'light'`
- **處理**: `system` 模式下永遠 resolved 為 `'light'`
- **UI**: 深色選項仍可顯示，但切換後效果受限（可選：在低版本上隱藏深色選項）

### 4.3 從 system 切回 manual

- **策略**: 落到當前 `resolvedTheme`，避免突兀跳轉
- **實現**: `setThemeMode('light' | 'dark')` 時，如果當前是 `system`，先獲取 `resolvedTheme` 再設置

### 4.4 快速連點

- **策略**: 設置寫入做防抖/排隊，最終以最後一次操作為準
- **實現**: Zustand 的 `set` 是同步的，但可選添加防抖（使用 `lodash.debounce` 或自定義）

### 4.5 啟動閃屏

- **問題**: 主題初始化在渲染後，可能出現淺色閃屏後切到深色
- **解決**:
  1. 在 `App.tsx` 初始化階段讀取 `themeMode` 並計算 `resolvedTheme`
  2. 在渲染前設置初始背景色（使用 `StatusBar` 和根 `View` 的 `backgroundColor`）
  3. 或使用啟動態遮罩（Splash Screen）

---

## 7. 性能考慮

### 5.1 系統外觀監聽

- **訂閱時機**: 僅在 `themeMode === 'system'` 時訂閱
- **取消訂閱**: 組件卸載或 `themeMode !== 'system'` 時取消
- **性能影響**: 監聽器開銷極小，無需優化

### 5.2 主題切換性能

- **重新渲染**: 主題切換會觸發所有使用 `useTheme` 的組件重新渲染
- **優化策略**:
  - 使用 `React.memo` 包裹不依賴主題的組件
  - 使用 `useMemo` 緩存依賴主題的計算值
  - 避免在渲染函數中創建新對象（colors 對象應在 Provider 中緩存）

---

## 8. 後續擴展（非本次實施）

### 6.1 服務端同步

- **場景**: 多端（iOS/Android/Web）希望主題一致
- **實現**:
  - 在 `user_preferences` 表新增 `theme_mode` 字段
  - 登錄時同步（server 有值則覆蓋本地，server 無值則上傳本地）
  - 以 `updated_at` 為準決策衝突

### 6.2 更多主題配色

- **場景**: 用戶希望自定義主題色（如護眼模式、高對比度等）
- **實現**: 擴展 `themeMode` 為更複雜的配置對象

---

## 9. 測試與驗收清單（避免返工）

### 9.1 功能驗收（必須通過）

- [ ] **初次安裝**: 預設 `system`；跟隨系統切換生效
- [ ] **system 開啟時**: 改 OS 深/淺，App 立即跟隨（不重啟）
- [ ] **system → off**: 落到當前 `resolvedTheme`（不跳回預設）
- [ ] **點淺/深**: 立即生效；Switch 變為 off
- [ ] **重啟 App**: 保持 `themeMode`；無明顯閃白/閃黑
- [ ] **反覆切換 20 次**: 無多重 listener、無內存增長（至少行為上不抖動）

### 9.2 視覺驗收

- [ ] 深色模式下所有頁面文字清晰可讀
- [ ] 深色模式下按鈕、卡片對比度符合 WCAG AA（≥4.5:1）
- [ ] 品牌主色（綠色）在深色模式下仍保持品牌識別度
- [ ] 深色模式下邊框/分隔線不過於明顯（不像網格紙）

### 9.3 邊界條件驗收

- [ ] 首次啟動默認為 `system`
- [ ] 系統不支持深色時，`system` 模式正常回退到 `light`
- [ ] 快速連點不會出現狀態不一致
- [ ] 從 `system` 切回 manual 時，落到當前 `resolvedTheme`（不突兀跳轉）

---

## 10. 風險與注意事項

### 8.1 遷移風險

- **現有代碼**: 大量組件直接使用 `colors`，需要逐步遷移到 `useTheme().colors`
- **緩解**: 第一階段保持 `colors` 導出（作為淺色默認），後續分階段遷移

### 8.2 兼容性風險

- **低版本系統**: 可能不支持深色模式檢測
- **緩解**: 檢測到不支持時，`system` 模式回退到 `light`

### 8.3 性能風險

- **全局重新渲染**: 主題切換可能觸發大量組件重新渲染
- **緩解**: 使用 `React.memo` 和 `useMemo` 優化

---

## 11. 文檔更新

### 9.1 需要更新的文檔

- [ ] `app.doc/features/主題設置功能設計方案.md`（如存在）
- [ ] `app/README.md`（添加主題系統說明）
- [ ] 開發規範文檔（添加主題使用指南）

---

## 12. 實施時間估算

| 階段 | 任務 | 預計時間 |
|------|------|----------|
| Phase 1 | 基礎架構擴展 | 2-3 小時 |
| Phase 2 | 頁面實現 | 2-3 小時 |
| Phase 3 | 全局集成 | 1-2 小時 |
| Phase 4 | 測試與優化 | 2-3 小時 |
| **總計** | | **7-11 小時** |

---

---

## 附錄：深色配色建議基準（可直接用）

以下為深色配色建議值，設計照此填值就不會翻車：

### A. 背景層級

- **background**: `#1a1a1a` 或 `#121212`（接近純黑但不純黑，避免 OLED 過黑造成眩光差異）
- **surface/card**: `#2d2d2d` 或 `#1e1e1e`（比 background 亮一級，用於卡片底）

### B. 文字層級

- **textPrimary**: `#f5f5f5` 或 `#ffffff`（接近白但非純白，避免純白 `#ffffff`）
- **textSecondary**: `#9ca3af` 或 `#a0a0a0`（降低亮度 20–30%）

### C. 邊框與分隔

- **border/divider**: `#404040` 或 `#333333`（在 dark 下要比 light 更"弱"，不然像網格紙）

### D. 品牌主色

- **primary**: `#52b788`（品牌綠保持，但需檢查與 dark 背景的對比度）
  - 必要時提高亮度或飽和度（例如 `#6bc89a`）
- **primaryTextOnPrimary**: `#ffffff`（主色上的文字，確保可讀）

### E. 陰影

- **shadow**: `rgba(0, 0, 0, 0.3)` 或更弱（dark 下陰影要更克制，更多用"描邊/層級差"而非強投影）

---

**方案已確認，可開始實施。**

