# 大运时间轴卡片优化方案（整合版 V1.1）

## 🔍 5 行摘要（给产品 / 设计看）

1. **时间轴展示**：每一步大运的干支、十神、年龄段、起止年份、一行简评
2. **颜色表达**：三种颜色表达运势整体节奏：顺（绿）/ 波动（橙）/ 平（灰）
3. **当前大运高亮**：当前所处大运卡片会高亮 + 标记"当前"，一眼知道自己走到哪一步
4. **底部解读**：点击卡片弹出底部解读：3–5 个关键词 + 3 个固定快捷提问
5. **文案风格**：所有文案遵循「不吓用户、温和建设性」的风格，只给提醒，不制造恐慌

---

## 📋 方案总评

✅ **大方向确认**：采用「方案 A：后端统一计算」，但通过**适配层分离**实现更干净的架构。

**核心原则**：
1. **引擎层**：只负责命理计算，输出「干净原始数据」+ 原始喜忌判断
2. **适配层**：把原始数据转成 App 需要的展示结构（颜色档位、简评、关键词）
3. **前端**：只负责 UI 渲染和交互，不参与命理逻辑
4. **命名统一**：十神字段全链路统一用 `shishen`，大运时间轴对前端统一用 `derived.luckCycle`
5. **Phase 1**：全部用规则表实现；Phase 2 再用小模型升级 toneTag/keywords 细节

---

## 一、架构分层设计

### 1.1 三层架构

```
┌─────────────────────────────────────────┐
│  前端（React Native）                    │
│  - 只负责 UI 渲染                        │
│  - 接收标准化的 LuckCycleData            │
└─────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────┐
│  适配层（core/src/utils/luckCycleAdapter）│
│  - 将引擎原始数据转换为前端格式           │
│  - 生成 favourLevel、toneTag、keywords   │
│  - 规则表配置（Phase 1）                  │
└─────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────┐
│  引擎层（core/engine/index.js）          │
│  - 计算大运基础数据                      │
│  - 输出 rawFavour、favourScore           │
│  - 不涉及展示逻辑                        │
└─────────────────────────────────────────┘
```

### 1.2 数据流转

#### 2.1 引擎层输出（内部结构，private）

```typescript
/**
 * 引擎层输出（内部使用，不对前端文档化）
 * 挂在引擎结果上：resultJson.derived.luck_cycle: RawLuckCycle[]
 */
interface RawLuckCycle {
  stem: string;              // 天干
  branch: string;            // 地支
  stemBranch: string;        // 干支组合，如 "甲子"
  shishen: string;           // 十神，如 "偏财"、"正官"
  startAge: number;          // 起运虚岁
  endAge: number;            // 下一步大运起运虚岁（不包含）
  startUTC: Date | string;   // 起运精确时间
  endUTC: Date | string;     // 结束精确时间
  rawFavour: '用神' | '中性' | '忌神';  // 原始喜忌判断
  favourScore?: number;      // -2 ~ +2，喜忌强度，Phase 1 不强依赖
  // ... 其他命理相关字段
}
```

⚠️ **约定**：`derived.luck_cycle` 为引擎内部字段，不对前端文档化。

#### 2.2 适配层输出（对前端公开）

```typescript
/**
 * 适配层输出（前端接收）
 * 挂在 API 结果上：result.derived.luckCycle: LuckCycleData[]
 */
export interface LuckCycleData {
  id: string;                // 唯一 ID，如 "甲子-31"
  stemBranch: string;        // "甲子"
  shishen: string;           // 十神（如 "偏财"）
  startAge: number;          // 31
  endAge: number;            // 41（下一运起运虚岁，不包含）
  startYear: number;         // 比如 2025
  endYear: number;           // 比如 2035（下一运起运年，不包含）
  favourLevel: 'good' | 'wave' | 'flat';  // 顺 / 波动 / 平
  toneTag: string;            // 一行简评，例如 "整体偏顺"
  keywords: string[];        // 3–5 个关键词
  isCurrent: boolean;        // 是否当前大运
}
```

**重要约定**：

1. **年龄区间使用半开区间 `[startAge, endAge)`**：
   - `startAge` 为本步大运起运虚岁
   - `endAge` 为下一步大运起运虚岁（不包含）
   - 当前大运判断公式：`currentAge >= raw.startAge && currentAge < raw.endAge`
   - 展示文案 `31–41岁` 表示：「从虚岁 31 起，到 41 岁起运前都是这一运」

2. **年份区间同样使用半开区间**：
   - `startYear = getYear(startUTC)` = 起运公历年
   - `endYear = getYear(endUTC)` = 下一运起运公历年
   - 展示文案 `2025–2035` 表示：「大致从 2025 年到 2034 年结束，2025 年后进入这一运，2035 年前后进入下一运」
   - ⚠️ 文档中标明：`startYear/endYear` 用于展示「大致年份范围」，精确切换时间仍以 `startUTC/endUTC` 为准，后续如做高级模式可精确到月日

#### 2.3 前端拿到的数据结构

```typescript
export interface BaziResult {
  // ...
  derived: {
    // ...其它字段
    luckCycle?: LuckCycleData[];  // ✅ 唯一对外公布的大运时间轴字段
  };
}
```

⚠️ **约定**：前端严禁依赖 `derived.luck_cycle` 字段，该字段只存在于内部 JSON，不属于对外接口合同。

---

## 二、引擎层补充（core/engine/index.js）

### 2.1 需要补充的字段

在 `luckCycleWithAge` 计算中，确保每个大运包含：

```javascript
const luckCycleWithAge = lucks.map((luck, index) => {
  // ... 现有计算逻辑 ...
  
  // 计算大运五行
  const luckElement = this.getElementFromPillar(luck);
  
  // 判断原始喜忌
  const rawFavour = this.determineFavourLevel(
    luckElement,
    favoredAvoid.favored,  // 用神五行数组
    favoredAvoid.avoid    // 忌神五行数组
  );
  
  // 可选：计算喜忌强度（-2 ~ +2）
  // -2: 很忌，-1: 偏忌，0: 中性，+1: 偏喜，+2: 很喜
  const favourScore = this.calculateFavourScore(
    luckElement,
    favoredAvoid,
    clashHarmPunish  // 冲合刑害影响
  );
  
  return {
    ...enrichedLuck,
    startAge,
    endAge,
    ageRange: `${startAge}-${endAge}岁`,
    startUTC,
    endUTC,
    rawFavour,        // ✅ 新增
    favourScore,      // ✅ 新增（可选）
  };
});
```

### 2.2 新增辅助函数

```javascript
/**
 * 计算喜忌强度（-2 ~ +2）
 * @param {string} element - 大运五行
 * @param {Object} favoredAvoid - 用神忌神信息
 * @param {string[]} clashHarmPunish - 冲合刑害列表
 * @returns {number} -2 ~ +2
 */
calculateFavourScore(element, favoredAvoid, clashHarmPunish = []) {
  let score = 0;
  
  // 基础喜忌
  if (favoredAvoid.favored.includes(element)) {
    score = 1; // 偏喜
    // 如果用神很稀缺，可以提升到 +2
    // 这里简化处理，后续可优化
  } else if (favoredAvoid.avoid.includes(element)) {
    score = -1; // 偏忌
  }
  
  // 冲合刑害影响（简化版）
  if (clashHarmPunish.length > 0) {
    // 有冲合刑害时，如果是忌神则更忌，如果是用神则减弱
    if (score < 0) {
      score -= 0.5; // 更忌
    } else if (score > 0) {
      score -= 0.3; // 减弱
    }
  }
  
  // 限制在 -2 ~ +2 之间
  return Math.max(-2, Math.min(2, score));
}
```

---

## 三、适配层实现（core/src/utils/luckCycleAdapter.ts）

### 3.1 核心转换函数

```typescript
/**
 * 将引擎原始大运数据转换为前端格式
 */
export function buildLuckCycleForApp(
  rawLuckCycle: RawLuckCycle[],
  currentAge: number
): LuckCycleData[] {
  return rawLuckCycle.map((raw) => {
    const startYear = getYearFromUTC(raw.startUTC);
    const endYear = getYearFromUTC(raw.endUTC);
    
    // 映射 favourLevel
    const favourLevel = mapFavourLevel(raw.rawFavour, raw.favourScore);
    
    // 生成 toneTag（规则表）
    const toneTag = getToneTag(favourLevel, raw.shishen);
    
    // 生成 keywords（规则表）
    const keywords = getKeywords(favourLevel, raw.shishen);
    
    // 判断是否当前大运（半开区间 [startAge, endAge)）
    const isCurrent = currentAge >= raw.startAge && currentAge < raw.endAge;
    
    return {
      id: `${raw.stemBranch}-${raw.startAge}`,
      stemBranch: raw.stemBranch,
      shishen: raw.shishen,  // ✅ 统一用 shishen
      startAge: raw.startAge,
      endAge: raw.endAge,
      startYear,
      endYear,
      favourLevel,
      toneTag,
      keywords,
      isCurrent,
    };
  });
}

/**
 * 从 UTC 时间提取年份
 */
function getYearFromUTC(utc: Date | string): number {
  const date = typeof utc === 'string' ? new Date(utc) : utc;
  return date.getFullYear();
}
```

### 3.2 favourLevel 映射（含「预留」说明 + 兼容旧数据）

```typescript
/**
 * 映射原始喜忌为 UI 展示档位
 *
 * 目前 Phase 1 仅使用 rawFavour，
 * favourScore 作为后续精细化调整的预留字段。
 *
 * 向后兼容：如果 rawFavour 缺失，则一律按 'flat'（平稳）处理。
 */
function mapFavourLevel(
  rawFavour?: '用神' | '中性' | '忌神',
  favourScore?: number
): 'good' | 'wave' | 'flat' {
  if (!rawFavour) {
    // 兼容旧数据：一律按平稳处理
    return 'flat';
  }
  
  if (rawFavour === '用神') return 'good';
  if (rawFavour === '中性') return 'flat';
  
  // rawFavour === '忌神'
  // 统一映射为 'wave'（波动），避免吓用户
  return 'wave';
}
```

**后续 Phase 2 优化方向**：
- 想用上 `favourScore` 时，可以在这里做细分
- 例如：忌神 + `favourScore <= -1.5` → 还是 `wave`，但 `toneTag` / `keywords` 更偏「稳住、保守」

### 3.2 toneTag 规则表（Phase 1）

```typescript
/**
 * toneTag 规则表
 * 格式：`${favourLevel}-${shishen}` → 标签文本
 */
const toneTagMap: Record<string, string> = {
  // ===== 用神 + 吉十神 =====
  'good-正官': '整体偏顺',
  'good-偏官': '压力中有机会',
  'good-正财': '收获期，资源聚拢',
  'good-偏财': '机会多、人脉活跃',
  'good-食神': '学习成长期',
  'good-伤官': '突破创新期',
  'good-正印': '贵人相助，稳步提升',
  'good-偏印': '思考深入，适合学习',
  'good-比肩': '合作机会增多',
  'good-劫财': '竞争激烈但有机会',
  
  // ===== 中性 =====
  'flat-正官': '稳中小进',
  'flat-偏官': '压力与机会并存',
  'flat-正财': '脚踏实地慢慢来',
  'flat-偏财': '机会与风险并存',
  'flat-食神': '平稳发展期',
  'flat-伤官': '需要控制情绪',
  'flat-正印': '调整蓄力期',
  'flat-偏印': '思考期，不宜冲动',
  'flat-比肩': '合作需谨慎',
  'flat-劫财': '竞争压力略大',
  
  // ===== 忌神 → 波动 =====
  'wave-正官': '压力增大，需要稳住',
  'wave-偏官': '压力与突破并存',
  'wave-正财': '财务压力，需谨慎',
  'wave-偏财': '花费增多，要懂取舍',
  'wave-食神': '情绪波动，注意调节',
  'wave-伤官': '容易冲动，需冷静',
  'wave-正印': '依赖心理，需独立',
  'wave-偏印': '思虑过多，需行动',
  'wave-比肩': '竞争压力略大',
  'wave-劫财': '竞争激烈，需谨慎',
};

/**
 * 获取 toneTag（含向后兼容）
 */
function getToneTag(
  level: 'good' | 'wave' | 'flat',
  shishen?: string
): string {
  if (!shishen) {
    // 极端情况下 shishen 为空的 fallback
    if (level === 'good') return '整体偏顺';
    if (level === 'wave') return '压力与机会并存';
    return '整体平稳，适合内调整';
  }
  
  const key = `${level}-${shishen}`;
  const tag = toneTagMap[key];
  
  if (tag) return tag;
  
  // toneTagMap 未覆盖的组合
  if (level === 'good') return '整体偏顺';
  if (level === 'wave') return '压力与机会并存';
  return '整体平稳，适合内调整';
}
```

### 3.3 keywords 规则表（Phase 1）

```typescript
/**
 * keywords 规则表
 * 格式：`${favourLevel}-${shishen}` → 关键词数组
 */
const keywordMap: Record<string, string[]> = {
  // ===== 用神 + 吉十神 =====
  'good-正官': ['事业稳定发展', '责任感提升', '适合规划长远'],
  'good-偏官': ['压力中有机会', '适合挑战', '需要主动出击'],
  'good-正财': ['收获期', '资源聚拢', '适合理财规划'],
  'good-偏财': ['偏财机会多', '人际应酬多', '适合拓展副业'],
  'good-食神': ['学习成长期', '适合进修', '创意灵感多'],
  'good-伤官': ['突破创新期', '适合尝试新方向', '表达欲增强'],
  'good-正印': ['贵人相助', '稳步提升', '适合学习'],
  'good-偏印': ['思考深入', '适合研究', '灵感增多'],
  'good-比肩': ['合作机会增多', '适合团队协作', '人脉拓展'],
  'good-劫财': ['竞争激烈但有机会', '需要主动争取', '适合合作'],
  
  // ===== 中性 =====
  'flat-正官': ['稳中小进', '适合规划', '不要急躁'],
  'flat-偏官': ['压力与机会并存', '需要平衡', '谨慎决策'],
  'flat-正财': ['脚踏实地', '慢慢积累', '不宜冒进'],
  'flat-偏财': ['机会与风险并存', '需要谨慎', '不宜大额投资'],
  'flat-食神': ['平稳发展', '适合学习', '保持节奏'],
  'flat-伤官': ['需要控制情绪', '避免冲动', '理性思考'],
  'flat-正印': ['调整蓄力期', '适合学习', '不要急于求成'],
  'flat-偏印': ['思考期', '不宜冲动', '需要沉淀'],
  'flat-比肩': ['合作需谨慎', '避免竞争', '保持和谐'],
  'flat-劫财': ['竞争压力略大', '需要谨慎', '避免冲突'],
  
  // ===== 忌神 → 波动 =====
  'wave-正官': ['压力增大', '需要稳住', '不要硬扛'],
  'wave-偏官': ['压力与突破并存', '适合磨炼心性', '不要硬扛，学会求助'],
  'wave-正财': ['财务压力', '需谨慎', '不宜大额支出'],
  'wave-偏财': ['消费欲增强', '投资需谨慎', '容易冲动花钱'],
  'wave-食神': ['情绪波动', '注意调节', '保持冷静'],
  'wave-伤官': ['容易冲动', '需冷静', '避免口舌'],
  'wave-正印': ['依赖心理', '需独立', '不要过度依赖'],
  'wave-偏印': ['思虑过多', '需行动', '避免钻牛角尖'],
  'wave-比肩': ['竞争压力略大', '需要谨慎', '避免冲突'],
  'wave-劫财': ['竞争激烈', '需谨慎', '避免破财'],
};

/**
 * 获取 keywords（含向后兼容）
 */
function getKeywords(
  favourLevel: 'good' | 'wave' | 'flat',
  shishen?: string
): string[] {
  if (!shishen) {
    // 极端情况下 shishen 为空，返回空数组
    return [];
  }
  
  const key = `${favourLevel}-${shishen}`;
  const keywords = keywordMap[key];
  
  // 如果查不到配置，就返回空数组 []，UI 可直接不渲染关键词区域
  return keywords || [];
}
```

---

## 四、API 层集成（baziService）

### 4.1 剥离内部字段，只暴露 luckCycle

```typescript
// core/src/modules/bazi/baziService.ts

import { buildLuckCycleForApp } from '../utils/luckCycleAdapter';

export async function getChartDetail(params: {
  userId: string;
  chartId: string;
}): Promise<any> {
  // 1. 查询数据库
  // ... 现有查询逻辑 ...
  
  const resultJson = JSON.parse(row.result_json);
  
  // 2. 计算当前年龄
  const currentAge = calculateCurrentAge(resultJson.birthInfo);
  
  // 3. 从引擎原始数据构建 luckCycle
  let luckCycle: LuckCycleData[] = [];
  if (resultJson.derived?.luck_cycle) {
    luckCycle = buildLuckCycleForApp(
      resultJson.derived.luck_cycle,
      currentAge
    );
  }
  
  // 4. 从 derived 中剥掉 luck_cycle，只保留对外结构
  const { luck_cycle, ...derivedRest } = resultJson.derived || {};
  
  const result = {
    ...resultJson,
    derived: {
      ...derivedRest,
      luckCycle,  // ✅ 唯一对外暴露的时间轴数据
    },
  };
  
  return {
    profile,
    result,
  };
}

/**
 * 计算当前年龄（虚岁 or 实岁，按你系统既有约定）
 */
function calculateCurrentAge(birthInfo: any): number {
  const { year, month, day } = birthInfo;
  const birthDate = new Date(year, month - 1, day);
  const now = new Date();
  const ageMs = now.getTime() - birthDate.getTime();
  const ageYears = ageMs / (365.25 * 24 * 60 * 60 * 1000);
  return Math.floor(ageYears);
}
```

---

## 五、前端使用约定

### 5.1 前端类型定义

```typescript
// app/src/types/chart.ts 或 app/src/components/bazi/LuckCycleList.tsx

export interface LuckCycleData {
  id: string;                // 唯一 ID，如 "甲子-31"
  stemBranch: string;        // "甲子"
  shishen: string;           // 十神（如 "偏财"）✅ 统一用 shishen
  startAge: number;          // 31
  endAge: number;            // 41（下一运起运虚岁，不包含）
  startYear: number;         // 2025
  endYear: number;           // 2035（下一运起运年，不包含）
  favourLevel: 'good' | 'wave' | 'flat';  // UI 展示用
  toneTag: string;           // "整体偏顺" / "学习成长期" / "压力与突破并存"
  keywords: string[];        // ["事业拓展", "偏财机会多", "人际应酬多"]
  isCurrent: boolean;        // 是否当前大运
}
```

### 5.2 前端使用规范

**只读 `derived.luckCycle`，不读 `derived.luck_cycle`**

渲染卡片时使用：
- `stemBranch`：大字，如「甲子」
- `shishen`：副标题，如「偏财」
- `startAge–endAge`：`31–41岁`（展示文案，实际逻辑为 `[31,41)`）
- `startYear–endYear`：`2025–2035`（展示文案，表示大致范围）
- `toneTag`：一行简评
- 根据 `favourLevel` 映射颜色 / 当前卡片高亮

**当前大运判断**：由后端算好（`isCurrent`），前端只负责根据 `isCurrent` 渲染高亮样式。

---

## 六、UI 实现要点

### 6.1 卡片样式规则

**颜色映射**：
```typescript
const levelColorMap = {
  good: '#3b8c5a',  // 深绿（淡调）
  wave: '#d68a27',  // 橙色（淡调）
  flat: '#999999',  // 灰色（淡调）
};
```

**当前大运高亮**：
- 加粗外边框（2px）
- 轻微阴影
- 可选：缩放 1.05

### 6.2 卡片布局（5 块）

1. **大字（顶部）**：干支（如"甲子"）
2. **辅字（小一号）**：十神（如"偏财"）
3. **年龄段**：`31 – 41岁`
4. **起止年份**：`2025 – 2034`
5. **简评标签**：`toneTag`（如"整体偏顺"）
6. **底部按钮**：`👉 解读这一步大运`

### 6.3 底部 Sheet 内容

- **标题**：`{stemBranch}大运（{startAge}–{endAge}岁）`
- **年份**：`{startYear} – {endYear}`
- **关键词标签**：显示 `keywords` 数组（3-5 个）
- **快捷提问按钮**（3 个）：
  - "这步大运的事业重点是什么？"
  - "这步大运感情大概是怎样的趋势？"
  - "这步大运财运有什么机会和坑？"

---

## 七、实施步骤

### Phase 1：规则表实现（当前）

1. ✅ **后端引擎层**：补充 `rawFavour`、`favourScore` 字段
2. ✅ **适配层**：创建 `luckCycleAdapter.ts`，实现规则表
3. ✅ **API 层**：在 `baziService.getChartDetail` 中调用适配层
4. ✅ **前端类型**：更新 `LuckCycleData` 接口
5. ✅ **前端 UI**：更新卡片样式，增加颜色规则和当前大运高亮
6. ✅ **底部 Sheet**：实现点击交互和快捷提问

### Phase 2：LLM 升级（后续）

1. 在适配层中，将 `getToneTag` 和 `getKeywords` 改为：
   - 先查规则表
   - 如果规则表没有，调用小模型从固定选项池中选择
   - 避免自由发挥，保持风格一致

---

## 八、关键决策总结

### 8.1 已确认的决策

1. ✅ **favourLevel 映射**：`'忌神'` → `'wave'`（统一为波动，不吓用户）
2. ✅ **toneTag 生成**：Phase 1 规则表，Phase 2 LLM 从固定选项选
3. ✅ **keywords 生成**：Phase 1 规则表，Phase 2 LLM 从短语池选
4. ✅ **实现位置**：引擎层输出干净数据，适配层生成展示字段

### 8.2 规则表覆盖范围

- **toneTag**：覆盖 30 种组合（3 种 favourLevel × 10 种十神）
- **keywords**：覆盖 30 种组合，每种 3-5 个关键词
- **Fallback**：未覆盖的组合使用通用标签

---

## 九、后续优化方向

1. **favourScore 细化**：根据用神稀缺度、冲合刑害强度等更精确计算
2. **LLM 升级**：Phase 2 时，让模型从固定选项池中选择，保持风格一致
3. **关键词扩展**：根据特殊格局（如食伤生财、印比护官）动态添加关键词
4. **个性化**：根据用户历史对话偏好，调整 toneTag 和 keywords 的生成策略

---

## 十、注意事项

1. **不要吓用户**：所有标签和关键词都保持温和、建设性的语气
2. **风格一致**：规则表和后续 LLM 都要遵循统一的风格指南
3. **向后兼容**：适配层要兼容旧数据（没有 `rawFavour`、`shishen` 为空的情况）
4. **性能考虑**：规则表查询是 O(1)，性能无压力
5. **字段命名统一**：全链路统一用 `shishen`，前端严禁依赖 `derived.luck_cycle`

---

## 十一、「产品视角」的小结

1. **年龄 & 年份的规则是严谨且写死的，不再靠猜**
   - 半开区间 `[startAge, endAge)` 和 `[startYear, endYear)` 的定义明确
   - 当前大运判断公式固定：`currentAge >= startAge && currentAge < endAge`

2. **前端使用的字段名和数据结构是唯一、稳定的**
   - `derived.luckCycle` + `shishen` 是唯一对外接口
   - 引擎层可以自由迭代算法，而不破坏前端 / UI 的合同

3. **未来要升级体验时，只动适配层即可**
   - 精确节气、用 `favourScore` 调整标签、用 LLM 精修文案
   - 前端完全不用改

---

**文档版本**：v1.1（整合版）  
**最后更新**：2024-12-XX  
**状态**：✅ 方案已确认，可开始实施

