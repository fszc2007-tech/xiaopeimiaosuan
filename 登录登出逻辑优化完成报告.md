# 登录/登出逻辑优化完成报告

## 一、核心原则

✅ **以后 App 里登录状态只认一件事：`authStore`**

- 登录状态以 `authStore` 为**唯一真相源**：
  - `token`
  - `user`
  - `isAuthenticated`
- API 返回的数据（如 `profile`）：**只当资料补充**，不作为「是否登录」的判断依据

---

## 二、修改内容（P0 - 最小必改版）

### **App 端修改**

#### 1️⃣ **MeScreen.tsx**（`app/src/screens/Me/MeScreen.tsx`）

**新增变量**（第 58 行后）：
```typescript
// ✅ 统一登录状态判断：只认 authStore
const isLoggedIn = isAuthenticated && !!user;
```

**修改用户信息显示逻辑**（第 168-180 行）：
```typescript
// 原来：使用 profile?.phone
// 现在：使用 user.phone + isLoggedIn 判断
<Text style={styles.profilePhone}>
  {isLoggedIn
    ? (user.phone ?? user.email ?? t('me.notLoggedIn'))
    : t('me.notLoggedIn')}
</Text>
{isLoggedIn && user.isPro ? (
  <View style={styles.proTag}>
    <Crown color={colors.yellowPro} size={14} />
    <Text style={styles.proTagText}>
      小佩 Pro · 至 {formatProExpiry(user.proExpiresAt)}
    </Text>
  </View>
) : (
  <Text style={styles.profileDesc}>免費版</Text>
)}
```

---

#### 2️⃣ **SettingsScreen.tsx**（`app/src/screens/Settings/SettingsScreen.tsx`）

**新增变量**（第 51-52 行）：
```typescript
const user = useAuthStore((state) => state.user);
const canLogout = isAuthenticated && !!user; // ✅ 双重检查
```

**修改登出按钮显示条件**（第 178 行）：
```typescript
// 原来：{isAuthenticated && (
// 现在：{canLogout && (
{canLogout && (
  <View style={styles.logoutSection}>
    <Pressable 
      style={({ pressed }) => [
        styles.logoutButton,
        pressed && styles.logoutButtonPressed,
      ]} 
      onPress={handleLogoutClick}
    >
      <LogOut color={colors.error} size={20} />
      <Text style={styles.logoutButtonText}>退出登錄</Text>
    </Pressable>
  </View>
)}
```

---

#### 3️⃣ **authStore.ts**（`app/src/store/authStore.ts`）

**修改数据恢复时的自动修复逻辑**（第 194-205 行）：
```typescript
// ✅ 自动修复：如果声称已登录但缺少关键数据，强制登出
if (state?.isAuthenticated && (!state?.token || !state?.user)) {
  console.error('[authStore] ⚠️ 数据不一致：isAuthenticated=true 但缺少 token/user，自动修复');
  state.isAuthenticated = false;
  state.user = null;
  state.token = null;
  console.log('[authStore] ✅ 已自动修复为未登录状态');
}

// ✅ 反向检查：有 token 但说没登录，也修复一致性
if (state?.token && state?.user && !state?.isAuthenticated) {
  console.warn('[authStore] ⚠️ 有 token/user 但 isAuthenticated=false，自动修复');
  state.isAuthenticated = true;
  console.log('[authStore] ✅ 已自动修复为已登录状态');
}
```

---

#### 4️⃣ **apiClient.ts**（`app/src/services/api/apiClient.ts`）

**优化 401 错误处理**（第 164-170 行）：
```typescript
// 2. 401 未授权 → 跳转登录
if (status === 401) {
  const { isAuthenticated } = useAuthStore.getState();
  // ✅ 只有在声称已登录时才需要 logout + toast
  if (isAuthenticated) {
    showToast('登入已過期，請重新登入', 'warning');
    useAuthStore.getState().logout();
  }
  // 未登录状态收到 401 是正常的（例如探测请求），静默处理
  return;
}
```

---

### **Web 端修改（H5 版）**

#### 5️⃣ **Me.tsx**（`web/src/pages/Me.tsx`）

**新增变量**（第 16-18 行）：
```typescript
const isAuthenticated = useAuthStore((state) => state.isAuthenticated);

// ✅ 统一登录状态判断：只认 authStore
const isLoggedIn = isAuthenticated && !!user;
```

**修改登出按钮显示条件**（第 107-111 行）：
```typescript
{/* 登出按钮 - 仅在已登录且有用户信息时显示 */}
{isLoggedIn && (
  <div className="menu-section">
    <button className="logout-menu-button" onClick={handleLogout}>
      登出
    </button>
  </div>
)}
```

**修改升级按钮显示条件**（第 99 行）：
```typescript
// 原来：{!user?.isPro && (
// 现在：{isLoggedIn && !user.isPro && (
{isLoggedIn && !user.isPro && (
  <div className="menu-section">
    <button className="upgrade-button" onClick={() => alert('Pro 訂閱功能開發中')}>
      ⭐ 升級為 Pro 會員
    </button>
  </div>
)}
```

---

#### 6️⃣ **authStore.ts**（`web/src/store/authStore.ts`）

**增强初始化逻辑**（第 106-123 行）：
```typescript
initialize: () => {
  console.log('[AuthStore] 初始化');
  
  const token = storage.getToken();
  const user = storage.getUser();
  
  // ✅ 自动修复：数据完整性检查
  if (token && user) {
    console.log('[AuthStore] 發現已保存的登錄信息');
    set({
      token,
      user,
      isAuthenticated: true,
      appRegion: user.appRegion,
    });
  } else if (token || user) {
    // ⚠️ 数据不一致：只有 token 或只有 user，清理脏数据
    console.warn('[AuthStore] 發現不完整的登錄數據，自動清理');
    storage.clear();
    set(initialState);
  } else {
    console.log('[AuthStore] 未找到登錄信息');
  }
}
```

---

#### 7️⃣ **apiClient.ts**（`web/src/services/api/apiClient.ts`）

**导入 authStore**（第 11 行后新增）：
```typescript
import { useAuthStore } from '@/store';
```

**优化 401 错误处理**（第 45-57 行）：
```typescript
apiClient.interceptors.response.use(
  (response) => {
    return response;
  },
  (error: AxiosError) => {
    // Token 過期或無效
    if (error.response?.status === 401) {
      const { isAuthenticated } = useAuthStore.getState();
      // ✅ 只有在声称已登录时才需要清空 + 跳转
      if (isAuthenticated) {
        storage.clear();
        window.location.href = '/login';
      }
      // 未登录状态收到 401 是正常的（例如探测请求），静默处理
    }
    return Promise.reject(error);
  }
);
```

---

## 三、修改摘要

| 平台 | 文件 | 修改点 | 改动量 |
|------|------|-------|--------|
| **App** | `MeScreen.tsx` | 1. 新增 `isLoggedIn` 判断<br>2. 改用 `user` 替代 `profile` | ~15 行 |
| **App** | `SettingsScreen.tsx` | 1. 新增 `canLogout` 判断<br>2. 改用 `canLogout` 控制按钮 | ~3 行 |
| **App** | `authStore.ts` | 恢复时主动修复不一致状态 | ~12 行 |
| **App** | `apiClient.ts` | 401 处理增加 `isAuthenticated` 判断 | ~5 行 |
| **Web** | `Me.tsx` | 1. 新增 `isLoggedIn` 判断<br>2. 登出/升级按钮增加条件 | ~8 行 |
| **Web** | `authStore.ts` | 初始化时增加数据完整性检查 | ~10 行 |
| **Web** | `apiClient.ts` | 401 处理增加 `isAuthenticated` 判断 | ~5 行 |

**总改动量**：~58 行代码，7 个文件

---

## 四、解决的问题

### **✅ 修复前的问题**

1. **状态不一致**：
   - MeScreen 使用 `profile`（API 数据）判断登录
   - SettingsScreen 使用 `isAuthenticated`（Store 数据）判断登录
   - 导致「未登入」文案 + 「退出登錄」按钮同时出现

2. **缺少防御性检查**：
   - 登出按钮在 `isAuthenticated=true` 但 `user=null` 时仍然显示

3. **401 处理不够智能**：
   - 未登录时的探测请求收到 401 也会触发 toast 和 logout

4. **缺少自动修复机制**：
   - 数据恢复时发现不一致状态只记录警告，不主动修复

### **✅ 修复后的效果**

1. **状态统一**：
   - 所有页面统一使用 `authStore.user` + `isAuthenticated` 判断
   - 不再出现状态撕裂

2. **双重保护**：
   - 关键操作增加 `isAuthenticated && !!user` 双重检查
   - 防止边缘 case 导致的 UI 错误

3. **智能 401 处理**：
   - 只在真正已登录时才执行 logout + toast
   - 减少无意义的错误提示

4. **自动修复机制**：
   - 数据恢复时主动检测并修复不一致状态
   - 防止脏数据导致的异常行为

---

## 五、测试建议

### **测试场景 1：正常登录登出**
1. 登录 → 查看"我的"页面 → 应该显示手机号/邮箱
2. 进入"设置" → 应该显示"退出登錄"按钮
3. 点击退出 → 应该跳转到登录页

### **测试场景 2：Token 过期**
1. 登录后关闭 App
2. 手动删除数据库中的 token 或等待 token 过期
3. 重新打开 App
4. 应该自动清除登录状态，跳转到登录页

### **测试场景 3：脏数据清理**
1. 手动修改 AsyncStorage/localStorage：
   - 设置 `isAuthenticated=true`
   - 删除 `token` 或 `user`
2. 重新打开 App
3. 应该自动修复为未登录状态

### **测试场景 4：未登录探测请求**
1. 清空登录状态
2. 访问需要登录的页面（会被路由保护拦截）
3. 不应该弹出"登录已过期"的 toast

---

## 六、后续优化（P1 - 可选）

如有需要，可以继续完善：

1. **引入 `authStatus` 字段**：
   - `idle` / `checking` / `guest` / `authed`
   - 提供更细粒度的状态管理

2. **App 启动时主动验证 Token**：
   - 调用 `/users/me` 验证 token 有效性
   - 避免用户操作时才发现 token 过期

3. **使用骨架屏代替加载闪烁**：
   - `authStatus === 'checking'` 时显示 skeleton
   - 提升用户体验

---

## 七、总结

本次优化遵循**"authStore 唯一真相源"**原则，通过：

- ✅ **统一状态判断**：所有页面使用 `authStore`
- ✅ **双重防护**：关键操作增加 `user` 检查
- ✅ **自动修复**：数据恢复时主动修正不一致
- ✅ **智能 401 处理**：只在真正登录时执行 logout

彻底解决了**"未登录状态显示登出按钮"**的逻辑矛盾问题，同时提升了系统的健壮性和用户体验。

---

**修改完成时间**：2025-12-02  
**修改人员**：AI Assistant  
**验证状态**：✅ 所有修改已通过 Linter 检查，无错误


