# 追问功能问题诊断报告

## 问题现象
用户测试"恋爱桃花"场景，追问没有显示出来。

## 代码逻辑分析

### 1. 时序问题（最可能的原因）

**问题位置**：`core/src/routes/conversation.ts` 第 789-842 行

**执行顺序**：
1. 第 789 行：开始异步生成追问（`.then()` 不阻塞）
2. 第 836-842 行：**立即执行** `res.write('done')` 和 `res.end()`
3. 追问生成完成后（可能在 `res.end()` 之后），尝试发送但流已关闭

**关键代码**：
```typescript
// 第 793 行：异步生成追问（不阻塞）
readingService.generateFollowUps({...}).then(async (followups) => {
  // 这里可能在 res.end() 之后才执行
  if (!res.destroyed && res.writable) {
    res.write(`data: ${JSON.stringify({ type: 'followups', followups })}\n\n`);
  }
});

// 第 836-842 行：立即执行，不等待追问生成
res.write(`data: ${JSON.stringify({ type: 'done', ... })}\n\n`);
res.end(); // 流在这里关闭了！
```

### 2. 可能的原因列表

#### 原因 A：时序问题（最可能）
- **现象**：追问生成是异步的，但 `res.end()` 在追问生成完成前就执行了
- **证据**：代码中追问生成使用 `.then()`，而 `res.end()` 是同步执行的
- **影响**：追问生成完成后，响应流已经关闭，无法发送

#### 原因 B：错误消息过滤
- **检查点**：`isErrorOrSystemMessage` 判断是否拦截了正常消息
- **可能触发**：如果 `fullResponse` 包含"错误"关键字或长度 < 20
- **检查方法**：查看日志中是否有 `[Follow-ups] Skipping generation for error/system message`

#### 原因 C：LLM 生成失败
- **检查点**：`generateFollowUps` 是否抛出异常
- **可能触发**：LLM API 调用失败、JSON 解析失败
- **检查方法**：查看日志中是否有 `[Follow-ups] Generation failed`

#### 原因 D：前端未正确处理
- **检查点**：前端 SSE 事件处理是否正确
- **可能触发**：前端代码未处理 `type: 'followups'` 事件
- **状态**：已修复，但需要确认是否生效

#### 原因 E：响应流已关闭
- **检查点**：`res.destroyed` 或 `!res.writable` 为 true
- **可能触发**：在追问生成完成前，响应流被关闭
- **检查方法**：查看日志中是否有 `[Follow-ups] Response stream already closed`

## 诊断步骤

### 1. 检查后端日志

查看是否有以下日志输出：

```bash
# 应该看到的日志：
[Follow-ups] Starting generation for scene: love, conversationId: xxx
[Follow-ups] Generated 3 followups: [...]
[Follow-ups] Saved to database for messageId: xxx
[Follow-ups] Sent SSE event: {...}

# 如果看到这些，说明追问生成成功：
[Follow-ups] Skipping generation for error/system message  # 被过滤了
[Follow-ups] Generation failed: ...  # 生成失败
[Follow-ups] Response stream already closed  # 流已关闭
[Follow-ups] No followups generated or empty array  # 生成为空
```

### 2. 检查时序

**问题**：追问生成是异步的，但 `res.end()` 是同步执行的

**验证方法**：
1. 查看日志时间戳
2. 确认 `[Follow-ups] Sent SSE event` 是否在 `res.end()` 之前执行
3. 如果 `Sent SSE event` 的日志在 `res.end()` 之后，说明是时序问题

### 3. 检查前端日志

查看前端控制台是否有：
```javascript
[ChatScreen] Received followups: [...]
```

如果没有，说明前端没有接收到追问事件。

## 解决方案建议

### 方案 1：等待追问生成完成（推荐）

**修改点**：在 `res.end()` 之前等待追问生成完成

**代码位置**：`core/src/routes/conversation.ts` 第 789-842 行

**逻辑**：
- 使用 `await` 等待追问生成完成
- 在追问发送后再执行 `res.end()`
- 设置超时机制（如 5 秒），避免无限等待

### 方案 2：在 done 事件中发送追问

**修改点**：将追问数据包含在 `done` 事件中

**逻辑**：
- 等待追问生成完成
- 在 `done` 事件中包含 `followups` 字段
- 前端从 `done` 事件中提取追问

### 方案 3：使用独立的追问接口

**修改点**：追问生成完成后，通过独立的 HTTP 请求发送

**逻辑**：
- 追问生成完成后，调用前端回调接口
- 或前端轮询查询追问状态
- 或使用 WebSocket 推送

## 当前代码问题总结

1. **时序问题**：追问生成是异步的，但 `res.end()` 是同步的
2. **流关闭时机**：可能在追问生成完成前就关闭了响应流
3. **错误处理**：追问生成失败时静默失败，没有重试机制

## 建议的检查清单

- [ ] 查看后端日志，确认追问是否生成
- [ ] 查看日志时间戳，确认时序问题
- [ ] 检查 `isErrorOrSystemMessage` 是否误判
- [ ] 检查 `generateFollowUps` 是否抛出异常
- [ ] 检查前端是否接收到 `followups` 事件
- [ ] 检查响应流是否在追问发送前关闭

