# å°ä½© App å®‰å…¨æ€§è¯„ä¼°æŠ¥å‘Š - ç¬¬ä¸€éƒ¨åˆ†

## ç›®å½•
1. [é¡¹ç›®ç›®å½•ç»“æ„](#é¡¹ç›®ç›®å½•ç»“æ„)
2. [åç«¯å…¥å£æ–‡ä»¶](#åç«¯å…¥å£æ–‡ä»¶)
3. [è®¤è¯ä¸æˆæƒä¸­é—´ä»¶](#è®¤è¯ä¸æˆæƒä¸­é—´ä»¶)
4. [è·¯ç”±ä¸æ§åˆ¶å™¨](#è·¯ç”±ä¸æ§åˆ¶å™¨)
5. [ç¯å¢ƒå˜é‡é…ç½®](#ç¯å¢ƒå˜é‡é…ç½®)

---

## é¡¹ç›®ç›®å½•ç»“æ„

```
xiaopei-app/
â”œâ”€â”€ core/                    # åç«¯æœåŠ¡
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ server.ts       # æœåŠ¡å™¨å…¥å£
â”‚   â”‚   â”œâ”€â”€ config/         # é…ç½®æ–‡ä»¶
â”‚   â”‚   â”‚   â””â”€â”€ auth.ts     # è®¤è¯é…ç½®
â”‚   â”‚   â”œâ”€â”€ database/       # æ•°æ®åº“ç›¸å…³
â”‚   â”‚   â”‚   â”œâ”€â”€ connection.ts
â”‚   â”‚   â”‚   â””â”€â”€ migrations/ # æ•°æ®åº“è¿ç§»
â”‚   â”‚   â”œâ”€â”€ middleware/     # ä¸­é—´ä»¶
â”‚   â”‚   â”‚   â”œâ”€â”€ auth.ts     # ç”¨æˆ·è®¤è¯
â”‚   â”‚   â”‚   â”œâ”€â”€ adminAuth.ts # Adminè®¤è¯
â”‚   â”‚   â”‚   â”œâ”€â”€ rateLimit.ts # é™æµ
â”‚   â”‚   â”‚   â”œâ”€â”€ requirePro.ts # Proæƒé™æ£€æŸ¥
â”‚   â”‚   â”‚   â””â”€â”€ requireProFeature.ts
â”‚   â”‚   â”œâ”€â”€ modules/        # ä¸šåŠ¡æ¨¡å—
â”‚   â”‚   â”‚   â”œâ”€â”€ auth/       # è®¤è¯æœåŠ¡
â”‚   â”‚   â”‚   â”œâ”€â”€ admin/      # AdminæœåŠ¡
â”‚   â”‚   â”‚   â”œâ”€â”€ pro/         # Proè®¢é˜…æœåŠ¡
â”‚   â”‚   â”‚   â””â”€â”€ ...
â”‚   â”‚   â””â”€â”€ routes/         # è·¯ç”±
â”‚   â”‚       â”œâ”€â”€ auth.ts
â”‚   â”‚       â”œâ”€â”€ pro.ts
â”‚   â”‚       â””â”€â”€ admin/
â”‚   â””â”€â”€ engine/             # å…«å­—å¼•æ“
â”‚
â”œâ”€â”€ app/                    # React Native App
â”‚   â”œâ”€â”€ App.tsx            # Appå…¥å£
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”‚   â”œâ”€â”€ api/       # APIå®¢æˆ·ç«¯
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ apiClient.ts
â”‚   â”‚   â”‚   â””â”€â”€ storage/   # æœ¬åœ°å­˜å‚¨
â”‚   â”‚   â”‚       â””â”€â”€ StorageService.ts
â”‚   â”‚   â”œâ”€â”€ utils/
â”‚   â”‚   â”‚   â””â”€â”€ initializeAuth.ts
â”‚   â”‚   â””â”€â”€ store/         # çŠ¶æ€ç®¡ç†
â”‚   â”œâ”€â”€ ios/               # iOSé…ç½®
â”‚   â”‚   â””â”€â”€ app/
â”‚   â”‚       â”œâ”€â”€ Info.plist
â”‚   â”‚       â””â”€â”€ app.entitlements
â”‚   â””â”€â”€ android/           # Androidé…ç½®
â”‚       â””â”€â”€ app/
â”‚           â”œâ”€â”€ build.gradle
â”‚           â”œâ”€â”€ proguard-rules.pro
â”‚           â””â”€â”€ src/main/AndroidManifest.xml
â”‚
â””â”€â”€ admin/                 # Adminåå°ï¼ˆå‰ç«¯ï¼‰
    â””â”€â”€ src/
```

---

## åç«¯å…¥å£æ–‡ä»¶

### `core/src/server.ts`

```1:161:core/src/server.ts
/**
 * Core åç«¯æœåŠ¡å…¥å£
 * 
 * è´Ÿè´£å¯åŠ¨ Express æœåŠ¡å™¨ï¼Œæ³¨å†Œè·¯ç”±å’Œä¸­é—´ä»¶
 */

import express, { Application } from 'express';
import cors from 'cors';
import dotenv from 'dotenv';
import { createConnection } from './database/connection';

// åŠ è½½ç¯å¢ƒå˜é‡
dotenv.config();

const app: Application = express();
const PORT = process.env.XIAOPEI_CORE_PORT || 3000;

// ===== ä¸­é—´ä»¶é…ç½® =====

// CORS é…ç½®
const allowedOrigins = process.env.ALLOWED_ORIGINS?.split(',') || [
  'http://localhost:19006',  // App å‰ç«¯
  'http://localhost:5173',   // Admin å‰ç«¯
  /^exp:\/\/.*/,  // Expo Go (æ‰€æœ‰ exp:// å¼€å¤´çš„ origin)
  /^http:\/\/192\.168\.\d+\.\d+:.*/,  // å±€åŸŸç½‘ IP
  /^http:\/\/10\.\d+\.\d+\.\d+:.*/,   // 10.x.x.x ç½‘æ®µ
];
app.use(cors({
  origin: (origin, callback) => {
    // å¼€å‘ç¯å¢ƒï¼šå…è®¸æ‰€æœ‰è¯·æ±‚
    if (process.env.NODE_ENV === 'development' || !process.env.NODE_ENV) {
      console.log('[CORS] Development mode - allowing origin:', origin || 'null');
      return callback(null, true);
    }
    
    // ç”Ÿäº§ç¯å¢ƒï¼šå…è®¸æ—  origin çš„è¯·æ±‚ï¼ˆç§»åŠ¨ç«¯ï¼‰
    if (!origin) return callback(null, true);
    
    // æ£€æŸ¥æ˜¯å¦åŒ¹é…å…è®¸çš„ origin
    const isAllowed = allowedOrigins.some(allowed => {
      if (typeof allowed === 'string') {
        return origin === allowed;
      }
      if (allowed instanceof RegExp) {
        return allowed.test(origin);
      }
      return false;
    });
    
    if (isAllowed) {
      callback(null, true);
    } else {
      console.warn('[CORS] Blocked origin:', origin);
      callback(new Error('Not allowed by CORS'));
    }
  },
  credentials: true,
}));

// Body è§£æ
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// è¯·æ±‚æ—¥å¿—ï¼ˆç®€å•ç‰ˆï¼‰
app.use((req, _res, next) => {
  console.log(`[Request] ${req.method} ${req.path}`);
  next();
});

// ===== è·¯ç”±æ³¨å†Œ =====

// å¥åº·æ£€æŸ¥
app.get('/health', (_req, res) => {
  res.json({ 
    success: true, 
    data: { 
      status: 'ok', 
      timestamp: new Date().toISOString(),
      version: '1.0.0',
    } 
  });
});

// API è·¯ç”±
import authRoutes from './routes/auth';
import baziRoutes from './routes/bazi';
import readingRoutes from './routes/reading';
import conversationRoutes from './routes/conversation';
import proRoutes from './routes/pro';
import adminRoutes from './routes/admin';

app.use('/api/v1/auth', authRoutes);
app.use('/api/v1/bazi', baziRoutes);
app.use('/api/v1/reading', readingRoutes);
app.use('/api/v1/chat/conversations', conversationRoutes); // ä¿®å¤ï¼šç»Ÿä¸€ä½¿ç”¨ /chat/ å‰ç¼€
app.use('/api/v1/pro', proRoutes);

app.use('/api/admin/v1', adminRoutes);

// ===== é”™è¯¯å¤„ç† =====

// 404 å¤„ç†
app.use((_req, res) => {
  res.status(404).json({
    success: false,
    error: {
      code: 'NOT_FOUND',
      message: 'è¯·æ±‚çš„èµ„æºä¸å­˜åœ¨',
    },
  });
});

// å…¨å±€é”™è¯¯å¤„ç†
app.use((err: any, _req: express.Request, res: express.Response, _next: express.NextFunction) => {
  console.error('[Error]', err);
  
  res.status(err.status || 500).json({
    success: false,
    error: {
      code: err.code || 'INTERNAL_SERVER_ERROR',
      message: err.message || 'æœåŠ¡å™¨å†…éƒ¨é”™è¯¯',
      details: process.env.NODE_ENV === 'development' ? err.stack : undefined,
    },
  });
});

// ===== å¯åŠ¨æœåŠ¡å™¨ =====

async function startServer() {
  try {
    // è¿æ¥æ•°æ®åº“
    await createConnection();
    console.log('[Database] Connected successfully');
    
    // å¯åŠ¨æœåŠ¡å™¨ï¼ˆç›‘å¬æ‰€æœ‰ç½‘ç»œæ¥å£ï¼‰
    app.listen(PORT, '0.0.0.0', () => {
      console.log(`[Server] Core service is running on port ${PORT}`);
      console.log(`[Server] Environment: ${process.env.NODE_ENV || 'development'}`);
      console.log(`[Server] Health check: http://localhost:${PORT}/health`);
      console.log(`[Server] Local network: http://172.20.10.2:${PORT}/health`);
    });
  } catch (error) {
    console.error('[Server] Failed to start:', error);
    process.exit(1);
  }
}

// å¯åŠ¨æœåŠ¡å™¨
startServer();

// ä¼˜é›…å…³é—­
process.on('SIGTERM', () => {
  console.log('[Server] SIGTERM received, shutting down gracefully...');
  process.exit(0);
});

process.on('SIGINT', () => {
  console.log('[Server] SIGINT received, shutting down gracefully...');
  process.exit(0);
});
```

**å®‰å…¨è§‚å¯Ÿç‚¹ï¼š**
- âœ… ä½¿ç”¨ç¯å¢ƒå˜é‡é…ç½®ç«¯å£
- âš ï¸ **å¼€å‘ç¯å¢ƒ CORS å®Œå…¨å¼€æ”¾**ï¼ˆç”Ÿäº§ç¯å¢ƒéœ€ä¸¥æ ¼é™åˆ¶ï¼‰
- âš ï¸ **é”™è¯¯ä¿¡æ¯åœ¨ç”Ÿäº§ç¯å¢ƒæš´éœ²å †æ ˆ**ï¼ˆå·²é€šè¿‡ `NODE_ENV` æ§åˆ¶ï¼Œä½†éœ€ç¡®è®¤ï¼‰
- âš ï¸ **æœåŠ¡å™¨ç›‘å¬ `0.0.0.0`**ï¼ˆæ‰€æœ‰ç½‘ç»œæ¥å£ï¼Œéœ€ç¡®ä¿é˜²ç«å¢™é…ç½®ï¼‰

---

## è®¤è¯ä¸æˆæƒä¸­é—´ä»¶

### 1. ç”¨æˆ·è®¤è¯ä¸­é—´ä»¶ (`core/src/middleware/auth.ts`)

```1:55:core/src/middleware/auth.ts
/**
 * è®¤è¯ä¸­é—´ä»¶
 * 
 * ç”¨äºä¿æŠ¤éœ€è¦ç™»å½•çš„è·¯ç”±
 */

import { Request, Response, NextFunction } from 'express';
import { verifyToken } from '../modules/auth/authService';
import { ApiResponse } from '../types';

// æ‰©å±• Express Request ç±»å‹ï¼Œæ·»åŠ  userId å±æ€§
declare global {
  namespace Express {
    interface Request {
      userId?: string;
    }
  }
}

/**
 * è®¤è¯ä¸­é—´ä»¶
 * éªŒè¯ JWT Tokenï¼Œå¹¶å°† userId æ·»åŠ åˆ° req.userId
 */
export function authMiddleware(req: Request, res: Response, next: NextFunction) {
  try {
    const token = req.headers.authorization?.replace('Bearer ', '');
    
    if (!token) {
      return res.status(401).json({
        success: false,
        error: {
          code: 'TOKEN_REQUIRED',
          message: 'æœªæä¾›è®¤è¯ Token',
        },
      } as ApiResponse);
    }
    
    const { userId } = verifyToken(token);
    req.userId = userId;
    
    next();
  } catch (error) {
    return res.status(401).json({
      success: false,
      error: {
        code: 'INVALID_TOKEN',
        message: 'Token æ— æ•ˆæˆ–å·²è¿‡æœŸ',
      },
    } as ApiResponse);
  }
}

// å¯¼å‡ºåˆ«å
export const requireAuth = authMiddleware;
```

**å®‰å…¨è§‚å¯Ÿç‚¹ï¼š**
- âœ… ä½¿ç”¨ JWT Token è®¤è¯
- âœ… ç»Ÿä¸€çš„é”™è¯¯å“åº”æ ¼å¼
- âš ï¸ **Token éªŒè¯å¤±è´¥æ—¶æœªè®°å½•æ—¥å¿—**ï¼ˆå¯èƒ½å½±å“å®‰å…¨å®¡è®¡ï¼‰

### 2. Admin è®¤è¯ä¸­é—´ä»¶ (`core/src/middleware/adminAuth.ts`)

```1:146:core/src/middleware/adminAuth.ts
/**
 * Admin è®¤è¯ä¸­é—´ä»¶
 * 
 * åŠŸèƒ½ï¼š
 * 1. éªŒè¯ Admin JWT Token
 * 2. æƒé™æ£€æŸ¥ï¼ˆsuper_admin / adminï¼‰
 * 3. å°† Admin ä¿¡æ¯æ³¨å…¥ req
 * 
 * éµå¾ªæ–‡æ¡£ï¼š
 * - admin.doc/Adminåå°æœ€å°éœ€æ±‚åŠŸèƒ½æ–‡æ¡£.md
 * - Phase 4 éœ€æ±‚ç¡®è®¤ï¼ˆæœ€ç»ˆç‰ˆï¼‰
 */

import { Request, Response, NextFunction } from 'express';
import { verifyAdminToken, getAdminById } from '../modules/admin/adminAuthService';

/**
 * Admin JWT Payloadï¼ˆä¸ adminAuthService ä¿æŒä¸€è‡´ï¼‰
 */
interface AdminJwtPayload {
  adminId: string;
  username: string;
  role: 'super_admin' | 'admin';
  type: 'admin';
}

/**
 * æ‰©å±• Express Requestï¼Œæ·»åŠ  admin å­—æ®µ
 */
declare global {
  namespace Express {
    interface Request {
      admin?: AdminJwtPayload;
    }
  }
}

/**
 * Admin è®¤è¯ä¸­é—´ä»¶
 * 
 * éªŒè¯è¯·æ±‚å¤´ä¸­çš„ Authorization: Bearer <token>
 * å°† Admin ä¿¡æ¯æ³¨å…¥ req.admin
 */
export async function requireAdminAuth(
  req: Request,
  res: Response,
  next: NextFunction
): Promise<void> {
  try {
    // 1. è·å– Token
    const authHeader = req.headers.authorization;
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      res.status(401).json({
        success: false,
        error: {
          code: 'ADMIN_AUTH_REQUIRED',
          message: 'Admin è®¤è¯å¤±è´¥ï¼Œè¯·æä¾›æœ‰æ•ˆçš„ Token',
        },
      });
      return;
    }

    const token = authHeader.substring(7); // å»æ‰ "Bearer "

    // 2. éªŒè¯ Token
    const decoded = verifyAdminToken(token);

    // 3. æ£€æŸ¥ Admin æ˜¯å¦ä»ç„¶æœ‰æ•ˆ
    const admin = await getAdminById(decoded.adminId);
    if (!admin) {
      res.status(401).json({
        success: false,
        error: {
          code: 'ADMIN_NOT_FOUND',
          message: 'Admin ç”¨æˆ·ä¸å­˜åœ¨æˆ–å·²è¢«ç¦ç”¨',
        },
      });
      return;
    }

    // 4. æ³¨å…¥ req.admin
    req.admin = decoded;

    next();
  } catch (error: any) {
    if (error.message === 'ADMIN_TOKEN_EXPIRED') {
      res.status(401).json({
        success: false,
        error: {
          code: 'ADMIN_TOKEN_EXPIRED',
          message: 'Admin Token å·²è¿‡æœŸï¼Œè¯·é‡æ–°ç™»å½•',
        },
      });
      return;
    }

    res.status(401).json({
      success: false,
      error: {
        code: 'INVALID_ADMIN_TOKEN',
        message: 'Admin Token æ— æ•ˆ',
      },
    });
  }
}

/**
 * Super Admin æƒé™æ£€æŸ¥ä¸­é—´ä»¶
 * 
 * å¿…é¡»åœ¨ requireAdminAuth ä¹‹åä½¿ç”¨
 */
export function requireSuperAdmin(
  req: Request,
  res: Response,
  next: NextFunction
): void {
  if (!req.admin) {
    res.status(401).json({
      success: false,
      error: {
        code: 'ADMIN_AUTH_REQUIRED',
        message: 'Admin è®¤è¯å¤±è´¥',
      },
    });
    return;
  }

  if (req.admin.role !== 'super_admin') {
    res.status(403).json({
      success: false,
      error: {
        code: 'INSUFFICIENT_PERMISSIONS',
        message: 'æƒé™ä¸è¶³ï¼Œéœ€è¦ Super Admin æƒé™',
      },
    });
    return;
  }

  next();
}



// å¯¼å‡ºåˆ«åï¼Œå…¼å®¹æ—§çš„å¯¼å…¥åç§°
export const adminAuthMiddleware = requireAdminAuth;
```

**å®‰å…¨è§‚å¯Ÿç‚¹ï¼š**
- âœ… åŒé‡éªŒè¯ï¼ˆToken + æ•°æ®åº“æŸ¥è¯¢ï¼‰
- âœ… æƒé™åˆ†çº§ï¼ˆsuper_admin / adminï¼‰
- âš ï¸ **æ¯æ¬¡è¯·æ±‚éƒ½æŸ¥è¯¢æ•°æ®åº“**ï¼ˆå¯èƒ½å½±å“æ€§èƒ½ï¼Œå»ºè®®ç¼“å­˜ï¼‰

### 3. é™æµä¸­é—´ä»¶ (`core/src/middleware/rateLimit.ts`)

```1:210:core/src/middleware/rateLimit.ts
/**
 * é™æµä¸­é—´ä»¶
 * 
 * åŠŸèƒ½ï¼š
 * - æ”¯æŒåŠ¨æ€å¼€å…³ï¼ˆé€šè¿‡ Admin é…ç½®ï¼‰
 * - Pro ç”¨æˆ·è‡ªåŠ¨è·³è¿‡é™æµ
 * - é Pro ç”¨æˆ·æŒ‰æ—¥é™æµ
 * - å‹å¥½çš„é”™è¯¯æç¤º
 */

import { Request, Response, NextFunction } from 'express';
import { getPool } from '../database/connection';
import { checkProStatus } from './requirePro';
import { isRateLimitEnabled, getRateLimitConfig } from '../services/systemConfigService';
import { ApiResponse } from '../types';

type ApiType = 'bazi_compute' | 'chat';

/**
 * åˆ›å»ºé™æµä¸­é—´ä»¶
 */
export function createRateLimitMiddleware(apiType: ApiType) {
  return async (req: Request, res: Response, next: NextFunction): Promise<void> => {
    try {
      const userId = req.userId;

      // 1. ç¡®ä¿ç”¨æˆ·å·²è®¤è¯
      if (!userId) {
        res.status(401).json({
          success: false,
          error: {
            code: 'AUTH_REQUIRED',
            message: 'è¯·å…ˆç™»å½•',
          },
        } as ApiResponse);
        return;
      }

      // 2. æ£€æŸ¥ç³»ç»Ÿé…ç½®ï¼šé™æµæ˜¯å¦å¯ç”¨
      const enabled = await isRateLimitEnabled(apiType);
      if (!enabled) {
        // é™æµå·²å…³é—­ï¼Œç›´æ¥é€šè¿‡
        return next();
      }

      // 3. æŸ¥è¯¢ç”¨æˆ·ä¿¡æ¯ï¼ˆåŒ…æ‹¬ Pro çŠ¶æ€ï¼‰
      const pool = getPool();
      const [userRows]: any = await pool.query(
        'SELECT is_pro, pro_expires_at, pro_plan FROM users WHERE user_id = ?',
        [userId]
      );

      if (userRows.length === 0) {
        res.status(404).json({
          success: false,
          error: {
            code: 'USER_NOT_FOUND',
            message: 'ç”¨æˆ·ä¸å­˜åœ¨',
          },
        } as ApiResponse);
        return;
      }

      const user = userRows[0];

      // 4. æ£€æŸ¥ Pro çŠ¶æ€
      const isPro = checkProStatus(user.is_pro, user.pro_expires_at, user.pro_plan);
      if (isPro) {
        // Pro ç”¨æˆ·å…é™æµ
        return next();
      }

      // 5. é Pro ç”¨æˆ·ï¼šæ£€æŸ¥é™æµ
      const today = new Date().toISOString().split('T')[0]; // YYYY-MM-DD
      const limitConfig = await getRateLimitConfig();

      // è·å–ä»Šæ—¥å·²ä½¿ç”¨æ¬¡æ•°
      const [limitRows]: any = await pool.query(
        `SELECT count FROM rate_limits 
         WHERE user_id = ? AND api_type = ? AND date = ?`,
        [userId, apiType, today]
      );

      const currentCount = limitRows.length > 0 ? limitRows[0].count : 0;

      // è·å–é™åˆ¶æ¬¡æ•°
      const dailyLimit =
        apiType === 'bazi_compute'
          ? limitConfig.baziComputeDailyLimit
          : limitConfig.chatDailyLimit;

      // æ£€æŸ¥æ˜¯å¦è¶…é™
      if (currentCount >= dailyLimit) {
        const featureName = apiType === 'bazi_compute' ? 'æ’ç›˜' : 'å¯¹è¯';
        res.status(429).json({
          success: false,
          error: {
            code: 'RATE_LIMIT_EXCEEDED',
            message: `ä»Šæ—¥${featureName}æ¬¡æ•°å·²è¾¾ä¸Šé™ï¼ˆ${dailyLimit}æ¬¡ï¼‰ï¼Œå‡çº§ Pro å¯äº«å—æ— é™åˆ¶`,
            details: {
              apiType,
              limit: dailyLimit,
              used: currentCount,
              remaining: 0,
              resetAt: new Date(new Date(today).getTime() + 24 * 60 * 60 * 1000).toISOString(),
              upgradeUrl: '/pro/subscribe',
            },
          },
        } as ApiResponse);
        return;
      }

      // 6. è®¡æ•° +1
      await pool.query(
        `INSERT INTO rate_limits (limit_id, user_id, api_type, date, count, created_at, updated_at)
         VALUES (UUID(), ?, ?, ?, 1, NOW(), NOW())
         ON DUPLICATE KEY UPDATE
           count = count + 1,
           updated_at = NOW()`,
        [userId, apiType, today]
      );

      // 7. æ·»åŠ é™æµä¿¡æ¯åˆ°å“åº”å¤´ï¼ˆå¯é€‰ï¼‰
      res.setHeader('X-RateLimit-Limit', dailyLimit.toString());
      res.setHeader('X-RateLimit-Remaining', (dailyLimit - currentCount - 1).toString());
      res.setHeader('X-RateLimit-Reset', new Date(new Date(today).getTime() + 24 * 60 * 60 * 1000).toISOString());

      next();
    } catch (error: any) {
      console.error('[RateLimit] Error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'INTERNAL_ERROR',
          message: 'æœåŠ¡å™¨å†…éƒ¨é”™è¯¯',
        },
      } as ApiResponse);
    }
  };
}

/**
 * è·å–ç”¨æˆ·å½“å‰é™æµçŠ¶æ€ï¼ˆå·¥å…·å‡½æ•°ï¼‰
 */
export async function getRateLimitStatus(
  userId: string,
  apiType: ApiType
): Promise<{
  limit: number;
  used: number;
  remaining: number;
  resetAt: string;
  isPro: boolean;
}> {
  const pool = getPool();

  // 1. æ£€æŸ¥ Pro çŠ¶æ€
  const [userRows]: any = await pool.query(
    'SELECT is_pro, pro_expires_at, pro_plan FROM users WHERE user_id = ?',
    [userId]
  );

  if (userRows.length === 0) {
    throw new Error('USER_NOT_FOUND');
  }

  const user = userRows[0];
  const isPro = checkProStatus(user.is_pro, user.pro_expires_at, user.pro_plan);

  const limitConfig = await getRateLimitConfig();
  const dailyLimit =
    apiType === 'bazi_compute'
      ? isPro
        ? limitConfig.baziComputeDailyLimitPro
        : limitConfig.baziComputeDailyLimit
      : isPro
      ? limitConfig.chatDailyLimitPro
      : limitConfig.chatDailyLimit;

  // 2. Pro ç”¨æˆ·è¿”å›æ— é™åˆ¶
  if (isPro) {
    return {
      limit: dailyLimit,
      used: 0,
      remaining: dailyLimit,
      resetAt: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString(),
      isPro: true,
    };
  }

  // 3. é Pro ç”¨æˆ·æŸ¥è¯¢ä»Šæ—¥ä½¿ç”¨æ¬¡æ•°
  const today = new Date().toISOString().split('T')[0];
  const [limitRows]: any = await pool.query(
    `SELECT count FROM rate_limits 
     WHERE user_id = ? AND api_type = ? AND date = ?`,
    [userId, apiType, today]
  );

  const used = limitRows.length > 0 ? limitRows[0].count : 0;

  return {
    limit: dailyLimit,
    used,
    remaining: Math.max(0, dailyLimit - used),
    resetAt: new Date(new Date(today).getTime() + 24 * 60 * 60 * 1000).toISOString(),
    isPro: false,
  };
}
```

**å®‰å…¨è§‚å¯Ÿç‚¹ï¼š**
- âœ… åŸºäºç”¨æˆ· ID çš„é™æµï¼ˆé˜²æ­¢å•ç”¨æˆ·æ»¥ç”¨ï¼‰
- âœ… Pro ç”¨æˆ·å…é™æµï¼ˆåˆç†çš„ä¸šåŠ¡é€»è¾‘ï¼‰
- âš ï¸ **é™æµåŸºäºæ—¥æœŸï¼Œå¯èƒ½è¢«æ—¶åŒºç»•è¿‡**ï¼ˆå»ºè®®ä½¿ç”¨ UTCï¼‰
- âš ï¸ **é™æµè®¡æ•°åœ¨æ•°æ®åº“ï¼Œé«˜å¹¶å‘å¯èƒ½æœ‰é—®é¢˜**ï¼ˆå»ºè®®ä½¿ç”¨ Redisï¼‰

---

## è·¯ç”±ä¸æ§åˆ¶å™¨

### 1. è®¤è¯è·¯ç”± (`core/src/routes/auth.ts`)

```1:233:core/src/routes/auth.ts
/**
 * è®¤è¯è·¯ç”±
 * 
 * è·¯å¾„ï¼š/api/v1/auth/*
 */

import { Router, Request, Response, NextFunction } from 'express';
import * as authService from '../modules/auth/authService';
import * as chartProfileService from '../services/chartProfileService';
import { ApiResponse } from '../types';
import { registerApi } from '../utils/apiDocs';

const router = Router();

// æ³¨å†Œ API æ–‡æ¡£
registerApi({
  method: 'POST',
  path: '/api/v1/auth/request-otp',
  description: 'è¯·æ±‚éªŒè¯ç ',
  auth: false,
  request: {
    body: {
      phone: 'æ‰‹æœºå·ï¼ˆCNåŒºåŸŸå¿…å¡«ï¼‰',
      email: 'é‚®ç®±ï¼ˆHKåŒºåŸŸå¿…å¡«ï¼‰',
      region: 'cn æˆ– hk',
    },
  },
  response: {
    success: { message: 'éªŒè¯ç å·²å‘é€' },
    error: ['INVALID_REGION', 'PHONE_REQUIRED', 'EMAIL_REQUIRED'],
  },
  example: `curl -X POST http://localhost:3000/api/v1/auth/request-otp \\
  -H "Content-Type: application/json" \\
  -d '{"phone":"13800138000","region":"cn"}'`,
});

registerApi({
  method: 'POST',
  path: '/api/v1/auth/login_or_register',
  description: 'ç™»å½•æˆ–æ³¨å†Œ',
  auth: false,
  request: {
    body: {
      phone: 'æ‰‹æœºå·',
      email: 'é‚®ç®±',
      code: 'éªŒè¯ç ',
      channel: 'cn æˆ– hk',
    },
  },
  response: {
    success: {
      token: 'JWT Token',
      user: { userId: 'string', nickname: 'string', /* ... */ },
    },
    error: ['CODE_REQUIRED', 'INVALID_CHANNEL', 'INVALID_OTP'],
  },
});

registerApi({
  method: 'GET',
  path: '/api/v1/auth/me',
  description: 'è·å–å½“å‰ç”¨æˆ·ä¿¡æ¯',
  auth: true,
  response: {
    success: { userId: 'string', nickname: 'string', /* ... */ },
    error: ['TOKEN_REQUIRED', 'INVALID_TOKEN'],
  },
});

registerApi({
  method: 'POST',
  path: '/api/v1/auth/logout',
  description: 'ç™»å‡º',
  auth: false,
  response: {
    success: { message: 'ç™»å‡ºæˆåŠŸ' },
  },
});

/**
 * POST /api/v1/auth/request-otp
 * è¯·æ±‚éªŒè¯ç 
 */
router.post('/request-otp', async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { phone, email, region } = req.body;
    
    // éªŒè¯è¾“å…¥
    if (!region || !['cn', 'hk'].includes(region)) {
      return res.status(400).json({
        success: false,
        error: {
          code: 'INVALID_REGION',
          message: 'region å¿…é¡»æ˜¯ cn æˆ– hk',
        },
      } as ApiResponse);
    }
    
    if (region === 'cn' && !phone) {
      return res.status(400).json({
        success: false,
        error: {
          code: 'PHONE_REQUIRED',
          message: 'CN åŒºåŸŸéœ€è¦æä¾›æ‰‹æœºå·',
        },
      } as ApiResponse);
    }
    
    if (region === 'hk' && !email) {
      return res.status(400).json({
        success: false,
        error: {
          code: 'EMAIL_REQUIRED',
          message: 'HK åŒºåŸŸéœ€è¦æä¾›é‚®ç®±',
        },
      } as ApiResponse);
    }
    
    const result = await authService.requestOTP({ phone, email, region });
    
    res.json({
      success: true,
      data: result,
    } as ApiResponse);
  } catch (error: any) {
    next(error);
  }
});

/**
 * POST /api/v1/auth/login_or_register
 * ç™»å½•æˆ–æ³¨å†Œ
 */
router.post('/login_or_register', async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { phone, email, code, channel } = req.body;
    
    // éªŒè¯è¾“å…¥
    if (!code) {
      return res.status(400).json({
        success: false,
        error: {
          code: 'CODE_REQUIRED',
          message: 'éªŒè¯ç ä¸èƒ½ä¸ºç©º',
        },
      } as ApiResponse);
    }
    
    if (!channel || !['cn', 'hk'].includes(channel)) {
      return res.status(400).json({
        success: false,
        error: {
          code: 'INVALID_CHANNEL',
          message: 'channel å¿…é¡»æ˜¯ cn æˆ– hk',
        },
      } as ApiResponse);
    }
    
    const result = await authService.loginOrRegister({ phone, email, code, channel });
    
    res.json({
      success: true,
      data: result,
    } as ApiResponse);
  } catch (error: any) {
    if (error.message === 'Invalid or expired verification code') {
      return res.status(400).json({
        success: false,
        error: {
          code: 'INVALID_OTP',
          message: 'éªŒè¯ç é”™è¯¯æˆ–å·²è¿‡æœŸ',
        },
      } as ApiResponse);
    }
    next(error);
  }
});

/**
 * GET /api/v1/auth/me
 * è·å–å½“å‰ç”¨æˆ·ä¿¡æ¯ï¼ˆå«å½“å‰å‘½ä¸»ï¼‰
 */
router.get('/me', async (req: Request, res: Response, next: NextFunction) => {
  try {
    const token = req.headers.authorization?.replace('Bearer ', '');
    
    if (!token) {
      return res.status(401).json({
        success: false,
        error: {
          code: 'TOKEN_REQUIRED',
          message: 'æœªæä¾›è®¤è¯ Token',
        },
      } as ApiResponse);
    }
    
    const user = await authService.getUserByToken(token);
    
    res.json({
      success: true,
      data: {
        ...user,
      },
    } as ApiResponse);
  } catch (error: any) {
    if (error.message === 'Invalid token') {
      return res.status(401).json({
        success: false,
        error: {
          code: 'INVALID_TOKEN',
          message: 'Token æ— æ•ˆæˆ–å·²è¿‡æœŸ',
        },
      } as ApiResponse);
    }
    next(error);
  }
});

/**
 * POST /api/v1/auth/logout
 * ç™»å‡ºï¼ˆå®¢æˆ·ç«¯æ¸…é™¤ Token å³å¯ï¼Œè¿™é‡Œåªæ˜¯å ä½ï¼‰
 */
router.post('/logout', async (req: Request, res: Response) => {
  res.json({
    success: true,
    data: {
      message: 'ç™»å‡ºæˆåŠŸ',
    },
  } as ApiResponse);
});

export default router;
```

**å®‰å…¨è§‚å¯Ÿç‚¹ï¼š**
- âœ… è¾“å…¥éªŒè¯ï¼ˆregionã€phoneã€emailï¼‰
- âš ï¸ **éªŒè¯ç æ¥å£æ— é™æµ**ï¼ˆå¯èƒ½è¢«æ»¥ç”¨å‘é€å¤§é‡éªŒè¯ç ï¼‰
- âš ï¸ **ç™»å‡ºæ¥å£æœªå®ç° Token é»‘åå•**ï¼ˆToken ä»å¯ä½¿ç”¨ç›´åˆ°è¿‡æœŸï¼‰

### 2. è®¤è¯æœåŠ¡ (`core/src/modules/auth/authService.ts`)

```1:214:core/src/modules/auth/authService.ts
/**
 * è®¤è¯æœåŠ¡
 * 
 * é‡è¦ï¼šæ‰€æœ‰å¯¹å¤–å“åº”å¿…é¡»ä½¿ç”¨ FieldMapperï¼Œç¦æ­¢æ‰‹æ“å­—æ®µæ˜ å°„
 * 
 * å‚è€ƒæ–‡æ¡£ï¼š
 * - app.doc/features/æ³¨å†Œç™»å½•è®¾è®¡æ–‡æ¡£.md
 */

import { v4 as uuidv4 } from 'uuid';
import bcrypt from 'bcryptjs';
import jwt from 'jsonwebtoken';
import { getPool } from '../../database/connection';
import { FieldMapper } from '../../utils/fieldMapper';
import { otpConfig, jwtConfig } from '../../config/auth';
import type { UserRow } from '../../types/database';
import type { UserDto, LoginResponseDto, RequestOtpResponseDto } from '../../types/dto';

const JWT_SECRET = process.env.XIAOPEI_JWT_SECRET || 'your-secret-key-change-me';
const JWT_EXPIRES_IN = `${jwtConfig.expiresInDays}d`;

/**
 * ç”ŸæˆéªŒè¯ç 
 * ä½¿ç”¨é…ç½®åŒ–çš„é•¿åº¦å’Œå­—ç¬¦é›†
 */
function generateCode(): string {
  const { length, charset } = otpConfig;
  let code = '';
  for (let i = 0; i < length; i++) {
    code += charset.charAt(Math.floor(Math.random() * charset.length));
  }
  return code;
}

/**
 * ç”Ÿæˆ JWT Token
 */
function generateToken(userId: string): string {
  return jwt.sign({ userId }, JWT_SECRET, { expiresIn: JWT_EXPIRES_IN });
}

/**
 * éªŒè¯ JWT Token
 */
export function verifyToken(token: string): { userId: string } {
  try {
    const decoded = jwt.verify(token, JWT_SECRET) as { userId: string };
    return decoded;
  } catch (error) {
    throw new Error('Invalid token');
  }
}

/**
 * è¯·æ±‚éªŒè¯ç 
 */
export async function requestOTP(params: {
  phone?: string;
  email?: string;
  region: 'cn' | 'hk';
}): Promise<RequestOtpResponseDto> {
  const { phone, email, region } = params;
  
  // éªŒè¯è¾“å…¥
  if (region === 'cn' && !phone) {
    throw new Error('CN region requires phone number');
  }
  if (region === 'hk' && !email) {
    throw new Error('HK region requires email');
  }
  
  const pool = getPool();
  
  // æ£€æŸ¥å‘é€é¢‘ç‡é™åˆ¶ï¼ˆä½¿ç”¨é…ç½®ï¼‰
  const { sendIntervalSeconds, dailyLimit, ttlMinutes } = otpConfig;
  
  // 1. æ£€æŸ¥æœ€è¿‘æ˜¯å¦å‘é€è¿‡éªŒè¯ç 
  const [recentCodes]: any = await pool.execute(
    `SELECT * FROM verification_codes 
     WHERE (phone = ? OR email = ?) 
       AND created_at > DATE_SUB(NOW(), INTERVAL ? SECOND)
     ORDER BY created_at DESC 
     LIMIT 1`,
    [phone || null, email || null, sendIntervalSeconds]
  );
  
  if (recentCodes.length > 0) {
    const elapsed = Math.floor((Date.now() - new Date(recentCodes[0].created_at).getTime()) / 1000);
    const retryAfter = sendIntervalSeconds - elapsed;
    throw new Error(`è¯·ç­‰å¾… ${retryAfter} ç§’åé‡è¯•`);
  }
  
  // 2. æ£€æŸ¥æ¯æ—¥å‘é€æ¬¡æ•°
  const [dailyCodes]: any = await pool.execute(
    `SELECT COUNT(*) as count FROM verification_codes 
     WHERE (phone = ? OR email = ?) 
       AND created_at > DATE_SUB(NOW(), INTERVAL 1 DAY)`,
    [phone || null, email || null]
  );
  
  if (dailyCodes[0].count >= dailyLimit) {
    throw new Error(`æ¯æ—¥éªŒè¯ç å‘é€æ¬¡æ•°å·²è¾¾ä¸Šé™ï¼ˆ${dailyLimit}æ¬¡ï¼‰`);
  }
  
  // 3. ç”Ÿæˆå¹¶ä¿å­˜éªŒè¯ç 
  const code = generateCode();
  const codeId = uuidv4();
  const expiresAt = new Date(Date.now() + ttlMinutes * 60 * 1000);
  
  await pool.execute(
    `INSERT INTO verification_codes (code_id, phone, email, code, code_type, expires_at) 
     VALUES (?, ?, ?, ?, 'login', ?)`,
    [codeId, phone || null, email || null, code, expiresAt]
  );
  
  // TODO: å‘é€éªŒè¯ç ï¼ˆçŸ­ä¿¡/é‚®ä»¶ï¼‰
  console.log(`[Auth] Verification code: ${code} (${phone || email})`);
  
  return {
    message: 'éªŒè¯ç å·²å‘é€',
  };
}

/**
 * ç™»å½•æˆ–æ³¨å†Œ
 */
export async function loginOrRegister(params: {
  phone?: string;
  email?: string;
  code: string;
  channel: 'cn' | 'hk';
}): Promise<LoginResponseDto> {
  const { phone, email, code, channel } = params;
  
  const pool = getPool();
  
  // 1. éªŒè¯éªŒè¯ç 
  // âœ… å›ºå®šéªŒè¯ç ï¼š123456ï¼ˆå› ä¸ºæœªæ¥å…¥çŸ­ä¿¡æœåŠ¡å•†ï¼‰
  // åç»­æ¥å…¥çœŸå®çŸ­ä¿¡æœåŠ¡åï¼Œæ”¹ä¸ºæŸ¥è¯¢æ•°æ®åº“éªŒè¯
  if (code !== '123456') {
    throw new Error('éªŒè¯ç é”™è¯¯ï¼ˆé»˜è®¤éªŒè¯ç ï¼š123456ï¼‰');
  }
  console.log('[Auth] éªŒè¯ç æ ¡éªŒé€šè¿‡ï¼ˆå›ºå®šéªŒè¯ç ï¼š123456ï¼‰');
  
  // 3. æŸ¥æ‰¾æˆ–åˆ›å»ºç”¨æˆ·
  const [userRows]: any = await pool.execute(
    `SELECT * FROM users WHERE phone = ? OR email = ?`,
    [phone || null, email || null]
  );
  
  let userRow: UserRow;
  
  if (userRows.length > 0) {
    // ç”¨æˆ·å·²å­˜åœ¨ï¼šç™»å½•
    userRow = userRows[0];
  } else {
    // ç”¨æˆ·ä¸å­˜åœ¨ï¼šæ³¨å†Œ
    const userId = uuidv4();
    const nickname = phone ? `ç”¨æˆ·${phone.slice(-4)}` : `ç”¨æˆ·${email?.split('@')[0]}`;
    
    await pool.execute(
      `INSERT INTO users (user_id, nickname, phone, email, app_region, is_pro) 
       VALUES (?, ?, ?, ?, ?, FALSE)`,
      [userId, nickname, phone || null, email || null, channel.toUpperCase()]
    );
    
    // é‡æ–°æŸ¥è¯¢ç”¨æˆ·ä¿¡æ¯
    const [newUserRows]: any = await pool.execute(
      `SELECT * FROM users WHERE user_id = ?`,
      [userId]
    );
    userRow = newUserRows[0];
    
    // åˆ›å»ºç”¨æˆ·è®¾ç½®
    await pool.execute(
      `INSERT INTO user_settings (setting_id, user_id, language) 
       VALUES (?, ?, ?)`,
      [uuidv4(), userId, channel === 'cn' ? 'zh-CN' : 'zh-HK']
    );
  }
  
  // 4. ç”Ÿæˆ JWT Token
  const token = generateToken(userRow.user_id);
  
  // âœ… ä½¿ç”¨ FieldMapper è½¬æ¢ä¸º DTO
  const userDto = FieldMapper.mapUser(userRow);
  
  return {
    token,
    user: userDto,
  };
}

/**
 * é€šè¿‡ Token è·å–ç”¨æˆ·ä¿¡æ¯
 */
export async function getUserByToken(token: string): Promise<UserDto> {
  const { userId } = verifyToken(token);
  
  const pool = getPool();
  const [rows]: any = await pool.execute(
    `SELECT * FROM users WHERE user_id = ?`,
    [userId]
  );
  
  if (rows.length === 0) {
    throw new Error('User not found');
  }
  
  // âœ… ä½¿ç”¨ FieldMapper è½¬æ¢ä¸º DTO
  return FieldMapper.mapUser(rows[0] as UserRow);
}
```

**å®‰å…¨è§‚å¯Ÿç‚¹ï¼š**
- ğŸ”´ **JWT_SECRET ä½¿ç”¨é»˜è®¤å€¼**ï¼ˆ`'your-secret-key-change-me'`ï¼‰ï¼Œç”Ÿäº§ç¯å¢ƒå¿…é¡»ä½¿ç”¨å¼ºå¯†é’¥
- ğŸ”´ **å›ºå®šéªŒè¯ç  `123456`**ï¼ˆä»…ç”¨äºå¼€å‘ï¼Œç”Ÿäº§ç¯å¢ƒå¿…é¡»æ¥å…¥çœŸå®çŸ­ä¿¡/é‚®ä»¶æœåŠ¡ï¼‰
- âœ… éªŒè¯ç æœ‰é¢‘ç‡é™åˆ¶å’Œæ¯æ—¥é™åˆ¶
- âš ï¸ **éªŒè¯ç åœ¨æ§åˆ¶å°æ‰“å°**ï¼ˆç”Ÿäº§ç¯å¢ƒéœ€ç§»é™¤ï¼‰

### 3. Pro è®¢é˜…è·¯ç”± (`core/src/routes/pro.ts`)

```1:234:core/src/routes/pro.ts
/**
 * Pro è®¢é˜…è·¯ç”±
 * 
 * è·¯å¾„ï¼š/api/v1/pro
 */

import { Router, Request, Response } from 'express';
import { requireAuth } from '../middleware/auth';
import { requirePro } from '../middleware/requirePro';
import {
  subscribe,
  getProStatus,
  getSubscriptionHistory,
} from '../modules/pro/proService';
import { registerApi } from '../utils/apiDocs';

const router = Router();

// æ‰€æœ‰è·¯ç”±éƒ½éœ€è¦ç”¨æˆ·è®¤è¯
router.use(requireAuth);

/**
 * GET /api/v1/pro/status
 * è·å–å½“å‰ç”¨æˆ·çš„ Pro çŠ¶æ€
 */
router.get('/status', async (req: Request, res: Response) => {
  try {
    const userId = req.user!.userId;

    const status = await getProStatus(userId);

    res.json({
      success: true,
      data: status,
    });
  } catch (error: any) {
    if (error.message === 'USER_NOT_FOUND') {
      res.status(404).json({
        success: false,
        error: {
          code: 'USER_NOT_FOUND',
          message: 'ç”¨æˆ·ä¸å­˜åœ¨',
        },
      });
      return;
    }

    console.error('[Pro] Get status error:', error);
    res.status(500).json({
      success: false,
      error: {
        code: 'INTERNAL_ERROR',
        message: 'æœåŠ¡å™¨å†…éƒ¨é”™è¯¯',
      },
    });
  }
});

/**
 * POST /api/v1/pro/subscribe
 * è®¢é˜… Proï¼ˆæ¨¡æ‹Ÿæ¥å£ï¼‰
 */
router.post('/subscribe', async (req: Request, res: Response) => {
  try {
    const userId = req.user!.userId;
    const { plan } = req.body;

    if (!plan || !['yearly', 'monthly', 'lifetime'].includes(plan)) {
      res.status(400).json({
        success: false,
        error: {
          code: 'INVALID_PLAN',
          message: 'plan å¿…é¡»æ˜¯ yearlyã€monthly æˆ– lifetime',
        },
      });
      return;
    }

    const result = await subscribe(userId, plan);

    res.json({
      success: true,
      data: result,
    });
  } catch (error: any) {
    if (error.message === 'USER_NOT_FOUND') {
      res.status(404).json({
        success: false,
        error: {
          code: 'USER_NOT_FOUND',
          message: 'ç”¨æˆ·ä¸å­˜åœ¨',
        },
      });
      return;
    }

    console.error('[Pro] Subscribe error:', error);
    res.status(500).json({
      success: false,
      error: {
        code: 'INTERNAL_ERROR',
        message: 'æœåŠ¡å™¨å†…éƒ¨é”™è¯¯',
      },
    });
  }
});

/**
 * GET /api/v1/pro/subscriptions
 * è·å–è®¢é˜…å†å²
 */
router.get('/subscriptions', async (req: Request, res: Response) => {
  try {
    const userId = req.user!.userId;

    const subscriptions = await getSubscriptionHistory(userId);

    res.json({
      success: true,
      data: subscriptions,
    });
  } catch (error: any) {
    console.error('[Pro] Get subscriptions error:', error);
    res.status(500).json({
      success: false,
      error: {
        code: 'INTERNAL_ERROR',
        message: 'æœåŠ¡å™¨å†…éƒ¨é”™è¯¯',
      },
    });
  }
});

/**
 * GET /api/v1/pro/features (ç¤ºä¾‹ï¼šPro ä¸“å±åŠŸèƒ½)
 * 
 * æ­¤æ¥å£éœ€è¦ Pro æƒé™
 */
router.get('/features', requirePro, async (req: Request, res: Response) => {
  try {
    res.json({
      success: true,
      data: {
        message: 'è¿™æ˜¯ Pro ä¸“å±åŠŸèƒ½',
        features: [
          'æ— é™æ¬¡æ•°æ’ç›˜',
          'æ— é™æ¬¡æ•°å¯¹è¯',
          'æ·±åº¦è§£è¯»ï¼ˆDeepSeek Thinking æ¨¡å¼ï¼‰',
          'é«˜çº§åˆ†ææŠ¥å‘Š',
          'ä¼˜å…ˆå®¢æœæ”¯æŒ',
        ],
      },
    });
  } catch (error: any) {
    console.error('[Pro] Get features error:', error);
    res.status(500).json({
      success: false,
      error: {
        code: 'INTERNAL_ERROR',
        message: 'æœåŠ¡å™¨å†…éƒ¨é”™è¯¯',
      },
    });
  }
});

// ===== API æ–‡æ¡£æ³¨å†Œ =====

registerApi({
  method: 'GET',
  path: '/api/v1/pro/status',
  description: 'è·å–å½“å‰ç”¨æˆ·çš„ Pro çŠ¶æ€',
  auth: true,
  response: {
    success: {
      isPro: 'boolean',
      expiresAt: 'string (ISO 8601ï¼Œå¯é€‰)',
      plan: 'yearly | monthly | lifetime (å¯é€‰)',
      features: 'string[]',
    },
    error: ['USER_NOT_FOUND'],
  },
  tags: ['Pro'],
});

registerApi({
  method: 'POST',
  path: '/api/v1/pro/subscribe',
  description: 'è®¢é˜… Proï¼ˆæ¨¡æ‹Ÿæ¥å£ï¼Œæ— çœŸå®æ”¯ä»˜ï¼‰',
  auth: true,
  request: {
    body: {
      plan: 'yearly | monthly | lifetime (å¿…å¡«)',
    },
  },
  response: {
    success: {
      subscription: 'SubscriptionDto',
      user: '{ isPro, proExpiresAt, proPlan }',
    },
    error: ['INVALID_PLAN', 'USER_NOT_FOUND'],
  },
  tags: ['Pro'],
});

registerApi({
  method: 'GET',
  path: '/api/v1/pro/subscriptions',
  description: 'è·å–è®¢é˜…å†å²',
  auth: true,
  response: {
    success: {
      subscriptions: 'SubscriptionDto[]',
    },
  },
  tags: ['Pro'],
});

registerApi({
  method: 'GET',
  path: '/api/v1/pro/features',
  description: 'Pro ä¸“å±åŠŸèƒ½ï¼ˆç¤ºä¾‹æ¥å£ï¼Œéœ€è¦ Pro æƒé™ï¼‰',
  auth: true,
  response: {
    success: {
      message: 'string',
      features: 'string[]',
    },
    error: ['PRO_REQUIRED'],
  },
  tags: ['Pro'],
});

export default router;
```

**å®‰å…¨è§‚å¯Ÿç‚¹ï¼š**
- âœ… æ‰€æœ‰è·¯ç”±éƒ½éœ€è¦è®¤è¯
- âœ… Pro åŠŸèƒ½ä½¿ç”¨ `requirePro` ä¸­é—´ä»¶ä¿æŠ¤
- âš ï¸ **è®¢é˜…æ¥å£æ— æ”¯ä»˜éªŒè¯**ï¼ˆå½“å‰ä¸ºæ¨¡æ‹Ÿï¼Œç”Ÿäº§ç¯å¢ƒéœ€æ¥å…¥çœŸå®æ”¯ä»˜ï¼‰

### 4. Admin è·¯ç”± (`core/src/routes/admin/users.ts`)

```1:277:core/src/routes/admin/users.ts
/**
 * Admin ç”¨æˆ·ç®¡ç†è·¯ç”±
 * 
 * è·¯å¾„ï¼š/api/admin/v1/users
 */

import { Router, Request, Response } from 'express';
import { requireAdminAuth, requireSuperAdmin } from '../../middleware/adminAuth';
import {
  getUserList,
  getUserDetail,
  createTestUser,
  getOrCreateCursorTestAccount,
  resetCursorTestAccountPassword,
} from '../../modules/admin/adminUserService';
import { registerApi } from '../../utils/apiDocs';

const router = Router();

// æ‰€æœ‰è·¯ç”±éƒ½éœ€è¦ Admin è®¤è¯
router.use(requireAdminAuth);

/**
 * GET /api/admin/v1/users
 * è·å– C ç«¯ç”¨æˆ·åˆ—è¡¨
 */
router.get('/', async (req: Request, res: Response) => {
  try {
    const page = parseInt(req.query.page as string) || 1;
    const pageSize = parseInt(req.query.pageSize as string) || 20;
    const keyword = req.query.keyword as string | undefined;

    const result = await getUserList(page, pageSize, keyword);

    res.json({
      success: true,
      data: result,
    });
  } catch (error: any) {
    console.error('[Admin Users] Get list error:', error);
    res.status(500).json({
      success: false,
      error: {
        code: 'INTERNAL_ERROR',
        message: 'æœåŠ¡å™¨å†…éƒ¨é”™è¯¯',
      },
    });
  }
});

/**
 * GET /api/admin/v1/users/:userId
 * è·å–ç”¨æˆ·è¯¦æƒ…
 */
router.get('/:userId', async (req: Request, res: Response) => {
  try {
    const { userId } = req.params;

    const result = await getUserDetail(userId);

    res.json({
      success: true,
      data: result,
    });
  } catch (error: any) {
    if (error.message === 'USER_NOT_FOUND') {
      res.status(404).json({
        success: false,
        error: {
          code: 'USER_NOT_FOUND',
          message: 'ç”¨æˆ·ä¸å­˜åœ¨',
        },
      });
      return;
    }

    console.error('[Admin Users] Get detail error:', error);
    res.status(500).json({
      success: false,
      error: {
        code: 'INTERNAL_ERROR',
        message: 'æœåŠ¡å™¨å†…éƒ¨é”™è¯¯',
      },
    });
  }
});

/**
 * POST /api/admin/v1/users/test
 * åˆ›å»ºæµ‹è¯•ç”¨æˆ·
 */
router.post('/test', async (req: Request, res: Response) => {
  try {
    const result = await createTestUser(req.body);

    res.json({
      success: true,
      data: result,
    });
  } catch (error: any) {
    if (error.message === 'PHONE_EXISTS' || error.message === 'EMAIL_EXISTS') {
      res.status(400).json({
        success: false,
        error: {
          code: error.message,
          message: 'æ‰‹æœºå·æˆ–é‚®ç®±å·²å­˜åœ¨',
        },
      });
      return;
    }

    console.error('[Admin Users] Create test user error:', error);
    res.status(500).json({
      success: false,
      error: {
        code: 'INTERNAL_ERROR',
        message: 'æœåŠ¡å™¨å†…éƒ¨é”™è¯¯',
      },
    });
  }
});

/**
 * GET /api/admin/v1/users/cursor/test-account
 * è·å–æˆ–åˆ›å»º Cursor æµ‹è¯•è´¦å·
 */
router.get('/cursor/test-account', async (req: Request, res: Response) => {
  try {
    const isProduction = process.env.NODE_ENV === 'production';
    const result = await getOrCreateCursorTestAccount(isProduction);

    res.json({
      success: true,
      data: result,
    });
  } catch (error: any) {
    console.error('[Admin Users] Get cursor test account error:', error);
    res.status(500).json({
      success: false,
      error: {
        code: 'INTERNAL_ERROR',
        message: 'æœåŠ¡å™¨å†…éƒ¨é”™è¯¯',
      },
    });
  }
});

/**
 * POST /api/admin/v1/users/cursor/reset-password
 * é‡ç½® Cursor æµ‹è¯•è´¦å·å¯†ç ï¼ˆä»… super_adminï¼‰
 */
router.post('/cursor/reset-password', requireSuperAdmin, async (req: Request, res: Response) => {
  try {
    const isProduction = process.env.NODE_ENV === 'production';
    const result = await resetCursorTestAccountPassword(isProduction);

    res.json({
      success: true,
      data: result,
    });
  } catch (error: any) {
    if (error.message === 'CURSOR_TEST_ACCOUNT_NOT_FOUND') {
      res.status(404).json({
        success: false,
        error: {
          code: 'CURSOR_TEST_ACCOUNT_NOT_FOUND',
          message: 'Cursor æµ‹è¯•è´¦å·ä¸å­˜åœ¨',
        },
      });
      return;
    }

    console.error('[Admin Users] Reset cursor password error:', error);
    res.status(500).json({
      success: false,
      error: {
        code: 'INTERNAL_ERROR',
        message: 'æœåŠ¡å™¨å†…éƒ¨é”™è¯¯',
      },
    });
  }
});

// ===== API æ–‡æ¡£æ³¨å†Œ =====

registerApi({
  method: 'GET',
  path: '/api/admin/v1/users',
  description: 'è·å– C ç«¯ç”¨æˆ·åˆ—è¡¨ï¼ˆåˆ†é¡µï¼‰',
  auth: true,
  request: {
    query: {
      page: 'number (é¡µç ï¼Œé»˜è®¤ 1)',
      pageSize: 'number (æ¯é¡µæ•°é‡ï¼Œé»˜è®¤ 20)',
      keyword: 'string (æœç´¢å…³é”®è¯ï¼Œå¯é€‰)',
    },
  },
  response: {
    success: {
      items: 'UserDto[]',
      total: 'number',
      page: 'number',
      pageSize: 'number',
    },
  },
  tags: ['Admin', 'Users'],
});

registerApi({
  method: 'GET',
  path: '/api/admin/v1/users/:userId',
  description: 'è·å–ç”¨æˆ·è¯¦æƒ…',
  auth: true,
  request: {
    params: {
      userId: 'string (ç”¨æˆ· ID)',
    },
  },
  response: {
    success: {
      user: 'UserDto',
      charts: 'ChartProfileDto[]',
      stats: 'object',
    },
    error: ['USER_NOT_FOUND'],
  },
  tags: ['Admin', 'Users'],
});

registerApi({
  method: 'POST',
  path: '/api/admin/v1/users/test',
  description: 'åˆ›å»ºæµ‹è¯•ç”¨æˆ·',
  auth: true,
  request: {
    body: {
      phone: 'string (å¯é€‰)',
      email: 'string (å¯é€‰)',
      password: 'string (å¿…å¡«)',
      nickname: 'string (å¯é€‰)',
      appRegion: 'CN | HK (å¿…å¡«)',
      isPro: 'boolean (å¯é€‰)',
    },
  },
  response: {
    success: { user: 'UserDto' },
    error: ['PHONE_EXISTS', 'EMAIL_EXISTS'],
  },
  tags: ['Admin', 'Users'],
});

registerApi({
  method: 'GET',
  path: '/api/admin/v1/users/cursor/test-account',
  description: 'è·å–æˆ–åˆ›å»º Cursor æµ‹è¯•è´¦å·',
  auth: true,
  response: {
    success: { account: 'CursorTestAccountDto' },
  },
  tags: ['Admin', 'Users'],
});

registerApi({
  method: 'POST',
  path: '/api/admin/v1/users/cursor/reset-password',
  description: 'é‡ç½® Cursor æµ‹è¯•è´¦å·å¯†ç ï¼ˆä»… super_adminï¼‰',
  auth: true,
  response: {
    success: { password: 'string (æ–°å¯†ç )' },
    error: ['CURSOR_TEST_ACCOUNT_NOT_FOUND', 'INSUFFICIENT_PERMISSIONS'],
  },
  tags: ['Admin', 'Users'],
});

export default router;
```

**å®‰å…¨è§‚å¯Ÿç‚¹ï¼š**
- âœ… Admin è·¯ç”±éœ€è¦è®¤è¯
- âœ… æ•æ„Ÿæ“ä½œï¼ˆé‡ç½®å¯†ç ï¼‰éœ€è¦ `super_admin` æƒé™
- âš ï¸ **åˆ†é¡µå‚æ•°æœªé™åˆ¶æœ€å¤§å€¼**ï¼ˆå¯èƒ½è¢«æ»¥ç”¨å¯¼è‡´æ€§èƒ½é—®é¢˜ï¼‰

---

## ç¯å¢ƒå˜é‡é…ç½®

### å½“å‰ä½¿ç”¨çš„ç¯å¢ƒå˜é‡

æ ¹æ®ä»£ç åˆ†æï¼Œé¡¹ç›®ä½¿ç”¨ä»¥ä¸‹ç¯å¢ƒå˜é‡ï¼š

```typescript
// æœåŠ¡å™¨é…ç½®
XIAOPEI_CORE_PORT=3000

// æ•°æ®åº“é…ç½®
XIAOPEI_MYSQL_HOST=localhost
XIAOPEI_MYSQL_PORT=3306
XIAOPEI_MYSQL_USER=root
XIAOPEI_MYSQL_PASSWORD=***
XIAOPEI_MYSQL_DATABASE=xiaopei

// JWT é…ç½®
XIAOPEI_JWT_SECRET=***  // âš ï¸ å½“å‰æœ‰é»˜è®¤å€¼ï¼Œç”Ÿäº§ç¯å¢ƒå¿…é¡»è®¾ç½®

// CORS é…ç½®
ALLOWED_ORIGINS=http://localhost:19006,http://localhost:5173

// ç¯å¢ƒ
NODE_ENV=development|production
```

**å®‰å…¨è§‚å¯Ÿç‚¹ï¼š**
- âš ï¸ **æœªæ‰¾åˆ° `.env.example` æ–‡ä»¶**ï¼ˆå»ºè®®åˆ›å»ºï¼Œéšè—æ•æ„Ÿå€¼ï¼‰
- ğŸ”´ **JWT_SECRET æœ‰é»˜è®¤å€¼**ï¼ˆç”Ÿäº§ç¯å¢ƒå¿…é¡»ä½¿ç”¨å¼ºéšæœºå¯†é’¥ï¼‰
- âš ï¸ **æ•°æ®åº“å¯†ç å¯èƒ½ç¡¬ç¼–ç **ï¼ˆéœ€ç¡®è®¤æ˜¯å¦ä½¿ç”¨ç¯å¢ƒå˜é‡ï¼‰

---

## ç¬¬ä¸€éƒ¨åˆ†æ€»ç»“

### å·²å‘ç°çš„å®‰å…¨é—®é¢˜ï¼ˆé«˜ä¼˜å…ˆçº§ï¼‰

1. **JWT Secret ä½¿ç”¨é»˜è®¤å€¼**
   - ä½ç½®ï¼š`core/src/modules/auth/authService.ts:19`
   - é£é™©ï¼šToken å¯è¢«ä¼ªé€ 
   - å»ºè®®ï¼šç”Ÿäº§ç¯å¢ƒå¿…é¡»è®¾ç½®å¼ºéšæœºå¯†é’¥ï¼ˆè‡³å°‘ 32 å­—ç¬¦ï¼‰

2. **å›ºå®šéªŒè¯ç  `123456`**
   - ä½ç½®ï¼š`core/src/modules/auth/authService.ts:140`
   - é£é™©ï¼šä»»ä½•äººéƒ½å¯ä»¥ç™»å½•
   - å»ºè®®ï¼šç”Ÿäº§ç¯å¢ƒå¿…é¡»æ¥å…¥çœŸå®çŸ­ä¿¡/é‚®ä»¶æœåŠ¡

3. **å¼€å‘ç¯å¢ƒ CORS å®Œå…¨å¼€æ”¾**
   - ä½ç½®ï¼š`core/src/server.ts:31-34`
   - é£é™©ï¼šå¼€å‘ç¯å¢ƒå¯èƒ½è¢«æ»¥ç”¨
   - å»ºè®®ï¼šå³ä½¿å¼€å‘ç¯å¢ƒä¹Ÿåº”é™åˆ¶å…è®¸çš„ origin

4. **éªŒè¯ç åœ¨æ§åˆ¶å°æ‰“å°**
   - ä½ç½®ï¼š`core/src/modules/auth/authService.ts:117`
   - é£é™©ï¼šæ—¥å¿—æ³„éœ²æ•æ„Ÿä¿¡æ¯
   - å»ºè®®ï¼šç”Ÿäº§ç¯å¢ƒç§»é™¤æˆ–ä½¿ç”¨å®‰å…¨æ—¥å¿—

### ä¸­ä¼˜å…ˆçº§é—®é¢˜

5. **é™æµåŸºäºæ—¥æœŸï¼Œå¯èƒ½è¢«æ—¶åŒºç»•è¿‡**
6. **ç™»å‡ºæ¥å£æœªå®ç° Token é»‘åå•**
7. **éªŒè¯ç æ¥å£æ— é¢å¤–é™æµä¿æŠ¤**
8. **åˆ†é¡µå‚æ•°æœªé™åˆ¶æœ€å¤§å€¼**

---

**ç»§ç»­é˜…è¯»ï¼š** [å®‰å…¨æ€§è¯„ä¼°æŠ¥å‘Š-ç¬¬äºŒéƒ¨åˆ†.md](./å®‰å…¨æ€§è¯„ä¼°æŠ¥å‘Š-ç¬¬äºŒéƒ¨åˆ†.md)




