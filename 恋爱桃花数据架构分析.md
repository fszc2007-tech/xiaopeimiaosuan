# 恋爱桃花数据架构分析

## 当前架构流程

### 1. 数据存储阶段

```
用户创建命盘
  ↓
前端调用 POST /api/v1/bazi/compute
  ↓
后端 baziService.computeChart()
  ↓
调用 Engine.compute() 计算八字
  ↓
Engine 返回完整结果对象（400+ 字段）
  ↓
保存到数据库：
  - chart_profiles 表：基本信息（name, gender, birthday, ...）
  - bazi_charts 表：result_json = JSON.stringify(engineResult)
```

**关键点**：
- ✅ Engine 的所有计算结果都保存在 `bazi_charts.result_json` 中
- ✅ 命盘档案信息（包括 gender）保存在 `chart_profiles` 表中
- ✅ 两个表通过 `chart_profile_id` 关联

---

### 2. 数据读取阶段（当前实现）

```
用户点击「恋爱桃花」卡片
  ↓
前端调用 POST /api/v1/chat/conversations/:id/messages
  ↓
后端 conversation.ts 路由处理
  ↓
从数据库读取：
  SELECT result_json FROM bazi_charts WHERE chart_profile_id = ?
  ↓
JSON.parse(result_json) → chartResult
  ↓
调用 buildLoveChatContext(chartResult, userQuestion)
  ↓
提取数据构建 LoveChatContext
  ↓
替换 prompt 占位符
  ↓
调用 LLM
```

**问题所在**：
- ❌ `buildLoveChatContext` 只接收 `chartResult`（解析后的 JSON）
- ❌ 性别信息尝试从 `chartResult.profile.gender` 或 `chartResult.meta.gender` 获取
- ❌ 但 `result_json` 中可能没有 `profile` 字段（profile 在另一个表中）
- ❌ 需要同时查询 `chart_profiles` 表获取性别信息

---

## 架构设计分析

### 方案 A：当前方案（后端提取）

**优点**：
- ✅ 前端不需要知道数据结构细节
- ✅ 数据提取逻辑集中管理，便于维护
- ✅ 可以统一处理数据转换和格式化
- ✅ 前端无法直接访问数据库，安全性好

**缺点**：
- ❌ 每次调用都需要从数据库读取完整 JSON，然后提取
- ❌ 如果提取逻辑复杂，可能影响性能
- ❌ 需要同时查询多个表（`bazi_charts` + `chart_profiles`）

**适用场景**：
- 数据提取逻辑复杂，需要多次转换
- 需要根据业务逻辑动态构建数据结构
- 前端不需要直接访问原始数据

---

### 方案 B：前端直接读取（不推荐）

**流程**：
```
前端直接调用数据库 API
  ↓
获取 result_json
  ↓
前端 JSON.parse()
  ↓
前端提取数据
  ↓
构建 LoveChatContext
```

**缺点**：
- ❌ 前端需要知道所有数据结构细节
- ❌ 数据提取逻辑分散在前端，难以维护
- ❌ 前端直接访问数据库，安全性差
- ❌ 如果数据结构变化，需要同时修改前端和后端

**不推荐**：不符合前后端分离的最佳实践

---

### 方案 C：后端预构建（推荐优化）

**流程**：
```
用户创建命盘时
  ↓
Engine 计算完成
  ↓
保存 result_json 的同时
  ↓
预构建常用数据结构（如 LoveChatContext）
  ↓
保存到数据库的额外字段或单独的表
  ↓
使用时直接读取，无需提取
```

**优点**：
- ✅ 使用时直接读取，性能好
- ✅ 数据提取逻辑集中，便于维护
- ✅ 前端仍然不需要知道数据结构

**缺点**：
- ❌ 需要额外的存储空间
- ❌ 如果提取逻辑变化，需要重新构建所有数据
- ❌ 增加数据库复杂度

**适用场景**：
- 数据结构相对稳定
- 对性能要求高
- 存储空间充足

---

### 方案 D：后端 API 返回结构化数据（当前部分实现）

**流程**：
```
前端调用 GET /api/v1/bazi/charts/:id
  ↓
后端从数据库读取 result_json
  ↓
后端提取并转换数据
  ↓
返回结构化的 DTO（如 BaziChartDto）
  ↓
前端直接使用
```

**当前实现**：
- ✅ `getChartDetail` 已经实现了部分数据转换
- ✅ 返回 `BaziChartDto` 给前端
- ❌ 但恋爱专线没有使用这个 API，而是直接在 `conversation.ts` 中读取

**问题**：
- 恋爱专线应该复用 `getChartDetail` 的逻辑，而不是重复读取数据库

---

## 当前架构的问题

### 问题 1：数据读取重复

**当前**：
- `conversation.ts` 中直接查询 `bazi_charts` 表
- `getChartDetail` 也查询 `bazi_charts` 表
- 两个地方都有数据提取逻辑

**应该**：
- 恋爱专线应该复用 `getChartDetail` 或类似的服务
- 或者创建一个统一的数据提取服务

---

### 问题 2：性别信息获取错误

**当前**：
```typescript
// buildLoveChatContext 中
function extractGender(chartResult: any) {
  if (chartResult.profile?.gender) { ... }
  if (chartResult.meta?.gender) { ... }
  return 'unknown';
}
```

**问题**：
- `result_json` 中可能没有 `profile` 字段
- `meta.gender` 也可能不存在
- 性别信息在 `chart_profiles` 表中

**应该**：
```typescript
// conversation.ts 中，查询时同时获取性别
const [chartDataRows] = await pool.query(`
  SELECT 
    bc.result_json,
    cp.gender
  FROM bazi_charts bc
  JOIN chart_profiles cp ON bc.chart_profile_id = cp.chart_profile_id
  WHERE bc.chart_profile_id = ?
`, [chartId]);

const chartResult = JSON.parse(chartDataRows[0].result_json);
const gender = chartDataRows[0].gender;

// 传递给 buildLoveChatContext
const loveChatContext = buildLoveChatContext(chartResult, userQuestion, gender);
```

---

### 问题 3：数据提取逻辑位置不当

**当前**：
- `buildLoveChatContext` 在 `core/src/modules/love/loveContextBuilder.ts`
- 但它在 `conversation.ts` 中被调用
- 数据提取逻辑和路由逻辑混在一起

**应该**：
- 创建一个统一的命盘数据服务
- 所有数据提取逻辑都在服务中
- 路由只负责调用服务和组装响应

---

## 推荐的架构优化

### 方案：统一数据服务 + 复用现有逻辑

```
1. 创建 LoveDataService
   - buildLoveChatContext(chartId, userQuestion)
   - 内部调用 getChartDetail 获取结构化数据
   - 或者直接查询数据库，但统一管理

2. conversation.ts 中
   - 调用 LoveDataService.buildLoveChatContext()
   - 不再直接查询数据库和提取数据

3. 数据提取逻辑
   - 集中在 LoveDataService 中
   - 可以复用 getChartDetail 的逻辑
   - 或者独立实现，但统一管理
```

**优点**：
- ✅ 数据提取逻辑集中管理
- ✅ 可以复用现有代码
- ✅ 路由逻辑简洁
- ✅ 便于测试和维护

---

## 数据流对比

### 当前流程（有问题）

```
conversation.ts
  ↓
查询 bazi_charts.result_json
  ↓
JSON.parse()
  ↓
buildLoveChatContext(chartResult)
  ↓
尝试从 chartResult 中提取所有数据（包括 gender）
  ❌ 但 gender 不在 result_json 中
```

### 优化后的流程（推荐）

```
conversation.ts
  ↓
调用 LoveDataService.buildLoveChatContext(chartId, userQuestion)
  ↓
LoveDataService 内部：
  1. 查询 bazi_charts.result_json
  2. 查询 chart_profiles.gender（如果需要）
  3. JSON.parse(result_json)
  4. 提取所有数据
  5. 返回 LoveChatContext
  ↓
conversation.ts 使用返回的 LoveChatContext
```

---

## 总结

### 当前架构的合理性

1. **后端提取数据是合理的** ✅
   - 前端不应该直接访问数据库
   - 数据提取逻辑应该在后端统一管理

2. **但实现有问题** ❌
   - 性别信息应该从 `chart_profiles` 表查询，而不是从 `result_json` 中提取
   - 数据提取逻辑应该集中在一个服务中，而不是分散在路由中
   - 应该复用现有的 `getChartDetail` 逻辑，而不是重复实现

### 建议的优化方向

1. **创建统一的数据服务**
   - `LoveDataService.buildLoveChatContext(chartId, userQuestion)`
   - 内部处理所有数据查询和提取

2. **修复数据提取逻辑**
   - 从 `chart_profiles` 表查询性别信息
   - 修复字段名错误（`gan/zhi` → `stem/branch`）
   - 从 `annualBrief` 中提取流年信息

3. **复用现有代码**
   - 可以复用 `getChartDetail` 的部分逻辑
   - 或者创建一个通用的数据提取工具函数

---

## 回答你的问题

> "不是应该从数据库取值吗？core 的 engine 把八字信息给到数据库，前端从数据库调取数据 为什么现在还是走 core，我不太理解当前的逻辑"

**回答**：

1. **数据确实在数据库中** ✅
   - Engine 计算完成后，所有数据都保存在 `bazi_charts.result_json` 中
   - 命盘档案信息在 `chart_profiles` 表中

2. **前端不直接访问数据库** ✅
   - 这是正确的架构设计
   - 前端通过后端 API 获取数据

3. **后端从数据库读取，然后提取数据** ✅
   - 这是合理的，但实现有问题
   - 当前在 `conversation.ts` 中直接查询数据库
   - 然后调用 `buildLoveChatContext` 提取数据

4. **问题在于** ❌
   - 数据提取逻辑不完整（字段名错误、路径错误）
   - 性别信息应该从 `chart_profiles` 表查询，而不是从 `result_json` 中提取
   - 应该创建一个统一的数据服务，而不是在路由中直接处理

**所以，架构是对的，但实现需要优化**。

