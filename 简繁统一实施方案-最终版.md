# 简繁统一实施方案（最终版）

**核心原则：坚决不碰用户输入，只统一系统输出为繁体**

---

## 📋 目录

1. [前提与规则](#前提与规则)
2. [整体策略](#整体策略)
3. [核心工具函数设计](#核心工具函数设计)
4. [LLM 输出处理](#llm-输出处理)
5. [前端 UI 文案处理](#前端-ui-文案处理)
6. [后端系统文本处理](#后端系统文本处理)
7. [用户输入禁区规则](#用户输入禁区规则)
8. [实施优先级](#实施优先级)
9. [技术选型](#技术选型)
10. [测试验证清单](#测试验证清单)
11. [紧急回滚策略](#紧急回滚策略)
12. [常见问题 FAQ](#常见问题-faq)
13. [总结](#总结)

---

## 一、前提与规则

### 1.1 技术前提

- ✅ 所有 LLM 调用都是**流式输出**（SSE/WebSocket）
- ✅ 可以在 Prompt 里要求 LLM 使用繁体
- ✅ 不希望大改后端流式实现，优先前端兜底
- ✅ 已有 i18n 基础设施（`zh-HK.ts` 语言包）

### 1.2 核心规则（必须严格遵守）

#### ✅ 用户输入：永远保持原样

- **不做简繁转换、不做术语替换**
- 展示、存储、传给后端/LLM，全部保持"原汁原味"
- 包括但不限于：
  - 用户在输入框里输入的内容
  - 聊天记录里的用户气泡
  - 用户问题、反馈、备注、搜索关键字
  - 用户自填标签、用户写的任何文本

#### ✅ 系统输出：统一繁体（zh-HK 风格）

- **UI 文案**：通过 i18n 语言包（`zh-HK.ts`）
- **LLM 回复**：Prompt 要求 + 前端兜底转换
- **后端生成字段**：标签、状态、卡片内容等
- **系统提示信息**：错误提示、加载状态等

> **结论：只动「系统产生的文本」，不动「用户产生的文本」。**

---

## 二、整体策略

### 2.1 一句话总结

> Prompt 让 LLM 尽量说繁体，前端 + 后端只对「系统文本」做 `normalizeToZhHK`，**对用户输入不做任何处理**。

### 2.2 三层防护架构

```
┌─────────────────────────────────────────┐
│  第一层：Prompt 约束（源头控制）         │
│  - 所有 Prompt 模板添加繁体输出要求      │
│  - 减少 LLM 输出简体字的概率            │
└─────────────────────────────────────────┘
              ↓
┌─────────────────────────────────────────┐
│  第二层：前端实时转换（流式兜底）        │
│  - 助手消息 chunk → normalizeToZhHK     │
│  - 用户消息 → 原样展示（不转换）         │
└─────────────────────────────────────────┘
              ↓
┌─────────────────────────────────────────┐
│  第三层：静态内容统一（i18n + 转换）     │
│  - UI 文案 → zh-HK.ts 语言包            │
│  - 后端字段 → normalizeToZhHK           │
└─────────────────────────────────────────┘
```

---

## 三、核心工具函数设计

### 3.1 `normalizeToZhHK` 统一函数

**位置**：`app/src/utils/normalizeText.ts`

```typescript
// utils/normalizeText.ts

import { Converter } from 'opencc-js';
import { toTraditional } from './shishenMapping';

// ⚠️ 重要：Converter 在模块顶层创建一次，不要每次调用都 new
const s2hk = Converter({ from: 'cn', to: 'hk' });

/**
 * 将系统产生的文本统一转换为繁体中文（香港用字风格）
 * 
 * ⚠️ 重要约束：
 * - 只能用于「系统文本」（LLM 输出、后端生成字段、系统提示等）
 * - 禁止在任何与用户输入有关的地方调用
 * - 凡是函数参数名包含 user/input/query/keyword 等字样的，默认视为用户输入，不得传入
 * 
 * @param text 系统产生的文本（可能是简体或繁体）
 * @returns 繁体中文（香港风格）
 */
export function normalizeToZhHK(text: string): string {
  if (!text || typeof text !== 'string') {
    return text || '';
  }
  
  // 第一步：简→繁（香港用字）
  const traditional = s2hk(text);
  
  // 第二步：命理术语/专业用字修正
  const normalized = applyDomainMapping(traditional);
  
  return normalized;
}
```

### 3.2 `applyDomainMapping` 领域映射

**作用**：修正通用转换库可能不准确的命理术语

**V1 实现**（明确、可执行）：

```typescript
/**
 * 命理術語 / 專業用字映射修正
 * 
 * V1：完全復用現有的 toTraditional 邏輯
 * 之後如果需要更多術語映射，再在這裡擴展
 * 
 * @param text 已經過 opencc 轉換的文本
 * @returns 經過領域映射修正的文本
 */
function applyDomainMapping(text: string): string {
  // V1：直接復用現有的 toTraditional 邏輯
  // 它已經處理了十神、格局、破格因素、救應因素等完整映射表
  return toTraditional(text);
}
```

**后续扩展说明**：

> 如果需要處理更多專業用字，可以在這裡增加 `domainMappings`，最終都掛在 `applyDomainMapping` 這一層，不要在其他地方單獨處理。

**与现有 `shishenMapping.ts` 的关系**：
- ✅ V1 直接复用 `toTraditional()`，立即生效
- ✅ 已有完整的映射表（十神、格局、破格因素、救应因素等）
- ✅ 未来扩展时，在 `applyDomainMapping` 中增加新的映射逻辑

---

## 四、LLM 输出处理

### 4.1 Prompt 层：要求繁体输出

**位置**：`core/src/modules/prompt/*.ts`

**统一添加段落**（所有 Prompt 模板）：

```typescript
// 在每个 Prompt 模板的适当位置（建议在开头或输出格式要求部分）添加：

【語言要求】

- 回覆請使用繁體中文（香港用字風格），避免出現簡體字。
- 八字與命理相關術語也請使用繁體，例如：正官、七殺、正財、偏印、命盤、流年等。
- 所有輸出內容（包括標題、正文、建議等）都必須使用繁體中文。

```

**需要修改的 Prompt 文件**：

- ✅ `promptTemplates.ts` - 系统提示词、通用解读、追问生成
- ✅ `love.ts` - 恋爱桃花专线（示例）
- ✅ `marriage.ts` - 婚姻专线（示例）
- ✅ 以及 `core/src/modules/prompt/` 目錄下所有專線 / 解讀相關的 Prompt 模板文件

**原则**：只要會喂給 LLM 的中文指令文本，都必須包含【語言要求】段落。

**实施方式**：
- 在每个 Prompt 的 `XIAOPEI_PROMPT_XXX` 常量开头或输出格式要求部分添加上述段落
- 保持占位符（如 `{{USER_QUESTION}}`）不变
- 保持 Prompt 逻辑结构不变

### 4.2 前端流式消费：只处理助手消息

**位置**：`app/src/screens/Chat/ChatScreen.tsx`

**当前实现**（第 316-324 行）：
```typescript
if (data.type === 'chunk') {
  // 更新消息内容
  assistantMessage.text += data.content;
  setMessages(prev => {
    const newMessages = [...prev];
    const lastIndex = newMessages.length - 1;
    newMessages[lastIndex] = { ...assistantMessage };
    return newMessages;
  });
}
```

**改造方案**：
```typescript
if (data.type === 'chunk') {
  // ⚠️ 关键：只对助手消息做转换，用户消息绝对不转换
  const normalizedContent = normalizeToZhHK(data.content);
  
  // 更新消息内容
  assistantMessage.text += normalizedContent;
  setMessages(prev => {
    const newMessages = [...prev];
    const lastIndex = newMessages.length - 1;
    newMessages[lastIndex] = { ...assistantMessage };
    return newMessages;
  });
}
```

**重要约束**：
- ✅ 只对 `role === 'assistant'` 的消息调用 `normalizeToZhHK`
- ✅ 用户消息（`role === 'user'`）绝对不转换，原样展示
- ✅ 消息模型必须明确区分 `role`，前端才能正确判断

### 4.3 历史消息加载：批量转换助手消息

**位置**：`app/src/screens/Chat/ChatScreen.tsx`（历史消息加载逻辑）

**改造方案**：
```typescript
// 加载历史消息后
const normalizedMessages = messages.map(msg => {
  if (msg.role === 'assistant') {
    return {
      ...msg,
      text: normalizeToZhHK(msg.text), // 只转换助手消息
    };
  }
  return msg; // 用户消息原样返回
});
```

### 4.4 追问建议：系统生成文本

**位置**：`app/src/screens/Chat/ChatScreen.tsx`（第 330-339 行）

**当前实现**：
```typescript
if (data.type === 'followups') {
  const followUpTexts = data.followups.map((item: any) => {
    return typeof item === 'string' ? item : (item.question || item);
  });
  // ...
}
```

**改造方案**：
```typescript
if (data.type === 'followups') {
  const followUpTexts = data.followups.map((item: any) => {
    const question = typeof item === 'string' ? item : (item.question || item);
    // ⚠️ 追问建议是系统生成的，需要转换
    return normalizeToZhHK(question);
  });
  // ...
}
```

---

## 五、前端 UI 文案处理

### 5.1 i18n 语言包完善

**位置**：`app/src/i18n/locales/zh-HK.ts`

**原则**：
- 语言包直接写繁体，不走转换
- 所有 UI 硬编码中文迁移到语言包

**需要补充的键值**（示例）：

```typescript
// 需要补充的键值
common: {
  send: '發送',  // ❌ 当前缺失
  // ...
},
xiaopei: {
  commonQuestions: '大家常問',  // ❌ 当前缺失
  commonQuestionsHint: '不知道問什麼？看看大家常問的問題',  // ❌ 当前缺失
  inputHint: '也可以直接把你現在最在意的事告訴小佩',  // ❌ 当前缺失
  inputPlaceholder: '比如：最近感情很亂，不知道該怎麼辦',  // ❌ 当前缺失
  // ...
},
shensha: {
  loading: '載入中...',  // ❌ 当前缺失
  interpret: '神煞解讀',  // ❌ 当前缺失
  // ...
},
```

**扫描方法**：
1. 使用 ESLint 规则或脚本扫描 `app/src` 下所有 `.tsx`、`.ts` 文件
2. 提取硬编码中文字符串（排除注释、变量名、API 路径）
3. 补充到 `zh-HK.ts`，并在组件中使用 `t('key')`

### 5.2 组件改造

**原则**：
- 所有硬编码中文 → `t('key')`
- 优先使用已有键值，缺失的补充到语言包

**示例改造**：

**改造前**（`XiaoPeiHomeScreen.tsx`）：
```typescript
<Text style={styles.sectionTitle}>大家常问</Text>
<Text style={styles.sectionHint}>不知道问什么？看看大家常问的问题</Text>
<Text style={styles.sendButtonText}>发送</Text>
```

**改造后**：
```typescript
const { t } = useTranslation();

<Text style={styles.sectionTitle}>{t('xiaopei.commonQuestions')}</Text>
<Text style={styles.sectionHint}>{t('xiaopei.commonQuestionsHint')}</Text>
<Text style={styles.sendButtonText}>{t('common.send')}</Text>
```

### 5.3 动态字段处理（系统生成的）

**场景**：
- 卡片标题、副标题、描述（来自后端或 LLM）
- 标签文案：`「機會年」/「行運偏順」/「桃花強」...`
- 状态提示：`「載入中…」「解讀生成中…」` 等

**处理方式**：
```typescript
// 在卡片容器层统一处理
const displayText = normalizeToZhHK(rawText);
```

**使用建议**：
- 在**卡片容器**层做一次，而不是在每个 `<Text>` 上到处调用
- 聊天记录/卡片内容如果是从缓存/后端取，也一样先 `normalizeToZhHK`

### 5.4 用户输入相关的展示

**规则**：一律不转换

**场景示例**：

1. **用户在输入框里打的内容**
   ```typescript
   // ✅ 正确：原样展示
   <TextInput value={userInput} />  // 不做任何转换
   ```

2. **聊天记录里的用户气泡**
   ```typescript
   // ✅ 正确：原样展示
   {message.role === 'user' && (
     <Text>{message.text}</Text>  // 不做 normalizeToZhHK
   )}
   ```

3. **引用用户原话**
   ```typescript
   // ✅ 正确：只转换系统提示部分
   const prefix = normalizeToZhHK('你剛才問：');
   const quote = userInput; // 原样
   const displayText = prefix + quote;
   ```

> **规则：只要这段文本的主要来源是用户输入，就不要过 `normalizeToZhHK`。**

---

## 六、后端系统文本处理

### 6.1 非流式接口（如果有）

**位置**：`core/src/routes/conversation.ts` 或其他返回 LLM 文本的接口

**处理方式**：
```typescript
// 在返回给前端前，统一对 LLM 返回的字符串做一次 normalizeToZhHK
const normalizedResponse = normalizeToZhHK(llmResponse.content);
```

### 6.2 流式接口

**原则**：
- 原样把 token/文本推给前端，不在后端改
- 前端负责 per-chunk 处理（已在 4.2 节说明）

### 6.3 后端生成的标签/状态文本

**场景**：
- 卡片标签（如「機會年」「壓力年」）
- 状态文本（如「載入中」「生成中」）
- 错误提示、系统消息

**处理方式**（二选一，不要重复）：

**方案 A：后端提前转换**（推荐）
```typescript
// 在生成标签/状态时直接使用繁体
const tag = normalizeToZhHK(generateTag());
```

**方案 B：前端统一转换**
```typescript
// 后端返回原样，前端渲染前转换
const displayTag = normalizeToZhHK(backendTag);
```

**建议**：选择方案 B（前端统一），因为：
- 后端逻辑更简单，不引入转换依赖
- 前端统一处理，更容易维护
- 如果后端已有繁体，前端转换是幂等的（不会重复转换）

### 6.4 请求处理：用户输入原样传递

**原则**：
- 请求 body 里的 `message` / `userQuestion`、URL 参数等，一律按用户原始输入传递，不做转换
- LLM Prompt 里引用用户文本时，也用原样内容（模型要理解的就是用户真实输入）

**示例**：
```typescript
// ✅ 正确：用户输入原样传给 LLM
const prompt = buildPrompt({
  userQuestion: req.body.userQuestion,  // 不做转换
  // ...
});
```

---

## 七、用户输入禁区规则

### 7.1 明确禁止的操作

为了避免团队之后有人"顺手处理一下用户文本"，明确以下规则：

1. **禁止对用户输入调用 `normalizeToZhHK`**
   - 包括：前端输入框、用户气泡、后端接收到的 request body

2. **禁止在保存/更新数据库前做简繁转换**
   - 用户问题、反馈、备注等，全部保留原样

3. **禁止对「主要信息来源为用户」的字段做自动改写**
   - 比如：搜索关键字、用户写的备注、用户自填标签

### 7.2 文档规范

在项目文档中明确一条：

> **用户產生的內容（User Generated Content, UGC）在本系統中一律保持原樣，不進行簡繁轉換或術語替換。所有簡繁統一僅針對系統產生的內容。**

### 7.3 工程化规则（Code Review 快速检查）

**参数命名检查**：
> 凡是函數參數名中包含 `user`, `input`, `query`, `keyword` 等字樣的，默認視為用戶輸入，不得傳入 `normalizeToZhHK`。

**代码审查检查点**：
- [ ] 所有 `normalizeToZhHK(...)` 的调用参数，确认不是直接来自用户输入（userInput / query / keyword 等）
- [ ] 是否对用户输入调用了 `normalizeToZhHK`？
- [ ] 是否在保存用户数据前做了转换？
- [ ] 是否对用户生成的内容做了自动改写？

---

## 八、实施优先级

### ✅ P0（马上能做，让新内容不再挖坑）

**时间线**：3-4 天

1. **Prompt 层**（1-2 天）
   - 全量给专线 Prompt + 通用 Prompt 加「繁体输出要求」一段
   - 覆盖 `core/src/modules/prompt/` 目录下所有 Prompt 模板文件

2. **前端流式层**（1 天）
   - 创建 `app/src/utils/normalizeText.ts`（`normalizeToZhHK` + `applyDomainMapping`）
   - 修改 `ChatScreen.tsx`：助手消息 chunk → `normalizeToZhHK`，用户消息原样

3. **卡片渲染层**（1 天）
   - 卡片正文、标题等系统生成文本统一过 `normalizeToZhHK`

### ✅ P1（质量 + 体验）

**时间线**：3-4 天

4. **i18n 完善**（2-3 天）
   - 扫描硬编码中文，补充到 `zh-HK.ts`
   - 改造组件使用 i18n
   - 建立 lint 规则：非 i18n 文件中出现中文字符 → 提醒

5. **系统提示/标签统一**（1 天）
   - 后端返回的标签、状态文本统一走 `normalizeToZhHK`
   - 系统提示信息统一走 i18n + 繁体

### 🕒 P2（慢慢还债）

6. **Prompt 源码繁体化**（可选）
   - 按专线分批把 Prompt 源码改成繁体（不影响功能）

7. **完善领域映射**（持续优化）
   - 收集实际使用中的转换问题，持续优化映射表

---

> **具体任务拆分与负责人、截止时间请以项目看板（Jira / 飞书项目）为准。**

---

## 九、技术选型

### 9.1 前端简繁转换库

**推荐：`opencc-js`**

- **优点**：
  - 覆盖全面，维护活跃
  - 支持多种转换模式（简→繁、繁→简、简→繁（香港）等）
  - 有 TypeScript 类型定义
  - 体积：~200KB（可接受）

- **安装**：
  ```bash
  npm install opencc-js
  ```

- **使用**：
  ```typescript
  import { Converter } from 'opencc-js';
  const converter = Converter({ from: 'cn', to: 'hk' });
  const traditional = converter(text);
  ```

**备选：`zhconv`**
- 更轻量，但覆盖有限
- 如果 `opencc-js` 体积问题，可以考虑

### 9.2 后端简繁转换库（如需要）

**推荐：`opencc`（Node.js 版本）**

- 如果后端需要统一转换（方案 A），可以使用
- 但建议优先前端统一处理（方案 B）

### 9.3 性能考虑

**流式输出转换（V1 实现建议）**：

```typescript
// V1：簡單版 - 每個 chunk 都轉（先這樣上線，觀察性能）
onChunk(content: string) {
  const normalized = normalizeToZhHK(content);
  append(normalized);
}
```

**如果後續發現性能問題，可以改成批量處理**：

```typescript
// 優化版：批量轉換（如果 V1 在低端機測試發現卡頓）
let buffer = '';
const BATCH_SIZE = 50; // 字符數或時間間隔

onChunk(content: string) {
  buffer += content;
  
  // 每累積到 N 個字符 / N 毫秒，做一次 batch normalize
  if (buffer.length >= BATCH_SIZE) {
    const normalized = normalizeToZhHK(buffer);
    append(normalized);
    buffer = '';
  }
}
```

**实施建议**：
> V1 直接對每個 chunk 調用 `normalizeToZhHK`，優先保證正確性。若後續在低端機測試發現卡頓，再按需優化為「小批量轉換」方案。

**缓存**：
- 对于重复出现的文本（如系统提示），可以考虑缓存转换结果
- 但需要权衡内存开销

---

## 十、测试验证清单

### 10.1 功能测试

#### LLM 输出测试
- [ ] 新建对话，发送问题，检查助手回复是否为繁体
- [ ] 流式输出过程中，每个 chunk 是否正确转换
- [ ] 历史消息加载后，助手消息是否为繁体
- [ ] 用户消息是否保持原样（不转换）

#### 用户输入测试
- [ ] 用户输入简体中文，展示时是否保持原样
- [ ] 用户输入繁体中文，展示时是否保持原样
- [ ] 用户输入传给后端时是否保持原样
- [ ] 用户输入传给 LLM 时是否保持原样

#### UI 文案测试
- [ ] 所有页面 UI 文案是否为繁体
- [ ] 按钮、标签、提示信息是否为繁体
- [ ] 错误提示、加载状态是否为繁体

#### 卡片/标签测试
- [ ] 卡片标题、描述是否为繁体
- [ ] 标签文案（如「機會年」「壓力年」）是否为繁体
- [ ] 后端返回的状态文本是否为繁体

### 10.2 边界情况测试

- [ ] 空字符串处理
- [ ] null/undefined 处理
- [ ] 混合简繁文本处理
- [ ] 特殊字符处理
- [ ] 长文本性能测试

### 10.3 对照截图测试（推荐）

- [ ] 隨機選 3 條典型聊天（愛情 / 事業 / 婚姻），分別截圖：
  - 老版本（簡繁混用）
  - 新版本（簡繁統一後）
  - 對比確認：
    - 助手部分全部為繁體
    - 用戶部分保持原樣
    - UI 文案全部繁體

**用途**：
- 給產品 / 運營看「改前改後」對比
- 出一張小 changelog 截圖，讓所有人都知道「繁體統一已經上線」

### 10.4 回归测试

- [ ] 确保用户输入功能正常（登录、注册、输入框等）
- [ ] 确保聊天功能正常（发送、接收、历史记录）
- [ ] 确保卡片展示正常
- [ ] 确保其他功能不受影响

---

## 十二、常见问题 FAQ

### Q1: 如果用户输入繁体，LLM 回复也用繁体，会不会重复转换？

**A**: 不会。`normalizeToZhHK` 使用 `opencc.s2hk`，如果输入已经是繁体，转换结果基本不变（可能会有细微用字差异，但不会出错）。

### Q2: 性能问题怎么办？

**A**: 
- 先实施，再测试
- 如果流式转换有性能问题，可以考虑：
  - 异步处理
  - 批量处理
  - 缓存常用文本

### Q3: 如何确保团队不会误用？

**A**: 
- 在 `normalizeToZhHK` 函数注释中明确说明使用场景
- 代码审查时检查
- 建立 lint 规则（P1 阶段）

### Q4: 如果 Prompt 要求繁体，但 LLM 还是输出简体怎么办？

**A**: 
- 前端 `normalizeToZhHK` 作为兜底，确保最终展示为繁体
- 如果发现某些 Prompt 效果不好，可以加强 Prompt 中的要求

### Q5: 历史数据怎么办？

**A**: 
- 历史消息加载时统一转换助手消息（已在方案中说明）
- 数据库中的用户输入保持原样，不做转换
- 如果需要批量转换历史数据，可以写脚本，但只转换助手消息

---

## 十一、紧急回滚策略

### 🧯 如发现问题，最小代价回滚

#### 场景 1：LLM 回复出现严重乱码 / 文本缺失

**处理步骤**：
1. 暂时关闭前端 `normalizeToZhHK` 调用（保留 Prompt 要求繁体）
2. 检查 `opencc-js` 引入与 `applyDomainMapping` 实现是否有问题
3. 修复后重新启用

**快速定位**：
```bash
# 全局搜索 normalizeToZhHK 的调用
grep -r "normalizeToZhHK" app/src/
```

#### 场景 2：用户输入被误转换

**处理步骤**：
1. 立即在代码中全局搜索 `normalizeToZhHK(`
2. 检查是否有传入 userInput / query / keyword 类变量
3. 删除相关调用后重新部署

**检查命令**：
```bash
# 检查是否有误用
grep -r "normalizeToZhHK.*user" app/src/
grep -r "normalizeToZhHK.*input" app/src/
grep -r "normalizeToZhHK.*query" app/src/
```

#### 场景 3：性能问题（低端机卡顿）

**处理步骤**：
1. 先确认是否由 `normalizeToZhHK` 引起（注释掉测试）
2. 如果确认，参考「9.3 性能考虑」中的批量处理方案
3. 或暂时降低转换频率（每 N 个 chunk 转换一次）

---

## 十三、总结

### 核心原则
1. **坚决不碰用户输入**：用户产生的所有内容保持原样
2. **统一系统输出为繁体**：UI 文案、LLM 回复、后端字段全部繁体
3. **三层防护**：Prompt 约束 + 前端实时转换 + 静态内容统一

### 实施路径
1. **P0 阶段**：Prompt 要求 + 前端流式转换 + 卡片渲染（让新内容不再挖坑）
2. **P1 阶段**：i18n 完善 + 系统文本统一（提升质量）
3. **P2 阶段**：Prompt 源码繁体化 + 领域映射完善（持续优化）

### 预期效果
- ✅ 前端 UI：100% 繁体中文
- ✅ LLM 输出：100% 繁体中文（通过 Prompt 约束 + 前端兜底）
- ✅ 后端字段：100% 繁体中文（通过转换工具）
- ✅ 用户输入：100% 保持原样
- ✅ 用户体验：统一繁体显示，不影响用户输入

---

---

**文档版本**：v1.1（优化版）  
**最后更新**：2025-01-XX  
**维护者**：开发团队

---

## 文档更新记录

- **v1.1**：优化版
  - 统一 opencc 用法写法
  - 明确 `applyDomainMapping` V1 实现
  - 精简重复内容（合并实施优先级和检查清单）
  - 增加工程化规则和紧急回滚策略
  - 优化性能考虑和测试清单

- **v1.0**：初始版

