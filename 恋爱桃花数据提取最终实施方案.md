# 恋爱桃花数据提取最终实施方案

## 一、核心原则

1. **字段命名与 Engine / 现有 DTO 完全一致**
2. **数据流清晰、可维护**
3. **复用现有工具函数，不重复造轮子**
4. **明确标注需要重新计算的字段，等确认后再实施**

---

## 二、系统已有字段检查清单

### ✅ 可直接使用的字段（无需重新计算）

| 字段 | 数据路径 | 状态 | 说明 |
|------|---------|------|------|
| **四柱干支** | `pillars.{year/month/day/hour}.stem`<br>`pillars.{year/month/day/hour}.branch` | ✅ 已有 | 引擎已计算 |
| **四柱十神** | `pillars.{year/month/day/hour}.shishen` | ✅ 已有 | 引擎已计算 |
| **四柱神煞** | `pillars.{year/month/day/hour}.shensha[]` | ✅ 已有 | 引擎已计算（包含桃花、红鸾、天喜等） |
| **十二长生** | `pillars.{year/month/day/hour}.zizuo`<br>`pillars.{year/month/day/hour}.self_sit` | ✅ 已有 | 引擎已计算 |
| **日主信息** | `analysis.dayMaster.{gan, zhi, wuxing, strength, strengthLabel, description}` | ✅ 已有 | 引擎已计算 |
| **日主强弱** | `analysis.strengthAnalysis.{score, label, factors}` | ✅ 已有 | 引擎已计算 |
| **格局名称** | `analysis.structure.name` | ✅ 已有 | 引擎已计算 |
| **十神权重** | `analysis.structure.tenGodWeights`<br>`analysis.structure.W` | ✅ 已有 | 引擎已计算（包含 guan, zGuan, sha, cai, shi, shang, bi, yin, zYin, pYin） |
| **用神五行** | `analysis.yongshenPattern.mainYongshen.elements` | ✅ 已有 | 引擎已计算 |
| **忌神五行** | `analysis.yongshenPattern.tabooElements` | ✅ 已有 | 引擎已计算 |
| **五行分布** | `analysis.wuxingPercent.{木, 火, 土, 金, 水}` | ✅ 已有 | 引擎已计算 |
| **清浊等级** | `analysis.purity.level`<br>`analysis.patternPurity.level` | ✅ 已有 | 引擎已计算 |
| **调候分析** | `analysis.tiaohou.{summary, label}` | ✅ 已有 | 引擎已计算 |
| **体用分析** | `analysis.tiyong.interpretation` | ✅ 已有 | 引擎已计算 |
| **当前大运** | `analysis.luckRhythm.currentLuck`<br>`derived.luck_cycle[]` | ✅ 已有 | 引擎已计算 |
| **流年列表** | `analysis.luckRhythm.annualBrief[]` | ✅ 已有 | 引擎已计算（包含 year, ganzhi, shishen, favourLevel） |
| **大运干支** | `derived.luck_cycle[].{stem, branch, ganzhi}` | ✅ 已有 | 引擎已计算 |
| **大运年龄区间** | `derived.luck_cycle[].{startAge, endAge, ageRange}` | ✅ 已有 | 引擎已计算 |
| **大运十神** | `derived.luck_cycle[].shishen` | ✅ 已有 | 引擎已计算 |
| **大运神煞** | `derived.luck_cycle[].shensha[]` | ✅ 已有 | 引擎已计算 |

### ⚠️ 需要重新计算的字段（需确认后实施）

| 字段 | 当前状态 | 需要计算的内容 | 计算依据 | 优先级 |
|------|---------|---------------|---------|--------|
| **配偶宫关系** | ❌ 占位符 | 日支与其他地支的六合、三合、六冲、三刑、六害关系 | 调用 `analyzeBranchRelationships(pillars)` | P0 |
| **流年与配偶宫关系** | ❌ 占位符 | 流年地支与日支的合冲刑害关系 | 调用 `analyzeYearRelationships(pillars, yearBranch)` | P0 |
| **配偶星分布** | ❌ 占位符 | 配偶星（财星/官杀）在四柱中的分布位置 | 根据十神权重和四柱十神分析 | P1 |
| **配偶星状态** | ❌ 占位符 | 配偶星强弱、是否混杂、是否被克冲 | 根据十神权重、格局、冲突分析 | P1 |
| **食伤状态** | ❌ 占位符 | 食神/伤官的强弱和状态 | 根据十神权重分析 | P1 |
| **感情表达方式提示** | ❌ 占位符 | 主动/被动、会不会说甜话等 | 根据配偶星、食伤、格局综合判断 | P1 |
| **恋爱环境提示** | ❌ 占位符 | 恋爱多发生在什么场景 | 根据月支、时支、配偶宫关系、神煞位置 | P2 |
| **风险提示** | ❌ 占位符 | 可能影响感情的风险点 | 从 `analysis.structure.pogeFactors`<br>`analysis.breaking` 中提取 | P2 |
| **大运恋爱神煞** | ❌ 占位符 | 当前大运中的恋爱相关神煞 | 从 `derived.luck_cycle[].shensha[]` 中筛选 | P0 |
| **流年恋爱神煞** | ❌ 占位符 | 流年中的恋爱相关神煞 | 需要计算流年神煞或从已有数据提取 | P0 |
| **大运 favourLevel 转换** | ⚠️ 类型不匹配 | 字符串转数字（'good'→2, 'bad'→-2, 'neutral'→0） | 简单映射函数 | P0 |
| **流年 favourLevel 转换** | ⚠️ 类型不匹配 | 字符串转数字 | 简单映射函数 | P0 |

---

## 三、Part A：`buildLoveChatContext` 优化方案

### 1. 函数签名优化 ✅

**当前**：
```typescript
export function buildLoveChatContext(
  chartResult: any,
  userQuestion?: string
): LoveChatContext
```

**优化后**：
```typescript
export function buildLoveChatContext(params: {
  chartResult: any;                  // Engine 原始结果
  gender: 'male' | 'female' | 'unknown';  // 从 chart_profiles 表查询
  userQuestion: string;
  now?: Date;                        // 方便测试 & 固定当前年份
}): LoveChatContext
```

**改动说明**：
- ✅ 性别作为参数传入，不再从 `chartResult` 中猜测
- ✅ 当前时间可配置，便于测试
- ✅ 参数结构清晰，便于扩展

---

### 2. 四柱字段名修复 ✅（P0）

**当前代码**（第 98 行）：
```typescript
ganzhi: `${pillar.gan || ''}${pillar.zhi || ''}`,
```

**修复后**：
```typescript
ganzhi: `${pillar.stem || ''}${pillar.branch || ''}`,
```

**改动说明**：
- ✅ 与引擎字段名完全一致
- ✅ 与前端 `PillarDetail` 类型定义一致

---

### 3. 基础信息 basic：直接透出 Engine 结构 ✅

**优化方案**：
```typescript
function extractBasicInfo(chartResult: any): LoveChatContext['basic'] {
  const analysis = chartResult.analysis || {};
  const dayMaster = analysis.dayMaster || {};
  const strength = analysis.strengthAnalysis || {};
  const structure = analysis.structure || {};
  const yongshenPattern = analysis.yongshenPattern || {};
  const wuxingPercent = analysis.wuxingPercent || {};
  
  // 十神权重：优先使用 W，否则从 tenGodWeights 聚合
  const W = structure.W || structure.tenGodWeights || {};
  
  return {
    dayMaster: dayMaster.gan && dayMaster.wuxing 
      ? `${dayMaster.gan}${dayMaster.wuxing}` 
      : '未知',
    dayMasterStrength: {
      score: strength.score ?? 0,
      level: strength.label || '未知',
      description: strength.description || '',
    },
    structure: {
      name: structure.name || '未知格局',
      confidence: structure.confidence ?? 0,
      weights: normalizeTenGodWeights(W), // 见下
    },
    yongshen: {
      like: yongshenPattern.mainYongshen?.elements || [],
      dislike: yongshenPattern.tabooElements || [],
      summary: yongshenPattern.summary || '',
    },
    wuxing: wuxingPercent, // 直接透出 { 木, 火, 土, 金, 水 }
  };
}

// 十神权重标准化函数
function normalizeTenGodWeights(rawW: any) {
  if (!rawW) {
    return { guan: 0, cai: 0, shishang: 0, bijie: 0, yin: 0 };
  }
  
  // 如果已经是标准格式（有 guan 字段），直接返回
  if (rawW.guan !== undefined) {
    return {
      guan: rawW.guan,
      cai: rawW.cai || 0,
      shishang: (rawW.shi || 0) + (rawW.shang || 0),
      bijie: rawW.bi || 0,
      yin: rawW.yin || 0,
    };
  }
  
  // 否则从 tenGodWeights 聚合
  return {
    guan: (rawW.zGuan || 0) + (rawW.sha || 0),
    cai: rawW.cai || 0,
    shishang: (rawW.shi || 0) + (rawW.shang || 0),
    bijie: rawW.bi || 0,
    yin: (rawW.yin || 0) + (rawW.zYin || 0) + (rawW.pYin || 0),
  };
}
```

**改动说明**：
- ✅ 直接使用 Engine 字段，不做额外转换
- ✅ 十神权重统一标准化，避免字段名不一致

---

### 4. 宫位 palace：使用现有关系计算工具 ⚠️（需确认）

**当前代码**（第 124-145 行）：
```typescript
// 从 structure.clashInfo 获取（可能不存在）
const clashInfo = structure.clashInfo || {};
```

**优化方案**：
```typescript
function extractPalaceInfo(chartResult: any): LoveChatContext['palace'] {
  const pillars = chartResult.pillars || {};
  const dayBranch = pillars.day?.branch || '';
  
  // ⚠️ 需要调用引擎的地支关系计算函数
  // 需要导入：import { analyzeBranchRelationships } from '../../../engine/mingli/branchRelationships.js';
  const relationships = analyzeBranchRelationships(pillars);
  
  return {
    spouseBranch: dayBranch || '未知',
    relations: {
      he: relationships.liuhe || [],
      sanhe: relationships.sanhe || [],
      chong: relationships.liuchong || [],
      xing: relationships.sanxing || [],
      hai: relationships.liuhai || [],
    },
    loveEnvironmentNotes: buildLoveEnvironmentNotes(chartResult), // 见下
  };
}

// ⚠️ 需要实现：根据月支、时支、配偶宫关系生成恋爱环境提示
function buildLoveEnvironmentNotes(chartResult: any): string {
  // 根据月支、时支、配偶宫关系、神煞位置生成提示
  // 例如："恋爱多发生在工作环境"、"容易在社交圈遇到"等
  // 需要确认：这个逻辑是否需要实现？
}
```

**需要确认**：
- ✅ 使用 `analyzeBranchRelationships` 计算关系（已有工具函数）
- ⚠️ `buildLoveEnvironmentNotes` 需要实现，是否同意实施？

---

### 5. 配偶星 spouseAndExpression：基于真实字段计算 ⚠️（需确认）

**当前代码**（第 150-176 行）：
```typescript
// 所有字段都是占位符
spouseStarDistribution: '配偶星分布需要根据十神分析确定',
spouseStarStatus: { strength: '中等', ... },
```

**优化方案**：
```typescript
function extractSpouseInfo(
  chartResult: any,
  gender: 'male' | 'female' | 'unknown'
): LoveChatContext['spouseAndExpression'] {
  const analysis = chartResult.analysis || {};
  const structure = analysis.structure || {};
  const pillars = chartResult.pillars || {};
  const W = structure.W || structure.tenGodWeights || {};
  const dayMasterGan = analysis.dayMaster?.gan || '';
  
  // 判断配偶星类型
  const spouseStarType = gender === 'male' ? '财星' : '官杀';
  
  // ⚠️ 需要实现：根据十神权重和四柱十神分析配偶星分布
  const spouseStarDistribution = analyzeSpouseStarDistribution(
    pillars,
    W,
    spouseStarType
  );
  
  // ⚠️ 需要实现：分析配偶星状态
  const spouseStarStatus = analyzeSpouseStarStatus(
    W,
    spouseStarType,
    structure,
    pillars
  );
  
  // ⚠️ 需要实现：分析食伤状态
  const shiShangStatus = analyzeShiShangStatus(W);
  
  // ⚠️ 需要实现：生成感情表达方式提示
  const expressionHints = buildExpressionHints({
    spouseStarStatus,
    shiShangStatus,
    structure,
    pillars,
  });
  
  return {
    spouseStarType,
    spouseStarDistribution,
    spouseStarStatus: {
      strength: spouseStarStatus.level, // '偏弱' | '中等' | '偏旺'
      mixed: spouseStarStatus.mixed,
      conflict: spouseStarStatus.conflict,
      description: spouseStarStatus.description,
    },
    shiShangStatus: {
      strength: shiShangStatus.level,
      description: shiShangStatus.description,
    },
    expressionHints, // 2-4 条短句
  };
}

// ⚠️ 需要实现的辅助函数（需确认）
function analyzeSpouseStarDistribution(
  pillars: any,
  W: any,
  spouseStarType: '财星' | '官杀'
): string {
  // 分析配偶星在年/月/日/时柱的分布
  // 例如："财星主要分布在月柱和时柱"
  // 需要确认：这个逻辑是否需要实现？
}

function analyzeSpouseStarStatus(
  W: any,
  spouseStarType: '财星' | '官杀',
  structure: any,
  pillars: any
): {
  level: string;
  mixed: boolean;
  conflict: boolean;
  description: string;
} {
  // 根据十神权重判断强弱
  // 根据格局判断是否混杂
  // 根据冲突分析判断是否被克冲
  // 需要确认：这个逻辑是否需要实现？
}

function analyzeShiShangStatus(W: any): {
  level: string;
  description: string;
} {
  // 根据食神+伤官的权重判断强弱
  // 需要确认：这个逻辑是否需要实现？
}

function buildExpressionHints(params: any): string[] {
  // 根据配偶星、食伤、格局综合判断
  // 生成 2-4 条提示，如："你在感情中比较主动"、"不太会说甜话"
  // 需要确认：这个逻辑是否需要实现？
}
```

**需要确认**：
- ⚠️ 以上 4 个辅助函数是否需要实现？
- ⚠️ 如果实现，计算规则是否需要进一步细化？

---

### 6. 清浊调候 patternAndBearing：对齐现有字段 ✅

**优化方案**：
```typescript
function extractPatternInfo(chartResult: any): LoveChatContext['patternAndBearing'] {
  const analysis = chartResult.analysis || {};
  const purity = analysis.purity || analysis.patternPurity || {};
  const tiaohou = analysis.tiaohou || {};
  const tiyong = analysis.tiyong || {};
  const breaking = analysis.breaking || analysis.structure?.pogeFactors || [];
  
  return {
    purityLevel: purity.level || purity.label || '未知',
    tiaoHouSummary: tiaohou.summary || tiaohou.label || '',
    tiYongSummary: tiyong.interpretation || tiyong.summary || '',
    riskHints: buildRiskHintsFromBreaking(breaking), // 见下
  };
}

// ⚠️ 需要实现：从 breaking/pogeFactors 中提取风险提示
function buildRiskHintsFromBreaking(breaking: any[]): string[] {
  // 从破格因素、冲突分析中提取与感情相关的风险提示
  // 例如："现实压力容易影响感情"、"情绪波动较大"
  // 需要确认：这个逻辑是否需要实现？
}
```

**需要确认**：
- ⚠️ `buildRiskHintsFromBreaking` 是否需要实现？

---

### 7. 大运流年 fortune：强制使用 `luckRhythm + annualBrief` ✅（P0）

**优化方案**：
```typescript
function extractFortuneInfo(
  chartResult: any,
  spouseBranch: string,
  now: Date
): LoveChatContext['fortune'] {
  const analysis = chartResult.analysis || {};
  const luckRhythm = analysis.luckRhythm || {};
  const annualBrief = luckRhythm.annualBrief || [];
  const derived = chartResult.derived || {};
  const luckCycle = derived.luck_cycle || [];
  const pillars = chartResult.pillars || {};
  
  const currentYear = now.getFullYear();
  
  // 找当前大运
  const currentLuckItem = luckCycle.find((luck: any) => luck.isCurrent)
    || luckCycle.find((luck: any) => isYearInAgeRange(currentYear, luck))
    || luckCycle[0]
    || {};
  
  const currentLuckRaw = luckRhythm.currentLuck || {};
  
  // 提取大运恋爱神煞
  const loveShenSha = extractLoveShenShaFromList(
    currentLuckItem.shensha || []
  );
  
  const currentLuck: LoveChatContext['fortune']['currentLuck'] = {
    ganzhi: currentLuckItem.ganzhi 
      || `${currentLuckItem.stem || ''}${currentLuckItem.branch || ''}`
      || currentLuckRaw.label
      || '未知',
    ageRange: currentLuckItem.ageRange 
      || currentLuckRaw.ageRange 
      || '',
    favourLevel: mapFavourLevel(currentLuckRaw.favourLevel), // 见下
    loveShenSha,
    rhythmDescription: currentLuckRaw.tone 
      || currentLuckRaw.rhythmDescription 
      || '',
  };
  
  // 从 annualBrief 提取最近 3 年
  const years: LoveChatContext['fortune']['years'] = annualBrief
    .filter((y: any) => Math.abs(y.year - currentYear) <= 1)
    .sort((a: any, b: any) => a.year - b.year)
    .slice(0, 3)
    .map((item: any) => ({
      year: item.year,
      ganzhi: item.ganzhi,
      tenGodToDay: item.shishen || '未知',
      favLevel: mapFavourLevel(item.favourLevel),
      branchRelationsToSpousePalace: calcYearBranchRelations(
        item,
        spouseBranch,
        pillars
      ), // 见下
      loveShenSha: extractYearLoveShenSha(item, chartResult), // 见下
    }));
  
  return { currentLuck, years };
}

// ✅ 需要实现：favourLevel 类型转换
function mapFavourLevel(
  level: 'good' | 'bad' | 'neutral' | 'mixed' | '用神' | '忌神' | string | undefined
): number {
  if (level === 'good' || level === '用神') return 2;
  if (level === 'bad' || level === '忌神') return -2;
  if (level === 'mixed') return 0;
  if (level === 'neutral') return 0;
  return 0; // 默认中性
}

// ⚠️ 需要实现：计算流年地支与配偶宫的关系
function calcYearBranchRelations(
  yearItem: any,
  spouseBranch: string,
  pillars: any
): string[] {
  // 需要导入：import { analyzeYearRelationships } from '../../../engine/mingli/branchRelationships.js';
  // 调用 analyzeYearRelationships(pillars, yearItem.branch)
  // 返回关系描述数组，如：["与日支六合", "冲月支"]
  // 需要确认：这个逻辑是否需要实现？
}

// ⚠️ 需要实现：提取流年恋爱神煞
function extractYearLoveShenSha(
  yearItem: any,
  chartResult: any
): string[] {
  // 流年神煞可能需要重新计算，或者从已有数据中提取
  // 需要确认：流年神煞数据是否已经存在？还是需要重新计算？
}

// ✅ 需要实现：从神煞列表中筛选恋爱相关神煞
function extractLoveShenShaFromList(shenshaList: string[]): string[] {
  const loveShenSha = [
    '桃花', '咸池', '红鸾', '天喜', '流霞', '孤辰', '寡宿',
    '天乙贵人', '月德', '天德'
  ];
  return shenshaList.filter(s => 
    loveShenSha.some(keyword => s.includes(keyword))
  );
}
```

**需要确认**：
- ✅ `mapFavourLevel` 类型转换（简单映射，同意实施）
- ✅ `extractLoveShenShaFromList` 筛选神煞（简单筛选，同意实施）
- ⚠️ `calcYearBranchRelations` 计算流年与配偶宫关系（需要调用引擎函数，是否同意实施？）
- ⚠️ `extractYearLoveShenSha` 提取流年神煞（需要确认流年神煞数据来源）

---

### 8. 辅助分析 extra：对齐现有字段 ✅

**优化方案**：
```typescript
function extractExtraInfo(chartResult: any): LoveChatContext['extra'] {
  const analysis = chartResult.analysis || {};
  
  return {
    energyFlowSummary: analysis.energyFlow?.summary || '',
    guancaiSummary: analysis.guancaiPattern?.summary || '',
    minggeSummary: analysis.minggeSummary?.summary || '',
  };
}
```

**改动说明**：
- ✅ 直接使用现有字段，不做额外处理
- ⚠️ 如果字段为空，LLM 会看到空字符串，这是合理的

---

## 四、Part B：数据架构优化方案

### 1. 新增 LoveDataService ✅

**文件**：`core/src/modules/love/loveDataService.ts`

**功能**：
- 统一管理恋爱专线的数据查询和提取
- 封装数据库访问逻辑
- 调用 `buildLoveChatContext` 构建上下文

**实现方案**：
```typescript
import { getPool } from '../../database/connection';
import { buildLoveChatContext } from './loveContextBuilder';

/**
 * 为指定命盘构建恋爱聊天上下文
 * 
 * @param params.chartProfileId 命盘档案ID
 * @param params.userQuestion 用户问题
 * @param params.now 当前时间（可选，用于测试）
 * @returns LoveChatContext
 */
export async function buildLoveChatContextForChart(params: {
  chartProfileId: string;
  userQuestion: string;
  now?: Date;
}): Promise<LoveChatContext> {
  const { chartProfileId, userQuestion, now = new Date() } = params;
  const pool = getPool();
  
  // 1. 一次性查询所需数据
  const [rows]: any = await pool.query(`
    SELECT 
      bc.result_json,
      cp.gender
    FROM bazi_charts bc
    JOIN chart_profiles cp ON bc.chart_profile_id = cp.chart_profile_id
    WHERE bc.chart_profile_id = ?
    ORDER BY bc.created_at DESC
    LIMIT 1
  `, [chartProfileId]);
  
  if (rows.length === 0) {
    throw new Error('命盘数据不存在');
  }
  
  const chartResult = JSON.parse(rows[0].result_json);
  const gender = normalizeGender(rows[0].gender);
  
  // 2. 调用统一的 builder
  return buildLoveChatContext({
    chartResult,
    gender,
    userQuestion,
    now,
  });
}

function normalizeGender(gender: string): 'male' | 'female' | 'unknown' {
  if (gender === 'male' || gender === 'female') {
    return gender;
  }
  return 'unknown';
}
```

**改动说明**：
- ✅ 所有数据库访问集中在 service 层
- ✅ 性别信息从 `chart_profiles` 表查询
- ✅ 路由层不再直接访问数据库

---

### 2. conversation.ts 简化 ✅

**当前代码**（第 422-435 行）：
```typescript
// 直接查询数据库
const [chartDataRows] = await pool.query<any[]>(
  'SELECT result_json FROM bazi_charts WHERE chart_profile_id = ?',
  [chartId]
);
const chartResult = JSON.parse(chartDataRows[0].result_json);

// 直接调用 buildLoveChatContext
const loveChatContext = buildLoveChatContext(chartResult, message);
```

**优化后**：
```typescript
// 导入 service
import { buildLoveChatContextForChart } from '../modules/love/loveDataService';

// 在恋爱专线分支中
if (isLoveTopic) {
  const loveChatContext = await buildLoveChatContextForChart({
    chartProfileId: chartId,
    userQuestion: message,
  });
  
  const userPrompt = promptTemplates.XIAOPEI_PROMPT_LOVE
    .replace('{{LOVE_CHAT_CONTEXT_JSON}}', JSON.stringify(loveChatContext, null, 2))
    .replace('{{USER_QUESTION}}', message)
    .replace('{{IS_FIRST_MESSAGE}}', isFirstMessage ? 'true' : 'false');
  
  systemPrompt = promptTemplates.XIAOPEI_SYSTEM_PROMPT_CHAT;
}
```

**改动说明**：
- ✅ 路由层只负责调用 service，不再处理数据提取
- ✅ 代码更简洁，职责更清晰

---

## 五、需要重新计算的字段清单（需确认）

### P0 优先级（必须修复，否则数据完全缺失）

| 字段 | 计算内容 | 实现方式 | 确认状态 |
|------|---------|---------|---------|
| **流年与配偶宫关系** | `branchRelationsToSpousePalace` | 调用 `analyzeYearRelationships(pillars, yearBranch)` | ⚠️ 待确认 |
| **大运恋爱神煞** | `currentLuck.loveShenSha` | 从 `luck_cycle[].shensha[]` 筛选 | ✅ 同意实施 |
| **流年恋爱神煞** | `years[].loveShenSha` | 需要确认数据来源 | ⚠️ 待确认 |
| **favourLevel 转换** | 字符串 → 数字 | 简单映射函数 | ✅ 同意实施 |

### P1 优先级（重要，影响数据完整性）

| 字段 | 计算内容 | 实现方式 | 确认状态 |
|------|---------|---------|---------|
| **配偶宫关系** | `palace.relations` | 调用 `analyzeBranchRelationships(pillars)` | ⚠️ 待确认 |
| **配偶星分布** | `spouseStarDistribution` | 根据十神权重和四柱十神分析 | ⚠️ 待确认 |
| **配偶星状态** | `spouseStarStatus` | 根据十神权重、格局、冲突分析 | ⚠️ 待确认 |
| **食伤状态** | `shiShangStatus` | 根据十神权重分析 | ⚠️ 待确认 |
| **感情表达方式提示** | `expressionHints` | 根据配偶星、食伤、格局综合判断 | ⚠️ 待确认 |

### P2 优先级（优化，提升数据质量）

| 字段 | 计算内容 | 实现方式 | 确认状态 |
|------|---------|---------|---------|
| **恋爱环境提示** | `loveEnvironmentNotes` | 根据月支、时支、配偶宫关系、神煞位置 | ⚠️ 待确认 |
| **风险提示** | `riskHints` | 从 `breaking/pogeFactors` 中提取 | ⚠️ 待确认 |

---

## 六、实施步骤建议

### 阶段 1：P0 修复（必须立即修复）

1. ✅ 修复四柱字段名：`gan/zhi` → `stem/branch`
2. ✅ 修复函数签名：添加 `gender` 参数
3. ✅ 实现 `mapFavourLevel` 类型转换
4. ✅ 实现 `extractLoveShenShaFromList` 筛选神煞
5. ✅ 从 `annualBrief` 提取流年信息（不再简化生成）
6. ⚠️ 实现 `calcYearBranchRelations`（需确认）
7. ⚠️ 实现流年神煞提取（需确认数据来源）
8. ✅ 创建 `LoveDataService`
9. ✅ 修改 `conversation.ts` 使用 service

### 阶段 2：P1 完善（重要）

10. ⚠️ 实现 `analyzeBranchRelationships` 调用（需确认）
11. ⚠️ 实现配偶星分析函数（需确认）
12. ⚠️ 实现食伤状态分析（需确认）
13. ⚠️ 实现感情表达方式提示（需确认）

### 阶段 3：P2 优化（可选）

14. ⚠️ 实现恋爱环境提示（需确认）
15. ⚠️ 实现风险提示提取（需确认）

---

## 七、需要确认的问题

### 问题 1：流年神煞数据来源 ⚠️

**问题**：流年神煞是否已经计算并保存在数据中？还是需要重新计算？

**选项**：
- A. 流年神煞已保存在 `derived.flow_years[].shensha[]` 中 → 直接提取
- B. 流年神煞需要重新计算 → 需要调用引擎函数计算
- C. 流年神煞暂时不提供 → 返回空数组

**建议**：先检查实际数据结构，如果不存在，暂时返回空数组，后续再补充。

---

### 问题 2：地支关系计算函数调用 ⚠️

**问题**：`analyzeBranchRelationships` 和 `analyzeYearRelationships` 是 ES 模块，在 TypeScript 中调用是否需要特殊处理？

**选项**：
- A. 直接 `import` 调用（如果支持）
- B. 使用 `dynamic import`（如 `baziService.ts` 中的做法）
- C. 在 TypeScript 中重新实现（不推荐）

**建议**：参考 `baziService.ts` 中 `buildAnnualBrief` 的调用方式，使用 `dynamic import`。

---

### 问题 3：配偶星分析的计算规则 ⚠️

**问题**：配偶星分布、状态、食伤状态的计算规则是否需要详细定义？

**选项**：
- A. 先实现简化版本，后续再细化
- B. 一次性实现完整规则
- C. 暂时使用占位符，后续再实现

**建议**：先实现简化版本，确保数据不为空，后续再根据实际需求细化。

---

### 问题 4：恋爱环境提示的生成规则 ⚠️

**问题**：如何根据月支、时支、配偶宫关系生成"恋爱多发生在XX场景"的提示？

**选项**：
- A. 实现详细规则（需要定义各种组合的映射）
- B. 暂时返回通用提示
- C. 暂时不提供，返回空字符串

**建议**：先返回通用提示，后续再细化规则。

---

## 八、总结

### 可直接实施的改动（无需确认）

1. ✅ 修复四柱字段名：`stem/branch`
2. ✅ 修复函数签名：添加 `gender` 参数
3. ✅ 实现 `mapFavourLevel` 类型转换
4. ✅ 实现 `extractLoveShenShaFromList` 筛选神煞
5. ✅ 从 `annualBrief` 提取流年信息
6. ✅ 创建 `LoveDataService`
7. ✅ 修改 `conversation.ts` 使用 service
8. ✅ 基础信息直接透出 Engine 字段

### 需要确认后实施的改动

1. ⚠️ 调用 `analyzeBranchRelationships` 计算配偶宫关系
2. ⚠️ 调用 `analyzeYearRelationships` 计算流年与配偶宫关系
3. ⚠️ 实现配偶星分析函数（分布、状态）
4. ⚠️ 实现食伤状态分析
5. ⚠️ 实现感情表达方式提示
6. ⚠️ 实现恋爱环境提示
7. ⚠️ 实现风险提示提取
8. ⚠️ 流年神煞数据来源确认

---

## 九、下一步行动

1. **请确认**：以上标记为 ⚠️ 的字段是否需要实施？
2. **请确认**：如果实施，计算规则是否需要进一步细化？
3. **请确认**：流年神煞数据来源（问题 1）
4. **请确认**：地支关系计算函数调用方式（问题 2）

确认后，我将按照优先级逐步实施。

