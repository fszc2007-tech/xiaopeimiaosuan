# 能量流通卡片实施方案

## 📋 方案概述

**目标**：实现「能量流通」卡片，聚焦「五行＋十神的动态流向」，服务于「做事风格、思考习惯、能量链路」。

**卡片名称**：`能量流通`（四字）

**核心要回答的问题**：
- 能量从哪里起、往哪里走、在哪些环节容易放大、在哪些地方容易卡住
- 哪些能量链路顺畅、哪里容易卡住，会对应怎样的思维或做事风格
- 给出 2–3 条温和、可执行的建议，帮助用户更好地顺着自己的能量模式做事

**定位与边界**：
- 不重复《命局总览》：整体气象＋性格主基调
- 不重复《用神格局》：用忌神、调候、取舍
- 不重复《官财格局》：钱与权的轴向

**输出形式**：
- 一段 350–500 字左右的连续文字（3 段落），用在《能量流通》卡片正文
- 卡片头部展示：流通度分数（0–100）、一句话总结、核心做功路径 chips

---

## 一、数据结构设计（与系统参数对齐）

### 1.1 后端数据结构（引擎层）

统一挂在 `analysis.energyFlow` 下面：

```typescript
// 做功路径类型
export type WorkPathType =
  | 'productive'   // 生：食伤生财、财生官、官印相生
  | 'control'      // 克：官克身、身克财等
  | 'rescue'       // 救应：印比护官、食神制杀等
  | 'conflict';    // 冲突：伤官见官、比劫夺财等

// 做功路径
export interface WorkPath {
  id: string;            // 'shi-cai', 'cai-guan', 'guan-yin' 等
  label: string;         // 「食伤生财」「官印相生」「印比护官」…
  type: WorkPathType;
  strength: number;      // 0–1，基于 W 值（min / avg）
  direction: string;     // 如 '食伤 → 财星'，给 LLM 参考
  notes?: string[];     // 算法备注：如「食伤略偏弱」「财星坐根」等
}

// 流通方向
export interface FlowDirection {
  id: string;            // 'yin-shi-cai', 'guan-yin-rizu' 等
  label: string;         // 「从印比 → 食伤 → 财」「从官杀 → 印星 → 日主」
  weight: number;        // 0–1，表示在整体流通中的权重
}

// 流通等级
export type FlowLevel = '流通顺畅' | '整体尚可' | '局部堵塞';

// 能量流通指标（核心数据结构）
export interface EnergyFlowMetrics {
  // 基础信息（复用现有系统参数）
  dmStrengthLevel: '偏弱' | '中和' | '偏强';  // 从 strengthResult.band 映射
  structure: string;               // structureResult.structure
  yongshenSummary: string;         // 从 favoredAvoid 生成：如「用神偏火土，忌金水」
  wuxingBalanceSummary: string;    // 从 wuxingPercent 生成：五行简述

  // 做功路径数据
  workPathCount: number;           // 总路径数
  coreWorkPaths: WorkPath[];       // 1–3 条主链路
  otherWorkPaths: WorkPath[];      // 其余有参考价值的路径

  // 流通度评估
  flowScore: number;               // 0–100
  flowLevel: FlowLevel;            // 基于 flowScore 分档
  mainFlowDirections: FlowDirection[];  // 主要流通方向（最多2条）

  // 风险与提示
  riskFlags: string[];             // 如「思考多行动少」「易过度自我消耗」
  notes: string[];                 // 给 LLM 的简短提示，不展示给用户

  // 调试用（可选）
  debug?: {
    wuxingWeights?: Record<string, number>;  // 木火土金水权重
    tenGodWeights?: Record<string, number>;  // 比劫、食伤、财、官杀、印星等
    patternTags?: string[];                  // 已有的「食伤生财」「印比护官」标签
    rescueTags?: string[];                   // 「食神制杀」「印星化杀」等
  };
}
```

### 1.2 前端卡片接口（与官财格局对齐）

```typescript
export interface EnergyFlowCard {
  type: 'energyFlow';
  title: '能量流通';
  score: number;              // flowScore
  level: FlowLevel;           // 展示为彩色 Tag
  summary: string;            // 一句话总结（来自 buildEnergyFlowSummary）
  corePathLabels: string[];   // 从 coreWorkPaths.label 提取
  content: string;            // LLM 生成正文（3 段）
}
```

---

## 二、字段映射表（与系统参数对齐）

| 新字段                          | 来源模块                       | 现有数据路径（系统参数）                                                      | 转换逻辑                                                    | 状态 |
| ---------------------------- | -------------------------- | --------------------------------------------------------------- | ------------------------------------------------------- | ---- |
| `dmStrengthLevel`            | `daymaster.js`             | `strengthResult.band`                                          | `'从弱'|'身弱' → '偏弱'; '平衡' → '中和'; '身强'|'从强' → '偏强'` | ✅ 一致 |
| `structure`                  | `structure.js`             | `structureResult.structure`                                    | 直接使用                                                      | ✅ 一致 |
| `yongshenSummary`            | `favored.js`               | `favoredAvoid.favored` + `favoredAvoid.avoid`                  | 生成一句话：如「用神偏火土，忌金水」                                      | ⚠️ 需生成 |
| `wuxingBalanceSummary`       | `wuxing.js`                | `wuxingPercent`                                                | 生成一句话：如「五行偏木火，金水偏弱」                                      | ⚠️ 需生成 |
| `workPathCount`              | `dogong.js` + 自定义算法        | `dogongResult.strongestPaths` + `buildWorkPaths()`              | 统计所有有效路径数量                                              | ⚠️ 需计算 |
| `coreWorkPaths`              | `dogong.js` + 自定义算法        | `dogongResult.strongestPaths` + `buildWorkPaths()`              | 取前 1–3 条，且 `strength >= 0.7` 或在 pattern/rescue 标签中有命中        | ⚠️ 需计算 |
| `otherWorkPaths`             | `dogong.js` + 自定义算法        | `dogongResult.strongestPaths` + `buildWorkPaths()`              | 其余路径保持原序                                                | ⚠️ 需计算 |
| `flowScore`                  | `purity.js` + 自定义算法        | `purityResult.details.wuxingFlow` + `calcFlowScore()`          | 综合计算：五行均衡度(30%) + 正向做功(40%) + 救应(20%) - 冲突惩罚(10%)      | ⚠️ 需计算 |
| `flowLevel`                  | `flowScore`                | 同上                                                              | `>= 70: '流通顺畅'; >= 40: '整体尚可'; 其余: '局部堵塞'`        | ✅ 一致 |
| `mainFlowDirections`         | `coreWorkPaths` + 自定义算法     | `buildMainFlowDirections(coreWorkPaths)`                        | 根据核心路径拼接成三段式方向                                          | ⚠️ 需计算 |
| `riskFlags`                  | `W` + `workPaths` + 自定义规则   | 根据简单规则生成：如「W.shi 高但 W.cai/guan 弱 → 思考多行动少」              | 生成风险提示数组                                                | ⚠️ 需生成 |
| `notes`                      | 同上                        | 同上                                                              | 给 LLM 的简短提示，不展示给用户                                      | ⚠️ 需生成 |
| `debug.wuxingWeights`        | `wuxing.js`                | `wuxingPercent`                                                 | 直接使用                                                      | ✅ 一致 |
| `debug.tenGodWeights`        | `structure.js`             | `structureResult.W`                                             | 直接使用                                                      | ✅ 一致 |
| `debug.patternTags`          | `dogong.js` + `generateWorkLineName` | `dogongResult.strongestPaths` + `extractWorkPatternTags()`      | 从最强路径中提取标签                                              | ✅ 一致 |
| `debug.rescueTags`           | `patternPurity.js`         | `patternPurityResult.rescueFactors`                             | 提取救应标签数组                                                | ✅ 一致 |

---

## 三、算法侧实现流程（如何算出这些参数）

### 3.1 做功路径抽取（`buildWorkPaths`）

#### 3.1.1 路径模板配置

```typescript
const WORK_PATH_CONFIG = [
  // 生助类（productive）
  { id: 'shi-cai', label: '食伤生财', type: 'productive', from: 'shi', to: 'cai' },
  { id: 'cai-guan', label: '财生官', type: 'productive', from: 'cai', to: 'guan' },
  { id: 'guan-yin', label: '官印相生', type: 'productive', from: 'guan', to: 'yin' },
  { id: 'yin-bi', label: '印比护身', type: 'productive', from: 'yin', to: 'bi' },
  
  // 救应类（rescue）
  { id: 'yin-bi-guan', label: '印比护官', type: 'rescue', from: 'yin', to: 'guan' },
  { id: 'shi-zhi-sha', label: '食神制杀', type: 'rescue', from: 'shi', to: 'guan' },
  { id: 'yin-hua-sha', label: '印星化杀', type: 'rescue', from: 'yin', to: 'guan' },
  
  // 冲突类（conflict）
  { id: 'shang-guan-guan', label: '伤官见官', type: 'conflict', from: 'shi', to: 'guan' },
  { id: 'bi-duo-cai', label: '比劫夺财', type: 'conflict', from: 'bi', to: 'cai' },
  { id: 'cai-huai-yin', label: '财星坏印', type: 'conflict', from: 'cai', to: 'yin' },
  
  // 克制类（control）
  { id: 'guan-ke-shen', label: '官杀克身', type: 'control', from: 'guan', to: 'bi' },
  { id: 'shen-ke-cai', label: '身克财星', type: 'control', from: 'bi', to: 'cai' },
];
```

#### 3.1.2 路径抽取算法

```typescript
/**
 * 构建做功路径数组
 * @param {Object} W - 十神权重对象
 * @param {Object} dogongResult - 做功分析结果
 * @param {Object} patternPurityResult - 格局纯度结果（包含 rescueFactors）
 * @returns {WorkPath[]} 做功路径数组
 */
function buildWorkPaths(W, dogongResult, patternPurityResult) {
  const paths: WorkPath[] = [];
  
  // 1. 从 dogongResult.strongestPaths 中提取已有路径名称
  const existingPathLabels = new Set();
  if (dogongResult?.strongestPaths) {
    dogongResult.strongestPaths.forEach(path => {
      // 使用 generateWorkLineName 生成路径名称
      const pathName = generateWorkLineName(path.path, path.relations || []);
      if (pathName) {
        existingPathLabels.add(pathName);
      }
    });
  }
  
  // 2. 从 patternPurityResult.rescueFactors 中提取救应标签
  const rescueLabels = new Set();
  if (patternPurityResult?.rescueFactors) {
    patternPurityResult.rescueFactors.forEach(factor => {
      const type = factor.type || '';
      if (type.includes('食神制杀') || type.includes('印星化杀') || 
          type.includes('印比护官') || type.includes('官星制劫')) {
        rescueLabels.add(type);
      }
    });
  }
  
  // 3. 遍历路径模板，判断是否有效
  for (const cfg of WORK_PATH_CONFIG) {
    // 3.1 判断是否在已有标签中命中（优先）
    const tagged = existingPathLabels.has(cfg.label) || rescueLabels.has(cfg.label);
    
    // 3.2 看 from/to 两个十神是否有足够权重
    const fromW = W[cfg.from] ?? 0;
    const toW = W[cfg.to] ?? 0;
    const strength = Math.min(fromW, toW);  // 简单起步：取较弱一方作为链路强度
    
    // 3.3 判断是否有效路径
    if (tagged || strength > 0.5) {
      // 生成方向描述
      const direction = `${mapTenGodName(cfg.from)} → ${mapTenGodName(cfg.to)}`;
      
      // 生成备注
      const notes = [];
      if (fromW < 0.3) notes.push(`${mapTenGodName(cfg.from)}略偏弱`);
      if (toW < 0.3) notes.push(`${mapTenGodName(cfg.to)}略偏弱`);
      if (fromW > 0.7) notes.push(`${mapTenGodName(cfg.from)}较强`);
      if (toW > 0.7) notes.push(`${mapTenGodName(cfg.to)}较强`);
      
      paths.push({
        id: cfg.id,
        label: cfg.label,
        type: cfg.type,
        strength: Math.min(1, strength),
        direction,
        notes: notes.length > 0 ? notes : undefined,
      });
    }
  }
  
  // 4. 按 strength 排序
  paths.sort((a, b) => b.strength - a.strength);
  
  return paths;
}

/**
 * 十神名称映射
 */
function mapTenGodName(key: string): string {
  const map = {
    'shi': '食伤',
    'cai': '财星',
    'guan': '官杀',
    'yin': '印星',
    'bi': '比劫',
  };
  return map[key] || key;
}
```

#### 3.1.3 拆分核心路径和其他路径

**⚠️ 重要说明**：核心路径筛选逻辑采用「强度优先 + 标签命中」策略。

```typescript
/**
 * 拆分核心路径和其他路径
 * @param {WorkPath[]} paths - 所有路径（已按 strength 降序排序）
 * @param {Set<string>} taggedPathLabels - 已在 pattern/rescue 标签中命中的路径标签集合
 * @returns {{coreWorkPaths: WorkPath[]}, otherWorkPaths: WorkPath[]}}
 */
function splitWorkPaths(paths: WorkPath[], taggedPathLabels: Set<string>) {
  const coreWorkPaths: WorkPath[] = [];
  const otherWorkPaths: WorkPath[] = [];
  
  for (const path of paths) {
    // 判断是否在标签中命中（优先）
    const isTagged = taggedPathLabels.has(path.label);
    
    // 核心路径条件：前 1–3 条，且满足以下任一条件：
    // 1. strength >= 0.7（强度足够）
    // 2. 在 pattern/rescue 标签中有命中（算法已识别）
    if (coreWorkPaths.length < 3 && 
        (path.strength >= 0.7 || isTagged)) {
      coreWorkPaths.push(path);
    } else {
      otherWorkPaths.push(path);
    }
  }
  
  // 兜底：如果所有路径都不满足条件，至少取前 1 条作为核心路径（避免空数组）
  if (coreWorkPaths.length === 0 && paths.length > 0) {
    coreWorkPaths.push(paths[0]);
  }
  
  return { coreWorkPaths, otherWorkPaths };
}
```

**核心路径筛选规则（Phase 1）**：

1. **先收集所有"被点名"的路径标签（taggedPathLabels）**，包括：
   - 做功分析 `dogongResult.strongestPaths` 中的路径名称（通过 `generateWorkLineName` 生成）
   - 格局纯度 `patternPurityResult.rescueFactors` 中的救应类型名称

2. **在所有 WorkPath 中筛选**：
   - 若路径在 `taggedPathLabels` 中，且 `strength ≥ 0.5`，优先作为核心候选
   - 若核心路径不足 3 条，再按 `strength` 从高到低补充其他 `productive`/`rescue` 类型路径
   - 若仍不足，再补充 `strength ≥ 0.7` 的其他类型路径

3. **最终结果**：
   - `coreWorkPaths` 不超过 3 条，其余为 `otherWorkPaths`
   - 兜底：如果所有路径都不满足条件，至少取前 1 条作为核心路径（避免空数组）

**策略说明**：
- **标签命中优先**：通过 `taggedPathLabels`（来自 `dogongResult` 和 `rescueFactors`）判断哪些路径是"被点名"的
- **强度补充**：在这些路径里，优先选 `strength` 较高的 1–3 条作为 `coreWorkPaths`
- **未被标签命中的**，再按强度补足

### 3.2 主要流通方向（`buildMainFlowDirections`）

```typescript
/**
 * 构建主要流通方向
 * @param {WorkPath[]} corePaths - 核心做功路径
 * @returns {FlowDirection[]} 主要流通方向（最多2条）
 */
function buildMainFlowDirections(corePaths: WorkPath[]): FlowDirection[] {
  const result: FlowDirection[] = [];
  
  // 示例规则1：食伤→财→官
  const hasShiCai = corePaths.find(p => p.id === 'shi-cai');
  const hasCaiGuan = corePaths.find(p => p.id === 'cai-guan');
  if (hasShiCai && hasCaiGuan) {
    result.push({
      id: 'shi-cai-guan',
      label: '从食伤 → 财星 → 官杀',
      weight: (hasShiCai.strength + hasCaiGuan.strength) / 2,
    });
  }
  
  // 示例规则2：官杀→印星→日主
  const hasGuanYin = corePaths.find(p => p.id === 'guan-yin');
  const hasYinBi = corePaths.find(p => p.id === 'yin-bi');
  if (hasGuanYin && hasYinBi) {
    result.push({
      id: 'guan-yin-rizu',
      label: '从官杀 → 印星 → 日主',
      weight: (hasGuanYin.strength + hasYinBi.strength) / 2,
    });
  }
  
  // 示例规则3：印比→食伤→财
  const hasYinBi2 = corePaths.find(p => p.id === 'yin-bi');
  const hasShiCai2 = corePaths.find(p => p.id === 'shi-cai');
  if (hasYinBi2 && hasShiCai2) {
    result.push({
      id: 'yin-bi-shi-cai',
      label: '从印比 → 食伤 → 财星',
      weight: (hasYinBi2.strength + hasShiCai2.strength) / 2,
    });
  }
  
  // 兜底：如果没找到复合路径，使用单条路径
  if (result.length === 0) {
    for (const p of corePaths.slice(0, 2)) {
      result.push({
        id: p.id,
        label: p.direction,
        weight: p.strength,
      });
    }
  }
  
  return result.slice(0, 2); // 最多给 LLM 2 条主要方向
}
```

### 3.3 流通度分数（`calcFlowScore`）

**⚠️ 重要说明**：权重分配与公式计算保持一致。

```typescript
/**
 * 计算流通度分数
 * @param {Object} wuxingWeights - 五行权重
 * @param {WorkPath[]} workPaths - 所有做功路径
 * @returns {number} 0–100 的分数
 */
function calcFlowScore(wuxingWeights, workPaths) {
  // 1. 五行均衡度：越平均分越高
  const wuxingScore = calcBalanceScore(wuxingWeights); // 0–100
  
  // 2. 正向做功路径强度
  const productivePaths = workPaths.filter(p => p.type === 'productive');
  const productiveScore = avgTopK(
    productivePaths.map(p => p.strength), 
    3
  ) * 100;
  
  // 3. 救应路径
  const rescuePaths = workPaths.filter(p => p.type === 'rescue');
  // Phase 1：使用条数计算（简单稳定）
  // Phase 2（可选优化）：改为使用强度计算，见「后续迭代建议」
  const rescueScore = Math.min(100, rescuePaths.length * 15);
  
  // 4. 冲突 / 堵塞惩罚
  const conflictPaths = workPaths.filter(p => p.type === 'conflict');
  const conflictScore = avgTopK(
    conflictPaths.map(p => p.strength), 
    2
  ) * 100;
  // 惩罚计算：
  // - conflictScore * 0.6：最高扣 60 分（当 conflictScore = 100 时）
  // - penalty * 0.5：在公式中再乘以 0.5，实际最多扣 30 分
  // - 相当于冲突部分最多影响 30% 的分数（但为扣分项）
  const penalty = conflictScore * 0.6; // 最高扣 60 分（在公式中再乘以 0.5，实际最多扣 30 分）
  
  // 5. 综合计算
  // 权重分配（与公式保持一致）：
  // - 五行均衡度：30%（基础平衡）
  // - 正向做功路径强度：40%（核心流通）
  // - 救应路径：20%（自我调节能力）
  // - 冲突惩罚：最多扣 30 分（约 30% 权重，但为扣分项）
  // 
  // 公式说明：
  // raw = wuxingScore * 0.3 + productiveScore * 0.4 + rescueScore * 0.2 - penalty * 0.5
  // 其中 penalty = conflictScore * 0.6，所以实际扣分为 conflictScore * 0.6 * 0.5 = conflictScore * 0.3
  // 当 conflictScore = 100 时，最多扣 30 分
  const raw =
    wuxingScore * 0.3 +
    productiveScore * 0.4 +
    rescueScore * 0.2 -
    penalty * 0.5;
  
  return clamp(raw, 0, 100);
}

**调参建议**（后续迭代）：
当有足够样本后，建议：
- 把实际用户分布与主观命理解读对比
- 视情况微调：冲突惩罚的上限（从 30 分下调到 20 分或更低）
- 根据数据反馈调整各权重配比（五行均衡、正向做功、救应路径的权重）

/**
 * 计算五行均衡度
 */
function calcBalanceScore(wuxingWeights) {
  const values = Object.values(wuxingWeights);
  const avg = values.reduce((a, b) => a + b, 0) / values.length;
  const variance = values.reduce((sum, v) => sum + Math.pow(v - avg, 2), 0) / values.length;
  const stdDev = Math.sqrt(variance);
  
  // 标准差越小，均衡度越高
  // 假设标准差 0–20 映射到 0–100 分
  return Math.max(0, Math.min(100, 100 - stdDev * 5));
}

/**
 * 取前 K 个值的平均值
 */
function avgTopK(arr, k) {
  if (arr.length === 0) return 0;
  const sorted = [...arr].sort((a, b) => b - a);
  const topK = sorted.slice(0, k);
  return topK.reduce((a, b) => a + b, 0) / topK.length;
}

/**
 * 限制数值范围
 */
function clamp(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
```

### 3.4 风险标志与提示（`generateRiskFlags`）

**⚠️ 重要说明**：风险标志生成采用「规则判断 + 强度门槛」策略，避免过度敏感。

```typescript
/**
 * 生成风险标志和提示
 * @param {Object} W - 十神权重
 * @param {WorkPath[]} workPaths - 所有做功路径
 * @returns {{riskFlags: string[], notes: string[]}}
 */
function generateRiskFlags(W, workPaths) {
  const riskFlags: string[] = [];
  const notes: string[] = [];
  
  // 规则1：思考多行动少
  if (W.shi > 0.5 && (W.cai < 0.3 || W.guan < 0.3)) {
    riskFlags.push('思考多行动少');
    notes.push('食伤强但财官弱，容易停留在头脑中，需要加强落地执行');
  }
  
  // 规则2：易过度自我消耗
  const conflictPaths = workPaths.filter(p => p.type === 'conflict');
  // Phase 1：使用条数判断（简单稳定）
  // Phase 2（可选优化）：改为使用强度判断，见「后续迭代建议」
  if (conflictPaths.length >= 2) {
    riskFlags.push('易过度自我消耗');
    notes.push('存在多条冲突路径，容易在高压下一边冲一边卡，需要注意节奏');
  }
  
  // 规则3：能量容易卡在某个环节
  const productivePaths = workPaths.filter(p => p.type === 'productive');
  if (productivePaths.length === 0) {
    riskFlags.push('能量容易卡在某个环节');
    notes.push('缺少正向做功路径，能量流通不畅');
  }
  
  return { riskFlags, notes };
}
```

### 3.5 用神总结生成（`generateYongshenSummary`）

```typescript
/**
 * 生成用神总结
 * @param {Object} favoredAvoid - 喜用神结果
 * @returns {string} 一句话总结
 */
function generateYongshenSummary(favoredAvoid) {
  const favored = favoredAvoid.favored || [];
  const avoid = favoredAvoid.avoid || [];
  
  if (favored.length === 0 && avoid.length === 0) {
    return '用神不显';
  }
  
  const favoredStr = favored.length > 0 ? `用神偏${favored.join('、')}` : '';
  const avoidStr = avoid.length > 0 ? `忌${avoid.join('、')}` : '';
  
  if (favoredStr && avoidStr) {
    return `${favoredStr}，${avoidStr}`;
  } else if (favoredStr) {
    return favoredStr;
  } else {
    return avoidStr;
  }
}
```

### 3.6 五行平衡总结生成（`generateWuxingBalanceSummary`）

```typescript
/**
 * 生成五行平衡总结
 * @param {Object} wuxingPercent - 五行百分比
 * @returns {string} 一句话总结
 */
function generateWuxingBalanceSummary(wuxingPercent) {
  const elements = ['木', '火', '土', '金', '水'];
  const sorted = elements
    .map(el => ({ element: el, percent: wuxingPercent[el] || 0 }))
    .sort((a, b) => b.percent - a.percent);
  
  const strong = sorted.filter(s => s.percent >= 25).map(s => s.element);
  const weak = sorted.filter(s => s.percent < 15).map(s => s.element);
  
  let summary = '';
  if (strong.length > 0) {
    summary += `五行偏${strong.join('、')}`;
  }
  if (weak.length > 0) {
    summary += summary ? `，${weak.join('、')}偏弱` : `${weak.join('、')}偏弱`;
  }
  
  return summary || '五行相对均衡';
}
```

### 3.7 一句话总结生成（`buildEnergyFlowSummary`）

**⚠️ 重要说明**：首版使用规则拼句子，简单好控；后续可根据用户反馈考虑使用 LLM 润色。

```typescript
/**
 * 生成能量流通一句话总结（用于卡片头部展示）
 * @param {EnergyFlowMetrics} metrics - 能量流通指标
 * @returns {string} 一句话总结
 */
function buildEnergyFlowSummary(metrics: EnergyFlowMetrics): string {
  const { flowLevel, coreWorkPaths, riskFlags } = metrics;
  
  // 获取最强路径
  const mainPath = coreWorkPaths && coreWorkPaths.length > 0 
    ? coreWorkPaths[0].label 
    : null;
  
  // 获取首个风险标志（如果有）
  const risk = riskFlags && riskFlags.length > 0 ? riskFlags[0] : null;
  
  // 根据流通等级生成总结
  const levelText = flowLevel; // 流通顺畅 / 整体尚可 / 局部堵塞
  
  // 规则版本：基于 flowLevel + 最强核心路径 + 首个风险标志
  if (risk && mainPath) {
    return `整体${levelText}，以「${mainPath}」为主轴，容易在「${risk}」这一环节卡住。`;
  } else if (mainPath) {
    return `整体${levelText}，能量主要通过「${mainPath}」流动。`;
  } else {
    return `整体${levelText}，能量流通以内外转换为主。`;
  }
}
```

**使用位置**：
- 在 `buildEnergyFlowMetrics` 函数中调用，将结果添加到返回对象的 `summary` 字段
- 前端卡片头部展示使用

**后续优化方向**（Phase 2）：
- 等有了足够多样本、知道用户喜欢什么风格，再考虑让大模型来润色这一句
- 可以基于 `flowLevel`、`coreWorkPaths`、`mainFlowDirections` 等更多信息生成更丰富的总结

---

## 四、组装函数设计（与官财格局对齐）

### 4.1 函数签名

```typescript
/**
 * 组装「能量流通」数据（纯函数）
 * 
 * 纯函数设计：
 * - 只做取值 + 映射 + 规则判断
 * - 不调用 async 函数
 * - 不操作全局状态
 * - 所有异步计算在上游完成
 * 
 * @param {Object} structureResult - 格局分析结果
 * @param {Object} strengthResult - 日主强弱结果
 * @param {Object} favoredAvoid - 喜用神结果
 * @param {Object} wuxingPercent - 五行百分比
 * @param {Object} dogongResult - 做功分析结果
 * @param {Object} patternPurityResult - 格局纯度结果
 * @param {Object} purityResult - 清浊分析结果
 * @returns {EnergyFlowMetrics} 能量流通指标
 */
function buildEnergyFlowMetrics(
  structureResult,
  strengthResult,
  favoredAvoid,
  wuxingPercent,
  dogongResult,
  patternPurityResult,
  purityResult
) {
  // 实现见下文
}
```

### 4.2 实现位置

在 `core/engine/index.js` 的 `BaziEngine` 类中添加：

```javascript
/**
 * 组装「能量流通」数据
 */
buildEnergyFlowMetrics(
  structureResult,
  strengthResult,
  favoredAvoid,
  wuxingPercent,
  dogongResult,
  patternPurityResult,
  purityResult
) {
  // 1. 提取 W 对象（十神权重）
  const W = structureResult.W || structureResult._internal?.W || {};
  
  // 2. 映射日主强弱等级
  const dmStrengthLevel = this.mapDmStrengthLevel(strengthResult?.band);
  
  // 3. 生成用神总结
  const yongshenSummary = this.generateYongshenSummary(favoredAvoid);
  
  // 4. 生成五行平衡总结
  const wuxingBalanceSummary = this.generateWuxingBalanceSummary(wuxingPercent);
  
  // 5. 构建做功路径
  const allWorkPaths = this.buildWorkPaths(W, dogongResult, patternPurityResult);
  const { coreWorkPaths, otherWorkPaths } = this.splitWorkPaths(allWorkPaths);
  
  // 6. 构建主要流通方向
  const mainFlowDirections = this.buildMainFlowDirections(coreWorkPaths);
  
  // 7. 计算流通度分数
  const flowScore = this.calcFlowScore(wuxingPercent, allWorkPaths);
  const flowLevel = this.mapFlowLevel(flowScore);
  
  // 8. 生成风险标志和提示
  const { riskFlags, notes } = this.generateRiskFlags(W, allWorkPaths);
  
  // 9. 生成一句话总结
  const summary = this.buildEnergyFlowSummary({
    flowLevel,
    coreWorkPaths,
  });
  
  // 10. 组装返回对象
  return {
    dmStrengthLevel,
    structure: structureResult.structure || '未知格局',
    yongshenSummary,
    wuxingBalanceSummary,
    workPathCount: allWorkPaths.length,
    coreWorkPaths,
    otherWorkPaths,
    flowScore,
    flowLevel,
    mainFlowDirections,
    summary,  // 一句话总结
    riskFlags,
    notes,
    // 调试用
    debug: {
      wuxingWeights: wuxingPercent,
      tenGodWeights: W,
      patternTags: this.extractWorkPatternTags(dogongResult),
      rescueTags: (patternPurityResult?.rescueFactors || []).map(f => f.type),
    },
  };
}

/**
 * 映射日主强弱等级
 */
mapDmStrengthLevel(band) {
  if (!band) return '中和';
  if (band === '从弱' || band === '身弱') return '偏弱';
  if (band === '平衡') return '中和';
  if (band === '身强' || band === '从强') return '偏强';
  return '中和';
}

/**
 * 映射流通等级
 */
mapFlowLevel(score) {
  if (score >= 70) return '流通顺畅';
  if (score >= 40) return '整体尚可';
  return '局部堵塞';
}
```

### 4.3 在 `BaziEngine.compute()` 中调用

```javascript
// 在 analysis 对象中添加
analysis: {
  // ... 其他字段
  energyFlow: this.buildEnergyFlowMetrics(
    structureResult,
    strengthResult,
    favoredAvoid,
    wuxingPercent,
    dogongResult,
    patternPurityResult,
    purityResult
  )
}
```

---

## 五、LLM Prompt 模板

### 5.1 Prompt 模板（与官财格局对齐）

```typescript
/**
 * 构建能量流通 Prompt
 * @param {EnergyFlowMetrics} metrics - 能量流通指标
 * @param {string} userQuestion - 用户问题（可选）
 * @returns {string} Prompt 文本
 */
/**
 * 构建能量流通 Prompt（核心函数）
 * @param {EnergyFlowMetrics} metrics - 能量流通指标
 * @param {string} userQuestion - 用户问题（可选）
 * @returns {string} Prompt 文本
 */
function buildEnergyFlowPromptCore(metrics: EnergyFlowMetrics, userQuestion?: string): string {
  const {
    dmStrengthLevel,
    structure,
    yongshenSummary,
    wuxingBalanceSummary,
    workPathCount,
    coreWorkPaths,
    otherWorkPaths,
    flowScore,
    flowLevel,
    mainFlowDirections,
    notes,
  } = metrics;
  
  // 格式化核心做功路径
  const corePathsStr = coreWorkPaths
    .map(p => `${p.label}（${p.direction}）`)
    .join('、');
  
  // 格式化主要流通方向
  const flowDirectionsStr = mainFlowDirections
    .map(d => d.label)
    .join('、');
  
  return `你是「小佩」，一位专业的八字命理 AI 助手。

现在要为用户生成一段「能量流通」解读，用在命盘报告中的《能量流通》卡片里。

【命盘与结构概览】

- 日主强弱：${dmStrengthLevel}${strengthSummary ? `（${strengthSummary}）` : ''}
- 格局类型：${structure}
- 用神喜忌：${yongshenSummary}
- 五行概况：${wuxingBalanceSummary}

【做功与流向数据】

- 做功路径数量：${workPathCount}
- 核心做功路径：${corePathsStr}
- 其他典型路径：${(otherWorkPaths && otherWorkPaths.length > 0) ? otherWorkPaths.map(p => p.label).join('、') : '无'}
- 流通度分数：${flowScore}（0–100，${flowLevel}）
- 主要流通方向：${flowDirectionsStr || '无'}
- 其他算法备注：${(notes && notes.length > 0) ? notes.join('；') : '无'}

【写作目标】

1. 用通俗的语言解释：命盘中的五行、十神是如何「流通」「做功」的。
2. 告诉用户：哪些能量链路顺畅、哪里容易卡住，会对应怎样的思维或做事风格。
3. 给出 2–3 条温和、可执行的建议，帮助用户更好地顺着自己的能量模式做事。

【写作结构】

请用三段文字完成解读，每一段是自然段，不要使用标题或列表格式。

第 1 段：整体概括
- 用 2–3 句话概括整体流通情况，说明流通度是偏顺畅、一般，还是容易在某一段卡住。
- 可以点出 1–2 条最重要的做功路径和五行偏重，但不要展开细节。

第 2 段：能量运行方式
- 展开描述主要做功路径的风格，例如偏「先思考再行动」「先感受再决策」「重效率与结果」「重关系与安全感」等。
- 说明哪些环节容易「过头」或「用力过猛」（如输出太多、控制欲偏强），哪些地方容易「断开」或「忽略」（如行动跟不上想法、照顾别人多于照顾自己）。
- 语言中可以结合核心做功路径和主要流通方向，但不需要列举全部技术细节。
- 注意避免绝对化用语，不要使用「注定」「必然失败」「一定会」之类的说法，改用「容易、倾向、需要留意」等表达。

第 3 段：生活与行动建议
- 提供 2–3 条自然融入段落的建议（不用项目符号），内容包括：
  - 在什么类型的事情或角色上，更容易顺着自己的能量模式发挥优势。
  - 当感觉卡住、效率下降或情绪反复时，可以从哪一环节调整，例如「把压力拆分为小步骤」「先把想法写下来再行动」「适当向专业人士或信任的人求助」等。
  - 强调命盘只是提供一个关于能量模式的观察角度，真正决定人生走向的是当下的选择与行动。

【风格要求】

- 使用简体中文，不要使用 emoji 或特殊符号。
- 语气专业但亲切，避免恐吓式表达，不过度夸大吉凶。
- 不复述《命局总览》《用神格局》《官财格局》已详细说过的内容，只在需要时简短呼应。
- 总字数控制在 350–500 字之间。

${userQuestion ? `\n【用户问题】\n${userQuestion}\n` : ''}`;
}
```

### 5.2 在 Reading 服务中使用

**⚠️ 函数命名说明**：为避免命名冲突，核心构造函数命名为 `buildEnergyFlowPromptCore`，外层封装函数命名为 `buildEnergyFlowPrompt`。

```typescript
// 在 core/src/modules/prompt/promptTemplates.ts 中添加

/**
 * 构建能量流通 Prompt 核心函数（内部使用）
 * @param {EnergyFlowMetrics} metrics - 能量流通指标
 * @param {string} userQuestion - 用户问题（可选）
 * @param {string} strengthSummary - 日主强弱详细说明（可选，来自 strengthResult.summary 或 strengthResult.comment）
 * @returns {string} Prompt 文本
 */
function buildEnergyFlowPromptCore(
  metrics: EnergyFlowMetrics, 
  userQuestion?: string,
  strengthSummary?: string
): string {
  // ... 实现见上文
}

/**
 * 构建能量流通 Prompt（对外接口，用于 Reading 服务）
 * @param {Object} params - 参数对象
 * @param {string} params.userQuestion - 用户问题
 * @param {any} params.baziData - 命盘数据
 * @returns {string} Prompt 文本
 */
function buildEnergyFlowPrompt(params: {
  userQuestion: string;
  baziData: any;
}): string {
  const { userQuestion, baziData } = params;
  
  const energyFlow = baziData?.analysis?.energyFlow;
  
  if (!energyFlow) {
    return `你现在要解读用户命盘的「能量流通」部分，但数据尚未生成。请告知用户稍后再试。`;
  }
  
  // 从 strengthResult 中提取详细说明（回退逻辑）
  // 策略：
  // - 若 strengthResult.summary 存在：使用该字段作为 strengthSummary
  // - 若不存在：仅输出「偏弱 / 中和 / 偏强」三个档位，不额外补充解释
  const strengthSummary = baziData?.analysis?.strength?.summary || 
                          baziData?.analysis?.strength?.comment || 
                          undefined;
  
  // 调用核心函数
  return buildEnergyFlowPromptCore(energyFlow, userQuestion, strengthSummary);
}
```

---

## 六、前端适配

### 6.1 类型定义（`app/src/types/chart.ts`）

```typescript
// 在 BaziChartDto 的 analysis 中添加
energyFlow?: {
  dmStrengthLevel: '偏弱' | '中和' | '偏强';
  structure: string;
  yongshenSummary: string;
  wuxingBalanceSummary: string;
  workPathCount: number;
  coreWorkPaths: Array<{
    id: string;
    label: string;
    type: 'productive' | 'control' | 'rescue' | 'conflict';
    strength: number;
    direction: string;
    notes?: string[];
  }>;
  otherWorkPaths: Array<{
    id: string;
    label: string;
    type: 'productive' | 'control' | 'rescue' | 'conflict';
    strength: number;
    direction: string;
    notes?: string[];
  }>;
  flowScore: number;
  flowLevel: '流通顺畅' | '整体尚可' | '局部堵塞';
  mainFlowDirections: Array<{
    id: string;
    label: string;
    weight: number;
  }>;
  riskFlags: string[];
  notes: string[];
};
```

### 6.2 UI 组件（`app/src/screens/ChartDetail/ChartOverviewTab.tsx`）

```typescript
{/* 能量流通卡 */}
<TouchableOpacity
  style={styles.card}
  activeOpacity={0.7}
  onPress={() => handleOneClickRead('energyFlow', '請詳細解讀我的能量流通')}
>
  <View style={styles.cardHeader}>
    <Text style={styles.cardTitle}>能量流通</Text>
    <Text style={styles.oneClickReadTag}>{t('chartDetail.overview.oneClickRead')}</Text>
  </View>
  {result?.analysis?.energyFlow ? (
    <View style={styles.indicatorContainer}>
      {/* 流通度分数 */}
      <View style={styles.indicatorRow}>
        <Text style={styles.indicatorLabel}>流通度：</Text>
        <Text style={styles.indicatorValue}>
          {result.analysis.energyFlow.flowScore}/100 · {result.analysis.energyFlow.flowLevel}
        </Text>
      </View>
      
      {/* 核心做功路径 */}
      {result.analysis.energyFlow.coreWorkPaths.length > 0 && (
        <View style={styles.indicatorRow}>
          <Text style={styles.indicatorLabel}>核心做功：</Text>
          <View style={styles.tagContainer}>
            {result.analysis.energyFlow.coreWorkPaths.map((path, idx) => (
              <View key={idx} style={styles.tag}>
                <Text style={styles.tagText}>{path.label}</Text>
              </View>
            ))}
          </View>
        </View>
      )}
      
      {/* 主要流通方向 */}
      {result.analysis.energyFlow.mainFlowDirections.length > 0 && (
        <View style={styles.indicatorRow}>
          <Text style={styles.indicatorLabel}>主要流向：</Text>
          <Text style={styles.indicatorValue}>
            {result.analysis.energyFlow.mainFlowDirections.map(d => d.label).join('、')}
          </Text>
        </View>
      )}
      
      {/* 做功路径数量 */}
      <View style={styles.indicatorRow}>
        <Text style={styles.indicatorLabel}>做功路径：</Text>
        <Text style={styles.indicatorValue}>
          {result.analysis.energyFlow.workPathCount}条
        </Text>
      </View>
    </View>
  ) : (
    <Text style={styles.placeholderText}>能量流通（待實現）</Text>
  )}
</TouchableOpacity>
```

---

## 七、实施步骤

### Phase 1: 引擎层实现 ✅（待实施）

1. ✅ 在 `core/engine/index.js` 中添加 `buildEnergyFlowMetrics` 函数
2. ✅ 实现所有辅助函数（`buildWorkPaths`、`buildMainFlowDirections`、`calcFlowScore` 等）
3. ✅ 在 `BaziEngine.compute()` 中调用并组装数据
4. ✅ 测试数据组装逻辑

### Phase 2: Prompt 模板 ✅（待实施）

1. ✅ 在 `core/src/modules/prompt/promptTemplates.ts` 中添加 `buildEnergyFlowPrompt` 函数
2. ✅ 测试 Prompt 生成

### Phase 3: 类型定义 ✅（待实施）

1. ✅ 在 `app/src/types/chart.ts` 中添加 `energyFlow` 类型定义

### Phase 4: 前端UI ✅（待实施）

1. ✅ 在 `ChartOverviewTab.tsx` 中添加"能量流通卡"
2. ✅ 测试UI显示效果

---

## 八、注意事项

### 8.1 向后兼容

- 保留原有的 `analysis.structure`、`analysis.dogong` 等字段，不删除
- 前端可以同时支持多种卡片（通过配置切换，或逐步迁移）

### 8.2 数据完整性

- 如果某个模块的计算结果缺失，使用默认值或空数组，避免前端报错
- 所有可选字段（如 `notes`、`debug`）都要做空值检查

### 8.3 性能考虑

- `buildWorkPaths` 函数需要遍历路径模板和 `dogongResult.strongestPaths`，但数据量小，性能影响可忽略
- `calcFlowScore` 计算简单，性能影响可忽略

### 8.4 与系统参数对齐

- ✅ 所有数据来源都来自现有系统参数，不新增计算模块
- ✅ 复用现有的 `generateWorkLineName`、`extractWorkPatternTags` 等函数
- ✅ 与「官财格局」卡片保持结构对齐，方便维护

---

## 九、待确认事项

1. **路径模板扩展**：是否需要增加更多路径模板？建议先实现基础版本，后续根据用户反馈扩展。

2. **流通度分数权重**：当前权重配比（五行均衡30% + 正向做功40% + 救应20% - 冲突惩罚10%）是否需要调整？建议先实现，后续根据实际效果微调。

3. **风险标志规则**：当前规则较简单，是否需要增加更多规则？建议先实现基础版本，后续根据用户反馈扩展。

4. **一句话总结生成**：是否需要使用 LLM 生成一句话总结，还是用简单规则生成？建议先用简单规则，后续可优化为 LLM 生成。

---

## 十、总结

### ✅ 与系统参数一致的部分

- 日主强弱：使用 `strengthResult.band`
- 格局类型：使用 `structureResult.structure`
- 用神结果：使用 `favoredAvoid.favored` 和 `favoredAvoid.avoid`
- 五行权重：使用 `wuxingPercent`
- 十神权重：使用 `structureResult.W`
- 做功路径：复用 `dogongResult.strongestPaths` 和 `generateWorkLineName`
- 救应标签：使用 `patternPurityResult.rescueFactors`
- 流通度基础：复用 `purityResult.details.wuxingFlow`

### ⚠️ 需要补充/适配的部分

#### 1. `generateYongshenSummary` - 用神总结生成

**现有系统状态**：
- ✅ `favoredAvoid` 已有 `favored` 和 `avoid` 数组（来自 `computeFavoredAvoid`）
- ❌ 没有格式化函数，需要实现

**实现方案**：
- **位置**：`core/engine/index.js` 的 `BaziEngine` 类中
- **输入**：`favoredAvoid` 对象 `{ favored: ['火', '土'], avoid: ['金', '水'] }`
- **输出**：字符串，如 `"用神偏火、土，忌金、水"`
- **逻辑**：
  1. 检查 `favored` 和 `avoid` 数组是否为空
  2. 格式化：`favored` → `"用神偏${favored.join('、')}"`
  3. 格式化：`avoid` → `"忌${avoid.join('、')}"`
  4. 拼接：如果两者都有，用 `"，"` 连接；如果只有一个，直接返回
  5. 兜底：如果都为空，返回 `"用神不显"`
- **复杂度**：O(1)，简单字符串拼接
- **复用性**：可被其他卡片复用（如用神格局卡片）

#### 2. `generateWuxingBalanceSummary` - 五行平衡总结生成

**现有系统状态**：
- ✅ `wuxingPercent` 已有五行百分比（来自 `computeWuXing`）
- ✅ `purity.js` 中有 `evaluateWuxingBalance` 函数计算平衡度，但只返回分数
- ❌ 没有格式化函数，需要实现

**实现方案**：
- **位置**：`core/engine/index.js` 的 `BaziEngine` 类中
- **输入**：`wuxingPercent` 对象 `{ 木: 32, 火: 18, 土: 20, 金: 15, 水: 15 }`
- **输出**：字符串，如 `"五行偏木、火，金、水偏弱"`
- **逻辑**：
  1. 遍历五行数组 `['木', '火', '土', '金', '水']`
  2. 按百分比降序排序
  3. 找出偏强的五行：`percent >= 25`（阈值可调）
  4. 找出偏弱的五行：`percent < 15`（阈值可调）
  5. 格式化：
     - 如果有偏强的：`"五行偏${strong.join('、')}"`
     - 如果有偏弱的：`"，${weak.join('、')}偏弱"` 或 `"${weak.join('、')}偏弱"`
  6. 兜底：如果都均衡（都在 15-25 之间），返回 `"五行相对均衡"`
- **复杂度**：O(1)，固定5个元素
- **阈值说明**：
  - 偏强阈值 25%：平均 20%，超过 25% 算偏强
  - 偏弱阈值 15%：平均 20%，低于 15% 算偏弱
  - 可根据实际效果调整

#### 3. `buildWorkPaths` - 做功路径抽取

**现有系统状态**：
- ✅ `dogongResult.strongestPaths` 已有路径数组（来自 `analyzeDogong`）
- ✅ `generateWorkLineName` 已有路径名称生成函数（在 `BaziEngine` 类中）
- ✅ `extractWorkPatternTags` 已有标签提取函数
- ❌ 没有基于路径模板和 W 值判断的逻辑，需要实现

**实现方案**：
- **位置**：`core/engine/index.js` 的 `BaziEngine` 类中
- **输入**：
  - `W` 对象（十神权重）
  - `dogongResult`（做功分析结果）
  - `patternPurityResult`（格局纯度结果，包含 `rescueFactors`）
- **输出**：`WorkPath[]` 数组
- **逻辑**：
  1. **定义路径模板**（`WORK_PATH_CONFIG`）：
     - 包含常见路径：`'食伤生财'`、`'官印相生'`、`'印比护官'` 等
     - 每个模板包含：`id`、`label`、`type`、`from`、`to`
  2. **提取已有路径标签**：
     - 从 `dogongResult.strongestPaths` 中提取，使用 `generateWorkLineName` 生成名称
     - 从 `patternPurityResult.rescueFactors` 中提取救应标签
  3. **遍历路径模板**：
     - 判断是否在已有标签中命中（优先）
     - 判断 `from` 和 `to` 两个十神的 W 值是否足够（`strength = min(W[from], W[to])`）
     - 如果 `tagged || strength > 0.5`，则添加为有效路径
  4. **生成路径对象**：
     - `id`：模板的 `id`
     - `label`：模板的 `label`
     - `type`：模板的 `type`（`'productive'`、`'rescue'`、`'conflict'`、`'control'`）
     - `strength`：`Math.min(1, strength)`
     - `direction`：`"${mapTenGodName(from)} → ${mapTenGodName(to)}"`
     - `notes`：根据 W 值生成备注（如 `"食伤略偏弱"`）
  5. **排序**：按 `strength` 降序
- **复杂度**：O(n)，n 为路径模板数量（约 10-15 个）
- **复用性**：可被其他分析模块复用

#### 4. `buildMainFlowDirections` - 主要流通方向

**现有系统状态**：
- ✅ `coreWorkPaths` 已有核心做功路径（来自 `buildWorkPaths`）
- ❌ 没有拼接成三段式方向的逻辑，需要实现

**实现方案**：
- **位置**：`core/engine/index.js` 的 `BaziEngine` 类中
- **输入**：`coreWorkPaths` 数组（`WorkPath[]`）
- **输出**：`FlowDirection[]` 数组（最多2条）
- **逻辑**：
  1. **定义复合路径规则**：
     - 规则1：`'shi-cai'` + `'cai-guan'` → `"从食伤 → 财星 → 官杀"`
     - 规则2：`'guan-yin'` + `'yin-bi'` → `"从官杀 → 印星 → 日主"`
     - 规则3：`'yin-bi'` + `'shi-cai'` → `"从印比 → 食伤 → 财星"`
  2. **遍历规则**：
     - 检查 `coreWorkPaths` 中是否同时存在规则中的两个路径
     - 如果存在，生成复合方向，权重为两个路径强度的平均值
  3. **兜底策略**：
     - 如果没找到复合路径，使用单条路径的 `direction` 作为方向
     - 最多返回 2 条
- **复杂度**：O(n)，n 为 `coreWorkPaths` 数量（通常 1-3 条）
- **扩展性**：后续可根据实际效果增加更多复合规则

#### 5. `calcFlowScore` - 流通度分数计算

**现有系统状态**：
- ✅ `purityResult.details.wuxingFlow` 已有五行流通分数（0-20分，因为只占20%）
- ✅ `purity.js` 中有 `evaluateWuxingBalance` 和 `evaluateFlowChain` 函数
- ❌ 没有综合多个因素计算 0-100 流通度分数的逻辑，需要实现

**实现方案**：
- **位置**：`core/engine/index.js` 的 `BaziEngine` 类中
- **输入**：
  - `wuxingPercent`（五行百分比）
  - `workPaths`（所有做功路径）
  - `purityResult.details.wuxingFlow`（可选，作为参考）
- **输出**：0-100 的分数
- **逻辑**：
  1. **五行均衡度**（30%）：
     - 计算标准差：`stdDev = sqrt(variance)`
     - 映射到 0-100：`score = 100 - stdDev * 5`（标准差 0-20 映射到 100-0）
     - 最终得分：`wuxingScore = clamp(score, 0, 100)`
  2. **正向做功路径强度**（40%）：
     - 筛选 `type === 'productive'` 的路径
     - 取前 3 条，计算平均强度：`avgTopK(strengths, 3)`
     - 映射到 0-100：`productiveScore = avgTopK * 100`
  3. **救应路径**（20%）：
     - 筛选 `type === 'rescue'` 的路径
     - 计算：`rescueScore = min(100, rescuePaths.length * 15)`（每条救应路径 15 分）
  4. **冲突惩罚**（10%）：
     - 筛选 `type === 'conflict'` 的路径
     - 取前 2 条，计算平均强度：`avgTopK(strengths, 2)`
     - 惩罚：`penalty = conflictScore * 0.6`（最高扣 60 分）
  5. **综合计算**：
     ```
     raw = wuxingScore * 0.3 + productiveScore * 0.4 + rescueScore * 0.2 - penalty * 0.5
     flowScore = clamp(raw, 0, 100)
     ```
- **复杂度**：O(n)，n 为 `workPaths` 数量
- **权重说明**：
  - 正向做功 40%：最重要，体现能量流通的核心
  - 五行均衡 30%：基础，体现整体平衡
  - 救应路径 20%：加分项，体现自我调节能力
  - 冲突惩罚 10%：扣分项，体现阻塞程度
  - 权重可根据实际效果调整

#### 6. `generateRiskFlags` - 风险标志生成

**现有系统状态**：
- ✅ `W` 对象已有十神权重
- ✅ `workPaths` 已有做功路径（来自 `buildWorkPaths`）
- ❌ 没有基于规则生成风险提示的逻辑，需要实现

**实现方案**：
- **位置**：`core/engine/index.js` 的 `BaziEngine` 类中
- **输入**：
  - `W` 对象（十神权重）
  - `workPaths`（所有做功路径）
- **输出**：`{ riskFlags: string[], notes: string[] }`
- **逻辑**：
  1. **规则1：思考多行动少**
     - 条件：`W.shi > 0.5 && (W.cai < 0.3 || W.guan < 0.3)`
     - 风险标志：`"思考多行动少"`
     - 提示：`"食伤强但财官弱，容易停留在头脑中，需要加强落地执行"`
  2. **规则2：易过度自我消耗**
     - 条件：`conflictPaths.length >= 2`
     - 风险标志：`"易过度自我消耗"`
     - 提示：`"存在多条冲突路径，容易在高压下一边冲一边卡，需要注意节奏"`
  3. **规则3：能量容易卡在某个环节**
     - 条件：`productivePaths.length === 0`
     - 风险标志：`"能量容易卡在某个环节"`
     - 提示：`"缺少正向做功路径，能量流通不畅"`
  4. **规则4：输出过多但缺少承接**
     - 条件：`W.shi > 0.6 && W.cai < 0.2`
     - 风险标志：`"输出过多但缺少承接"`
     - 提示：`"食伤过旺但财星偏弱，容易想法多但变现难"`
  5. **规则5：控制欲过强**
     - 条件：`W.guan > 0.6 && W.yin < 0.2`
     - 风险标志：`"控制欲过强"`
     - 提示：`"官杀过旺但印星偏弱，容易压力大但缺少内在支撑"`
- **复杂度**：O(n)，n 为规则数量（约 5-10 条）
- **扩展性**：后续可根据用户反馈增加更多规则
- **复用性**：可被其他分析模块复用（如用神格局、官财格局）

---

## 实现优先级建议

### Phase 1（核心功能，必须实现）
1. ✅ `generateYongshenSummary` - 简单，直接复用 `favoredAvoid`
2. ✅ `generateWuxingBalanceSummary` - 简单，直接复用 `wuxingPercent`
3. ✅ `buildWorkPaths` - 核心功能，需要路径模板和 W 值判断

### Phase 2（增强功能，建议实现）
4. ✅ `calcFlowScore` - 核心功能，综合多个因素
5. ✅ `buildMainFlowDirections` - 增强功能，提升 LLM 理解

### Phase 3（优化功能，可选实现）
6. ✅ `generateRiskFlags` - 优化功能，提供风险提示

---

## 实现注意事项

1. **与现有系统对齐**：
   - 所有函数都应该是纯函数，不修改输入参数
   - 所有函数都应该有防御性编程（空值检查、默认值）
   - 所有函数都应该有清晰的注释

2. **性能考虑**：
   - 所有函数复杂度都是 O(1) 或 O(n)，n 很小（< 20）
   - 不需要优化，性能影响可忽略

3. **测试建议**：
   - 每个函数都应该有单元测试
   - 测试用例应该覆盖边界情况（空数组、空对象等）

4. **扩展性**：
   - 路径模板、风险规则等应该放在配置文件中，方便后续扩展
   - 阈值（如偏强 25%、偏弱 15%）应该作为常量，方便调整

---

## 十一、后续迭代建议（不影响先上线）

以下优化点可以在上线后根据用户反馈和数据效果逐步迭代，不影响首版功能。

### 11.1 救应分数改为使用强度计算（P1：强烈建议做）

**当前实现**（Phase 1）：
```typescript
const rescueScore = Math.min(100, rescuePaths.length * 15);
```

**优化方案**（Phase 2）：
```typescript
// 使用强度而非条数，质量比数量更重要
const rescueScore = avgTopK(rescuePaths.map(p => p.strength), 2) * 100;
```

**理由**：有 1 条很强救应和 3 条很弱救应，应该区别对待。对分数合理性影响大。

---

### 11.2 风险标志增加强度门槛（P1：强烈建议做）

**当前实现**（Phase 1）：
```typescript
if (conflictPaths.length >= 2) {
  riskFlags.push('易过度自我消耗');
}
```

**优化方案**（Phase 2）：
```typescript
// 只统计强度较高的冲突路径
const strongConflicts = conflictPaths.filter(p => p.strength > 0.6);
if (strongConflicts.length >= 1) {
  riskFlags.push('易过度自我消耗');
}
```

**理由**：避免"有两条很弱的冲突"也被说得太严重。防止文案太"吓人"，用户感知明显。

---

### 11.3 增加 `control` 类型风险判断（P2：有空就做）

**当前实现**（Phase 1）：
- 只判断 `conflict` 类型的风险
- `control` 类型（如「官杀克身」「身克财」）未纳入风险判断

**优化方案**（Phase 2）：
在 `generateRiskFlags` 中增加针对 `control` 类型的规则：

```typescript
// 规则：官杀克身强 → 压力、规训感强
const guanKeShenPaths = workPaths.filter(
  p => p.type === 'control' && p.id === 'guan-ke-shen'
);
const strongGuanKeShen = guanKeShenPaths.filter(p => p.strength > 0.6);
if (strongGuanKeShen.length >= 1) {
  riskFlags.push('压力与规训感较强');
  notes.push('官杀克身过重，容易感受到较强的外部压力和规训感，需要适当放松和自我调节');
}

// 规则：身克财强 → 在钱、资源上会比较用力、容易过度消耗
const shenKeCaiPaths = workPaths.filter(
  p => p.type === 'control' && p.id === 'shen-ke-cai'
);
const strongShenKeCai = shenKeCaiPaths.filter(p => p.strength > 0.6);
if (strongShenKeCai.length >= 1) {
  riskFlags.push('在资源使用上容易过度用力');
  notes.push('身克财过重，容易在钱、资源上用力过猛，需要注意适度');
}
```

**理由**：如果一个命盘是「官杀克身很重」或「身克财很狠」，但算法里只归类为 `control`，风险提示会偏温和。体验锦上添花。

---

### 11.4 丰富 `mainFlowDirections` 的规则（P2：有空就做）

**当前实现**（Phase 1）：
- 主要规则：食伤→财→官、官→印→日主、印比→食伤→财

**优化方案**（Phase 2）：
根据用户反馈增加更多复合规则：

```typescript
// 规则4：比劫→食伤→财（团队/伙伴→输出→变现）
const hasBiShi = corePaths.find(p => p.id === 'bi-shi');
const hasShiCai = corePaths.find(p => p.id === 'shi-cai');
if (hasBiShi && hasShiCai) {
  result.push({
    id: 'bi-shi-cai',
    label: '从比劫 → 食伤 → 财星',
    weight: (hasBiShi.strength + hasShiCai.strength) / 2,
  });
}

// 规则5：印→日主→食伤（学习内化→自我→表达）
const hasYinRizu = corePaths.find(p => p.id === 'yin-rizu');
const hasRizuShi = corePaths.find(p => p.id === 'rizu-shi');
if (hasYinRizu && hasRizuShi) {
  result.push({
    id: 'yin-rizu-shi',
    label: '从印星 → 日主 → 食伤',
    weight: (hasYinRizu.strength + hasRizuShi.strength) / 2,
  });
}
```

**理由**：这些都不影响现阶段上线，算"口味增强"。体验锦上添花。

---

### 11.5 一句话总结 LLM 化（P3：数据积累后再考虑）

**当前实现**（Phase 1）：
- 使用规则拼句子，简单好控（见 3.7 节）

**优化方案**（Phase 2）：
等有了足够多样本、知道用户喜欢什么风格，再考虑让大模型来润色这一句。

**理由**：需要数据积累，了解用户偏好后再优化。

---

### 11.6 路径模板扩展（P3：数据积累后再考虑）

**当前实现**（Phase 1）：
- 基础路径模板约 10-15 个

**优化方案**（Phase 2）：
根据用户反馈和实际命盘数据，逐步增加更多路径模板，如：
- 「印星化杀」
- 「比劫护财」
- 「食伤泄秀」
- 等

**理由**：需要数据积累，根据实际命盘反馈扩展。

---

## 十二、落地前检查清单

### ✅ 必须修复的问题（落地前完成）

- [ ] **核心路径筛选逻辑**：确保使用 `taggedPathLabels` 判断，而非仅依赖 `type`
- [ ] **权重说明一致性**：确保文档中的权重说明与公式计算一致
- [ ] **Prompt 中的"例如"问题**：移除或替换为真实的 `strengthSummary`
- [ ] **函数命名**：确保 `buildEnergyFlowPromptCore` 和 `buildEnergyFlowPrompt` 命名不冲突
- [ ] **空值保护**：确保所有数组操作都有空值检查（`notes`、`otherWorkPaths` 等）

### ✅ 建议完成的优化（不影响上线，但建议完成）

- [ ] **一句话总结生成**：实现 `buildEnergyFlowSummary` 函数（规则拼句子）
- [ ] **防御性编程**：所有函数都有空值检查和默认值
- [ ] **代码注释**：所有函数都有清晰的注释说明

### ⏳ 后续迭代（上线后根据反馈优化）

- [ ] 救应分数改为使用强度计算
- [ ] 风险标志增加强度门槛
- [ ] 增加 `control` 类型风险判断
- [ ] 丰富 `mainFlowDirections` 的规则
- [ ] 路径模板扩展

### ✅ 工程化检查项（落地前完成）

- [ ] **日志与调试输出**：
  - 确认在 debug 模式 / 内部环境下，可以方便打印：
    * `analysis.energyFlow.flowScore`
    * `coreWorkPaths` / `mainFlowDirections`
    * `riskFlags`
  - 方便用几张真实命盘做对比调试

- [ ] **缺失数据兜底策略验证**：
  - 人为制造几种异常情况：缺 `dogongResult`、缺 `patternPurityResult`、缺 `wuxingPercent`
  - 确认：
    * 不会抛异常
    * 前端卡片能优雅展示"数据暂不完整"或简单版结果

---

**文档版本**：v1.1  
**创建时间**：2024年12月  
**最后更新**：2024年12月（根据反馈优化）  
**维护者**：开发团队

**更新内容**：
- v1.0：初始版本，完整实施方案
- v1.1：根据反馈优化
  - 修复核心路径筛选逻辑说明
  - 修正权重说明与公式一致性
  - 优化 Prompt 模板（移除"例如"问题）
  - 明确函数命名规范
  - 加强空值保护说明
  - 添加后续迭代建议章节
  - 添加落地前检查清单

