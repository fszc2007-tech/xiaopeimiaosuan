# 配偶星状态计算方案

## 一、计算逻辑说明

### 1. 强弱判断（基于十神权重）

**数据来源**：`analysis.structure.W` 或 `analysis.structure.tenGodWeights`

**计算方式**：
```typescript
// 获取配偶星权重
const spouseStarWeight = spouseStarType === '财星'
  ? (W.cai || 0)  // 财星总权重
  : ((W.guan || 0) + (W.sha || 0));  // 官杀总权重

// 判断强弱等级
const level = spouseStarWeight < 0.3 ? '偏弱'
  : spouseStarWeight > 0.7 ? '偏旺'
  : '中等';
```

**阈值说明**：
- `< 0.3`：偏弱（配偶星力量不足）
- `0.3 - 0.7`：中等（配偶星力量适中）
- `> 0.7`：偏旺（配偶星力量过强）

---

### 2. 是否混杂判断（正偏混杂）

**数据来源**：`analysis.structure.W` 中的细分权重

**计算方式**：

#### 2.1 官杀混杂（女命）
```typescript
// 检查正官和七杀是否同时存在
const hasZhengGuan = (W.zGuan || W.zhengGuan || 0) > 0;
const hasQiSha = (W.sha || W.qiSha || 0) > 0;
const mixed = hasZhengGuan && hasQiSha;
```

**参考系统函数**：`core/engine/analysis/purity.js` 中的 `hasGuanShaHunZa` 函数

#### 2.2 财星混杂（男命）
```typescript
// 检查正财和偏财是否同时存在
const hasZhengCai = (W.zCai || W.zhengCai || 0) > 0;
const hasPianCai = (W.pCai || W.pianCai || 0) > 0;
const mixed = hasZhengCai && hasPianCai;
```

**注意**：系统可能使用不同的字段名，需要兼容：
- `zCai` / `zhengCai` / `正财`
- `pCai` / `pianCai` / `偏财`

---

### 3. 是否被克冲判断（冲突分析）

**数据来源**：
- `analysis.structure.W`（十神权重）
- `analysis.pogeFactors`（破格因素，包含冲突信息）
- `pillars`（四柱数据，用于检查具体位置）

**计算方式**：

#### 3.1 使用破格因素判断（推荐）

系统已经计算了破格因素，可以直接使用：

```typescript
function checkSpouseStarConflict(
  pogeFactors: any[],
  spouseStarType: '财星' | '官杀'
): boolean {
  if (!pogeFactors || pogeFactors.length === 0) return false;
  
  // 财星被克的情况
  if (spouseStarType === '财星') {
    // 检查是否有"比劫夺财"相关的破格因素
    return pogeFactors.some(factor => 
      factor.type?.includes('比劫夺财') ||
      factor.type?.includes('比劫') && factor.description?.includes('财')
    );
  }
  
  // 官杀被克的情况
  if (spouseStarType === '官杀') {
    // 检查是否有"食伤制官"相关的破格因素
    return pogeFactors.some(factor => 
      factor.type?.includes('食伤制官') ||
      factor.type?.includes('伤官见官') ||
      factor.type?.includes('食伤') && factor.description?.includes('官')
    );
  }
  
  return false;
}
```

#### 3.2 使用十神权重直接判断（备选方案）

如果 `pogeFactors` 不可用，可以基于十神权重直接判断：

```typescript
function checkSpouseStarConflictByWeight(
  W: any,
  spouseStarType: '财星' | '官杀'
): boolean {
  // 财星被克：比劫夺财
  if (spouseStarType === '财星') {
    const biJieWeight = (W.bi || 0) + (W.jie || 0);
    const caiWeight = W.cai || 0;
    // 比劫力量强且财星力量弱，容易夺财
    return biJieWeight > 0.5 && caiWeight < 0.5;
  }
  
  // 官杀被克：食伤制官
  if (spouseStarType === '官杀') {
    const shiShangWeight = (W.shi || 0) + (W.shang || 0);
    const guanShaWeight = (W.guan || 0) + (W.sha || 0);
    // 食伤力量强且官杀力量弱，容易制官
    return shiShangWeight > 0.5 && guanShaWeight < 0.5;
  }
  
  return false;
}
```

#### 3.3 使用系统冲突评估函数（最准确）

系统中有 `evaluateConflictsNew` 函数，但它是内部函数，需要检查是否可以复用：

```typescript
// 参考：core/engine/analysis/purity.js 中的 evaluateConflictsNew
// 该函数检查了以下冲突：
// 1. 财印冲突（财星坏印）
// 2. 比劫夺财
// 3. 枭神夺食
// 4. 食伤制官
// 5. 官杀混杂

// 我们可以基于这个逻辑，检查配偶星相关的冲突
function checkSpouseStarConflictBySystem(
  pillars: any,
  W: any,
  spouseStarType: '财星' | '官杀'
): boolean {
  // 财星被克：检查"比劫夺财"
  if (spouseStarType === '财星') {
    // 需要检查是否有比劫夺财的情况
    // 参考：hasBiJieDuoCai 函数的逻辑
    // 但该函数是内部函数，可能需要重新实现
  }
  
  // 官杀被克：检查"食伤制官"
  if (spouseStarType === '官杀') {
    // 需要检查是否有食伤制官的情况
    // 参考：hasShangGuan 函数的逻辑
  }
  
  return false;
}
```

---

## 二、完整实现函数

### 函数签名

```typescript
function analyzeSpouseStarStatus(
  W: any,                    // 十神权重对象
  spouseStarType: '财星' | '官杀',
  structure: any,            // 格局分析结果（包含 pogeFactors）
  pillars?: any              // 四柱数据（可选，用于更精确的判断）
): {
  level: string;             // '偏弱' | '中等' | '偏旺'
  mixed: boolean;            // 是否混杂
  conflict: boolean;         // 是否被克冲
  description: string;       // 文字描述
}
```

### 实现代码

```typescript
import { tenGodOf } from '../../../engine/analysis/utils.js';

/**
 * 分析配偶星状态
 */
export function analyzeSpouseStarStatus(
  W: any,
  spouseStarType: '财星' | '官杀',
  structure: any,
  pillars?: any
): {
  level: string;
  mixed: boolean;
  conflict: boolean;
  description: string;
} {
  // ========== 1. 判断强弱 ==========
  const spouseStarWeight = spouseStarType === '财星'
    ? (W.cai || W.caiXing || 0)
    : ((W.guan || W.guanSha || 0) + (W.sha || W.qiSha || 0));
  
  const level = spouseStarWeight < 0.3 ? '偏弱'
    : spouseStarWeight > 0.7 ? '偏旺'
    : '中等';
  
  // ========== 2. 判断是否混杂 ==========
  let mixed = false;
  
  if (spouseStarType === '财星') {
    // 财星混杂：正财和偏财同时存在
    const hasZhengCai = (W.zCai || W.zhengCai || 0) > 0;
    const hasPianCai = (W.pCai || W.pianCai || 0) > 0;
    mixed = hasZhengCai && hasPianCai;
  } else {
    // 官杀混杂：正官和七杀同时存在
    const hasZhengGuan = (W.zGuan || W.zhengGuan || 0) > 0;
    const hasQiSha = (W.sha || W.qiSha || 0) > 0;
    mixed = hasZhengGuan && hasQiSha;
  }
  
  // ========== 3. 判断是否被克冲 ==========
  let conflict = false;
  
  // 优先使用破格因素判断
  const pogeFactors = structure?.pogeFactors || structure?.breaking?.factors || [];
  
  if (spouseStarType === '财星') {
    // 财星被克：比劫夺财
    conflict = pogeFactors.some((factor: any) => 
      factor.type?.includes('比劫夺财') ||
      (factor.type?.includes('比劫') && factor.description?.includes('财'))
    );
    
    // 如果破格因素中没有，使用权重判断
    if (!conflict) {
      const biJieWeight = (W.bi || 0) + (W.jie || 0);
      conflict = biJieWeight > 0.5 && spouseStarWeight < 0.5;
    }
  } else {
    // 官杀被克：食伤制官
    conflict = pogeFactors.some((factor: any) => 
      factor.type?.includes('食伤制官') ||
      factor.type?.includes('伤官见官') ||
      (factor.type?.includes('食伤') && factor.description?.includes('官'))
    );
    
    // 如果破格因素中没有，使用权重判断
    if (!conflict) {
      const shiShangWeight = (W.shi || 0) + (W.shang || 0);
      conflict = shiShangWeight > 0.5 && spouseStarWeight < 0.5;
    }
  }
  
  // ========== 4. 生成描述 ==========
  const description = buildSpouseStarDescription(level, mixed, conflict, spouseStarType);
  
  return { level, mixed, conflict, description };
}

/**
 * 生成配偶星状态描述
 */
function buildSpouseStarDescription(
  level: string,
  mixed: boolean,
  conflict: boolean,
  spouseStarType: '财星' | '官杀'
): string {
  const parts: string[] = [];
  
  // 强弱描述
  if (level === '偏弱') {
    parts.push(`${spouseStarType}力量偏弱`);
  } else if (level === '偏旺') {
    parts.push(`${spouseStarType}力量偏旺`);
  } else {
    parts.push(`${spouseStarType}力量中等`);
  }
  
  // 混杂描述
  if (mixed) {
    if (spouseStarType === '财星') {
      parts.push('正偏财混杂');
    } else {
      parts.push('官杀混杂');
    }
  }
  
  // 冲突描述
  if (conflict) {
    if (spouseStarType === '财星') {
      parts.push('容易被比劫所夺');
    } else {
      parts.push('容易被食伤所制');
    }
  }
  
  return parts.join('，') || `${spouseStarType}状态正常`;
}
```

---

## 三、系统已有函数参考

### 1. 官杀混杂检查

**位置**：`core/engine/analysis/purity.js`

**函数**：
```javascript
function hasGuanShaHunZa(pillars) {
  if (!pillars || !pillars.day) return false;
  const dayMaster = pillars.day.stem;
  
  let hasZhengGuan = false;
  let hasQiSha = false;
  
  for (const pos of ['year', 'month', 'day', 'hour']) {
    const pillar = pillars[pos];
    if (!pillar) continue;
    const tg = tenGodOf(dayMaster, pillar.stem);
    if (tg === '正官') hasZhengGuan = true;
    if (tg === '七杀') hasQiSha = true;
  }
  
  return hasZhengGuan && hasQiSha;
}
```

**说明**：该函数只检查天干，不检查地支藏干。如果需要更精确，可以扩展检查藏干。

### 2. 冲突评估

**位置**：`core/engine/analysis/purity.js`

**函数**：`evaluateConflictsNew(pillars, W, dayMaster)`

**检查的冲突类型**：
1. 财印冲突（财星坏印）
2. 比劫夺财
3. 枭神夺食
4. 食伤制官
5. 官杀混杂

**说明**：该函数返回冲突分数，不是布尔值。我们可以参考其逻辑，但需要自己实现布尔判断。

### 3. 破格因素分析

**位置**：`core/engine/analysis/poge.js`

**函数**：`analyzePoGeFactors(pillars, W, structureName, strength)`

**返回**：`{ factors, context }`

**说明**：该函数已经分析了各种破格因素，包括：
- 官杀混杂
- 比劫夺财
- 财多身弱
- 等等

**建议**：优先使用 `pogeFactors` 来判断冲突，因为系统已经计算好了。

---

## 四、注意事项

### 1. 字段名兼容性

系统可能使用不同的字段名，需要兼容：
- `W.cai` / `W.caiXing` / `W.财星`
- `W.zCai` / `W.zhengCai` / `W.正财`
- `W.pCai` / `W.pianCai` / `W.偏财`
- `W.guan` / `W.guanSha` / `W.官杀`
- `W.zGuan` / `W.zhengGuan` / `W.正官`
- `W.sha` / `W.qiSha` / `W.七杀`

### 2. 权重阈值

当前使用的阈值（0.3、0.7）是基于系统其他部分的经验值，可能需要根据实际效果调整。

### 3. 混杂判断的精确度

当前混杂判断只检查是否存在，不检查强度。如果需要更精确，可以检查权重：
```typescript
// 更精确的混杂判断
const mixed = hasZhengGuan && hasQiSha && 
  (W.zGuan > 0.3 || W.sha > 0.3);  // 至少有一个权重较高
```

### 4. 冲突判断的优先级

建议优先级：
1. **优先**：使用 `pogeFactors` 判断（系统已计算）
2. **备选**：使用十神权重直接判断
3. **最后**：如果需要更精确，可以检查四柱具体位置

---

## 五、总结

### 计算方式总结

| 判断项 | 计算方式 | 数据来源 | 复杂度 |
|--------|---------|---------|--------|
| **强弱** | 基于权重阈值 | `W.cai` 或 `W.guan + W.sha` | 简单 |
| **混杂** | 检查正偏是否同时存在 | `W.zCai/pCai` 或 `W.zGuan/sha` | 简单 |
| **被克冲** | 优先使用破格因素，备选权重判断 | `pogeFactors` 或 `W` | 中等 |

### 实现建议

1. **强弱判断**：直接基于权重，阈值可调
2. **混杂判断**：检查正偏是否同时存在，逻辑简单
3. **被克冲判断**：优先使用 `pogeFactors`，如果没有则用权重判断

### 是否需要新增函数

**需要新增**：`analyzeSpouseStarStatus` 函数

**不需要新增**：混杂和冲突的判断逻辑可以直接实现，不需要单独的函数（除非需要复用）

---

## 六、测试建议

1. **强弱判断**：测试不同权重值（0.2、0.5、0.8）是否正确判断
2. **混杂判断**：测试只有正财、只有偏财、正偏财都有三种情况
3. **冲突判断**：测试有破格因素、无破格因素两种情况

