# 小佩系统高并发优化方案

**分析时间**: 2025-01-XX  
**系统版本**: v1.0.1  
**目标**: 支持 1万+ QPS，延迟 < 200ms（P95）

---

## 一、系统现状分析

### 1.1 架构概览

```
┌─────────────┐         ┌─────────────┐
│    app/     │────────▶│    core/    │
│  (React Native) │  HTTP   │  (Express) │
└─────────────┘  API    └─────────────┘
                            │
                            ▼
                    ┌─────────────┐
                    │   MySQL     │
                    └─────────────┘
```

**技术栈**:
- 后端: Express + TypeScript + MySQL
- 前端: React Native + Expo
- 数据库: MySQL (InnoDB)
- 缓存: node-cache (仅系统配置)

### 1.2 当前瓶颈识别

#### 🔴 **严重瓶颈**（影响并发能力）

1. **数据库连接池过小**
   - 当前: `connectionLimit: 10`
   - 问题: 高并发时连接耗尽，请求排队
   - 影响: 直接限制并发上限

2. **限流实现效率低**
   - 当前: 每次请求都查数据库 (`rate_limits` 表)
   - 问题: 增加数据库压力，延迟高
   - 影响: 限流本身成为瓶颈

3. **缺少 Redis 缓存层**
   - 当前: 仅用内存缓存（node-cache）缓存系统配置
   - 问题: 无法跨进程共享，无法缓存热点数据
   - 影响: 大量重复数据库查询

4. **LLM 调用无重试机制**
   - 当前: 单次调用，60秒超时
   - 问题: 网络抖动导致失败，无降级策略
   - 影响: 用户体验差，错误率高

5. **单进程运行**
   - 当前: 单 Node.js 进程
   - 问题: 无法利用多核 CPU，单点故障
   - 影响: 吞吐量上限低

#### 🟡 **中等瓶颈**（影响性能和稳定性）

6. **日志系统简陋**
   - 当前: `console.log` 输出
   - 问题: 无法追踪请求链路，难以排查问题
   - 影响: 运维困难

7. **缺少监控和指标**
   - 当前: 无 APM、无指标收集
   - 问题: 无法发现性能问题，无法预警
   - 影响: 被动响应，用户体验差

8. **数据库索引可能不足**
   - 当前: 有基本索引
   - 问题: 复杂查询可能未优化
   - 影响: 慢查询拖累整体性能

9. **错误处理不完善**
   - 当前: 基本错误处理，无熔断器
   - 问题: 依赖服务故障会级联影响
   - 影响: 系统稳定性差

10. **无请求队列**
    - 当前: 同步处理所有请求
    - 问题: 突发流量直接压垮系统
    - 影响: 无法削峰填谷

---

## 二、优化方案（按优先级）

### 2.1 P0 - 立即优化（影响并发上限）

#### 方案 1: 扩大数据库连接池

**现状**:
```typescript
// core/src/database/connection.ts
connectionLimit: 10,  // ❌ 太小
queueLimit: 0,        // ❌ 无队列限制
```

**优化建议**:
```typescript
connectionLimit: 50,        // 根据服务器配置调整（建议: CPU核心数 * 10）
queueLimit: 100,            // 允许排队，避免直接拒绝
acquireTimeout: 60000,       // 获取连接超时
idleTimeout: 300000,         // 空闲连接超时（5分钟）
maxIdle: 10,                 // 最大空闲连接数
```

**预期效果**:
- 并发能力提升 **5倍**（10 → 50）
- 减少连接等待时间

**实施成本**: ⭐ 低（仅修改配置）

---

#### 方案 2: 引入 Redis 缓存层

**架构变更**:
```
┌─────────┐         ┌─────────┐         ┌─────────┐
│  App    │────────▶│  Core   │────────▶│  Redis  │
└─────────┘         └─────────┘         └─────────┘
                            │
                            ▼
                    ┌─────────┐
                    │  MySQL  │
                    └─────────┘
```

**缓存策略**:

1. **限流计数缓存**（Redis）
   - Key: `rate_limit:{userId}:{apiType}:{date}`
   - TTL: 24小时
   - 操作: INCR + EXPIRE
   - **效果**: 限流查询从 DB → Redis，延迟从 10ms → 1ms

2. **系统配置缓存**（Redis）
   - Key: `system_setting:{key}`
   - TTL: 5分钟
   - **效果**: 跨进程共享，减少 DB 查询

3. **热点数据缓存**（Redis）
   - 命盘结果: `bazi_chart:{chartId}` (TTL: 1小时)
   - 用户信息: `user:{userId}` (TTL: 5分钟)
   - LLM 配置: `llm_config:{model}` (TTL: 10分钟)

4. **会话缓存**（Redis）
   - JWT Token 黑名单: `token_blacklist:{token}` (TTL: 7天)

**预期效果**:
- 数据库 QPS 降低 **60-80%**
- API 响应时间降低 **30-50%**
- 限流查询延迟降低 **90%**

**实施成本**: ⭐⭐ 中（需要引入 Redis，修改代码）

---

#### 方案 3: 优化限流实现

**当前实现问题**:
```typescript
// 每次请求都查数据库
const [limitRows]: any = await pool.query(
  `SELECT count FROM rate_limits 
   WHERE user_id = ? AND api_type = ? AND date = ?`,
  [userId, apiType, today]
);
```

**优化方案 A: Redis 计数器**（推荐）
```typescript
// 使用 Redis INCR
const key = `rate_limit:${userId}:${apiType}:${today}`;
const count = await redis.incr(key);
if (count === 1) {
  await redis.expire(key, 86400); // 24小时
}
// 异步同步到数据库（后台任务）
```

**优化方案 B: 内存 + 定期同步**
```typescript
// 内存计数器（Map）
const rateLimitMap = new Map<string, number>();
// 每5分钟批量同步到数据库
```

**预期效果**:
- 限流查询延迟: 10ms → 1ms
- 数据库压力降低 **80%**

**实施成本**: ⭐⭐ 中（需要 Redis 或重构限流逻辑）

---

### 2.2 P1 - 重要优化（提升稳定性和性能）

#### 方案 4: LLM 调用优化

**当前问题**:
- 无重试机制
- 无超时降级
- 无熔断器

**优化建议**:

1. **重试机制**
```typescript
async function callLLMWithRetry(params, maxRetries = 3) {
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await provider.chatStream(request);
    } catch (error) {
      if (i === maxRetries - 1) throw error;
      // 指数退避: 1s, 2s, 4s
      await sleep(1000 * Math.pow(2, i));
    }
  }
}
```

2. **超时降级**
```typescript
// 主模型超时 → 切换到备用模型
// 或返回缓存结果
```

3. **熔断器**（Circuit Breaker）
```typescript
// 连续失败 N 次 → 熔断 → 等待 M 秒 → 半开 → 恢复
```

**预期效果**:
- 错误率降低 **50%**
- 用户体验提升

**实施成本**: ⭐⭐⭐ 高（需要重构 LLM 调用逻辑）

---

#### 方案 5: 进程集群（Cluster Mode）

**当前**: 单进程

**优化**: Node.js Cluster
```typescript
import cluster from 'cluster';
import os from 'os';

if (cluster.isPrimary) {
  const numWorkers = os.cpus().length;
  for (let i = 0; i < numWorkers; i++) {
    cluster.fork();
  }
} else {
  // 启动 Express 服务器
  startServer();
}
```

**或使用 PM2**:
```json
{
  "instances": "max",
  "exec_mode": "cluster"
}
```

**预期效果**:
- 吞吐量提升 **N倍**（N = CPU核心数）
- 单进程崩溃不影响整体

**实施成本**: ⭐⭐ 中（需要配置进程管理）

---

#### 方案 6: 数据库查询优化

**检查项**:

1. **慢查询日志**
```sql
SET GLOBAL slow_query_log = 'ON';
SET GLOBAL long_query_time = 1; -- 1秒
```

2. **索引优化**
```sql
-- 检查缺失索引
EXPLAIN SELECT ...;

-- 常见优化点:
-- - conversations 表: (user_id, created_at)
-- - messages 表: (conversation_id, created_at)
-- - rate_limits 表: (user_id, api_type, date) -- 已有
```

3. **连接池监控**
```typescript
pool.on('connection', (connection) => {
  console.log('New connection:', connection.threadId);
});
pool.on('acquire', (connection) => {
  console.log('Connection acquired:', connection.threadId);
});
```

**预期效果**:
- 慢查询减少 **70%**
- 数据库 CPU 使用率降低

**实施成本**: ⭐ 低（主要是分析和优化）

---

### 2.3 P2 - 长期优化（提升可观测性和运维能力）

#### 方案 7: 结构化日志

**当前**: `console.log`

**优化**: Winston / Pino
```typescript
import winston from 'winston';

const logger = winston.createLogger({
  format: winston.format.json(),
  transports: [
    new winston.transports.File({ filename: 'error.log', level: 'error' }),
    new winston.transports.File({ filename: 'combined.log' }),
  ],
});

// 请求日志中间件
app.use((req, res, next) => {
  const start = Date.now();
  res.on('finish', () => {
    logger.info({
      method: req.method,
      path: req.path,
      status: res.statusCode,
      duration: Date.now() - start,
      userId: req.userId,
    });
  });
  next();
});
```

**预期效果**:
- 问题排查时间减少 **80%**
- 支持日志聚合和分析

**实施成本**: ⭐⭐ 中

---

#### 方案 8: 监控和指标收集

**工具选择**:
- **APM**: New Relic / Datadog / 自建 Prometheus
- **指标**: Prometheus + Grafana
- **告警**: AlertManager

**关键指标**:
```typescript
// 1. 请求指标
- QPS (每秒请求数)
- 响应时间 (P50, P95, P99)
- 错误率

// 2. 系统指标
- CPU 使用率
- 内存使用率
- 数据库连接数

// 3. 业务指标
- 限流触发次数
- LLM 调用成功率
- 缓存命中率
```

**实施成本**: ⭐⭐⭐ 高（需要搭建监控系统）

---

#### 方案 9: 请求队列和削峰

**场景**: 突发流量（如营销活动）

**方案**: Bull / BullMQ (基于 Redis)
```typescript
import Queue from 'bull';

const baziQueue = new Queue('bazi-compute', {
  redis: { host: 'localhost', port: 6379 },
  limiter: {
    max: 100,        // 每秒最多 100 个任务
    duration: 1000,
  },
});

// 生产者
baziQueue.add({ userId, birthInfo });

// 消费者
baziQueue.process(async (job) => {
  return await computeChart(job.data);
});
```

**预期效果**:
- 系统稳定性提升
- 支持削峰填谷

**实施成本**: ⭐⭐⭐ 高

---

## 三、优化路线图

### Phase 1: 快速提升（1-2周）
1. ✅ 扩大数据库连接池（1天）
2. ✅ 引入 Redis 缓存（3-5天）
3. ✅ 优化限流实现（2-3天）

**预期效果**: 并发能力提升 **5-10倍**

---

### Phase 2: 稳定性提升（2-4周）
4. ✅ LLM 调用重试和降级（1周）
5. ✅ 进程集群（2-3天）
6. ✅ 数据库查询优化（1周）

**预期效果**: 错误率降低 **50%**，吞吐量提升 **N倍**（N = CPU核心数）

---

### Phase 3: 可观测性（4-6周）
7. ✅ 结构化日志（1周）
8. ✅ 监控和指标（2-3周）
9. ✅ 请求队列（可选，1-2周）

**预期效果**: 运维效率提升，问题发现时间缩短

---

## 四、性能目标

### 4.1 目标指标

| 指标 | 当前（估算） | 目标 | 提升 |
|------|------------|------|------|
| **QPS** | ~100 | 10,000+ | 100倍 |
| **P95 延迟** | ~500ms | < 200ms | 60% |
| **错误率** | ~5% | < 1% | 80% |
| **数据库连接数** | 10 | 50 | 5倍 |
| **缓存命中率** | 0% | > 80% | - |

### 4.2 压测建议

**工具**: k6 / JMeter / locust

**测试场景**:
1. **基准测试**: 单接口 QPS 上限
2. **负载测试**: 正常流量下的性能
3. **压力测试**: 超出正常流量 2-3 倍
4. **稳定性测试**: 长时间运行（24小时）

**关键接口**:
- `POST /api/v1/bazi/chart` (排盘)
- `POST /api/v1/chat/conversations/:id/messages` (对话)
- `GET /api/v1/bazi/charts` (列表)

---

## 五、成本评估

### 5.1 基础设施成本

| 组件 | 当前 | 优化后 | 增量成本 |
|------|------|--------|---------|
| **服务器** | 1台（2核4G） | 2-3台（4核8G） | +200% |
| **Redis** | 无 | 1台（1核2G） | +100% |
| **数据库** | 1台（2核4G） | 1台（4核8G） | +100% |
| **监控** | 无 | 可选（云服务） | +50% |

**总计**: 基础设施成本增加 **约 2-3倍**

### 5.2 开发成本

- **Phase 1**: 1-2周（1-2人）
- **Phase 2**: 2-4周（1-2人）
- **Phase 3**: 4-6周（1人）

**总计**: 约 **2-3个月**（1-2人）

---

## 六、风险评估

### 6.1 技术风险

| 风险 | 影响 | 概率 | 应对 |
|------|------|------|------|
| Redis 单点故障 | 高 | 中 | 主从复制 + 哨兵 |
| 数据库连接池配置不当 | 中 | 低 | 压测验证 |
| 缓存一致性问题 | 中 | 中 | 缓存失效策略 |
| 进程集群内存泄漏 | 高 | 低 | 监控 + 定期重启 |

### 6.2 业务风险

- **数据一致性**: 引入缓存后，需要确保数据一致性
- **用户体验**: 优化过程中可能短暂影响服务
- **成本增加**: 基础设施成本增加 2-3倍

---

## 七、实施建议

### 7.1 优先级排序

1. **P0（立即）**: 连接池 + Redis + 限流优化
2. **P1（重要）**: LLM 重试 + 进程集群 + DB 优化
3. **P2（长期）**: 日志 + 监控 + 队列

### 7.2 分阶段实施

- **不要一次性改完**，分阶段上线
- **每个阶段都要压测验证**
- **保留回滚方案**

### 7.3 监控先行

- **先搭建监控**，再优化
- **建立基线指标**，对比优化效果
- **设置告警阈值**

---

## 八、总结

### 8.1 关键优化点

1. ✅ **数据库连接池**: 10 → 50（5倍提升）
2. ✅ **Redis 缓存**: 减少 60-80% 数据库查询
3. ✅ **限流优化**: 延迟降低 90%
4. ✅ **进程集群**: 吞吐量提升 N倍（N = CPU核心数）
5. ✅ **LLM 重试**: 错误率降低 50%

### 8.2 预期效果

- **并发能力**: 100 QPS → 10,000+ QPS（**100倍**）
- **响应时间**: 500ms → < 200ms（**60%提升**）
- **错误率**: 5% → < 1%（**80%降低**）

### 8.3 下一步行动

1. **确认优化优先级**（P0/P1/P2）
2. **制定详细实施计划**
3. **搭建压测环境**
4. **开始 Phase 1 实施**

---

**报告生成时间**: 2025-01-XX  
**分析工具**: Cursor AI  
**文档版本**: v1.0




